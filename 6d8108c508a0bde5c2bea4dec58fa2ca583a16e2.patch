diff --git a/base/renderprogs/blendLight.pixel b/base/renderprogs/blendLight.pixel
new file mode 100644
index 0000000..3a06661
--- /dev/null
+++ b/base/renderprogs/blendLight.pixel
@@ -0,0 +1,46 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+uniform sampler2D samp1 : register(s1);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float4 texcoord0 : TEXCOORD0_centroid;
+	float2 texcoord1 : TEXCOORD1_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	result.color = idtex2Dproj( samp0, fragment.texcoord0 ) * tex2D( samp1, fragment.texcoord1 ) * rpColor;
+}
diff --git a/base/renderprogs/blendLight.vertex b/base/renderprogs/blendLight.vertex
new file mode 100644
index 0000000..b024f18
--- /dev/null
+++ b/base/renderprogs/blendLight.vertex
@@ -0,0 +1,59 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 binormal : BINORMAL;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float4 texcoord0 : TEXCOORD0;
+	float2 texcoord1 : TEXCOORD1;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0.x = dot4( vertex.position, rpTexGen0S );
+	result.texcoord0.y = dot4( vertex.position, rpTexGen0T );
+	result.texcoord0.z = 0.0;
+	result.texcoord0.w = dot4( vertex.position, rpTexGen0Q );
+
+	result.texcoord1.x = dot4( vertex.position, rpTexGen1S );
+	result.texcoord1.y = 0.5;
+}
diff --git a/base/renderprogs/bumpyenvironment.pixel b/base/renderprogs/bumpyenvironment.pixel
new file mode 100644
index 0000000..6afc026
--- /dev/null
+++ b/base/renderprogs/bumpyenvironment.pixel
@@ -0,0 +1,67 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform samplerCUBE	samp0 : register(s0); // texture 0 is the cube map
+uniform sampler2D	samp1 : register(s1); // normal map
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float2 texcoord0	: TEXCOORD0_centroid;
+	float3 texcoord1	: TEXCOORD1_centroid;
+	float3 texcoord2	: TEXCOORD2_centroid;
+	float3 texcoord3	: TEXCOORD3_centroid;
+	float3 texcoord4	: TEXCOORD4_centroid;
+	float4 color		: COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	float4 bump = tex2D( samp1, fragment.texcoord0 ) * 2.0f - 1.0f;
+	float3 localNormal = float3( bump.wy, 0.0f );
+	localNormal.z = sqrt( 1.0f - dot3( localNormal, localNormal ) );
+
+	float3 globalNormal;
+	globalNormal.x = dot3( localNormal, fragment.texcoord2 );
+	globalNormal.y = dot3( localNormal, fragment.texcoord3 );
+	globalNormal.z = dot3( localNormal, fragment.texcoord4 );
+
+	float3 globalEye = normalize( fragment.texcoord1 );
+
+	float3 reflectionVector = globalNormal * dot3( globalEye, globalNormal );
+	reflectionVector = ( reflectionVector * 2.0f ) - globalEye;
+
+	float4 envMap = texCUBE( samp0, reflectionVector );
+
+	result.color = float4( envMap.xyz, 1.0f ) * fragment.color;
+}
diff --git a/base/renderprogs/bumpyenvironment.vertex b/base/renderprogs/bumpyenvironment.vertex
new file mode 100644
index 0000000..59ab069
--- /dev/null
+++ b/base/renderprogs/bumpyenvironment.vertex
@@ -0,0 +1,80 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float2 texcoord0	: TEXCOORD0;
+	float3 texcoord1	: TEXCOORD1;
+	float3 texcoord2	: TEXCOORD2;
+	float3 texcoord3	: TEXCOORD3;
+	float3 texcoord4	: TEXCOORD4;
+	float4 color		: COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	float4 normal = vertex.normal * 2.0 - 1.0;
+	float4 tangent = vertex.tangent * 2.0 - 1.0;
+	float3 binormal = cross( normal.xyz, tangent.xyz ) * tangent.w;
+
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0 = vertex.texcoord.xy;
+
+	float4 toEye = rpLocalViewOrigin - vertex.position;
+	result.texcoord1.x = dot3( toEye, rpModelMatrixX );
+	result.texcoord1.y = dot3( toEye, rpModelMatrixY );
+	result.texcoord1.z = dot3( toEye, rpModelMatrixZ );
+
+	result.texcoord2.x = dot3( tangent, rpModelMatrixX );
+	result.texcoord3.x = dot3( tangent, rpModelMatrixY );
+	result.texcoord4.x = dot3( tangent, rpModelMatrixZ );
+
+	result.texcoord2.y = dot3( binormal, rpModelMatrixX );
+	result.texcoord3.y = dot3( binormal, rpModelMatrixY );
+	result.texcoord4.y = dot3( binormal, rpModelMatrixZ );
+
+	result.texcoord2.z = dot3( normal, rpModelMatrixX );
+	result.texcoord3.z = dot3( normal, rpModelMatrixY );
+	result.texcoord4.z = dot3( normal, rpModelMatrixZ );
+
+	result.color = rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/color.pixel b/base/renderprogs/color.pixel
new file mode 100644
index 0000000..2726f00
--- /dev/null
+++ b/base/renderprogs/color.pixel
@@ -0,0 +1,39 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( out PS_OUT result ) {
+	result.color = rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/color.vertex b/base/renderprogs/color.vertex
new file mode 100644
index 0000000..41989a4
--- /dev/null
+++ b/base/renderprogs/color.vertex
@@ -0,0 +1,48 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float3 normal 	: NORMAL;
+	float3 tangent 	: TANGENT;
+	float4 color 	: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+}
\ No newline at end of file
diff --git a/base/renderprogs/colorProcess.pixel b/base/renderprogs/colorProcess.pixel
new file mode 100644
index 0000000..5c602b6
--- /dev/null
+++ b/base/renderprogs/colorProcess.pixel
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float4 color		: COLOR;
+	float3 texcoord0	: TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	float4 src = tex2D( samp0, fragment.texcoord0.xy );
+	float4 target = fragment.color * dot3( float3( 0.333, 0.333, 0.333 ), src );
+	result.color = lerp( src, target, fragment.texcoord0.z );
+}
diff --git a/base/renderprogs/colorProcess.vertex b/base/renderprogs/colorProcess.vertex
new file mode 100644
index 0000000..a90be57
--- /dev/null
+++ b/base/renderprogs/colorProcess.vertex
@@ -0,0 +1,61 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform float4 rpUser0 : register(c128); //rpFraction
+uniform float4 rpUser1 : register(c129); //rpTargetHue
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 color 		: COLOR0;
+	float3 texcoord0	: TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+	
+	result.color = rpUser1; // targetHue
+	
+	result.texcoord0.x = vertex.texcoord.x;
+	result.texcoord0.y = 1.0f - vertex.texcoord.y;
+
+	result.texcoord0.z = rpUser0.x; // fraction
+}
+
diff --git a/base/renderprogs/depth.pixel b/base/renderprogs/depth.pixel
new file mode 100644
index 0000000..01402e7
--- /dev/null
+++ b/base/renderprogs/depth.pixel
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	float4 color = tex2D( samp0, fragment.texcoord0 );
+	clip( color.a - rpAlphaTest.x );
+	result.color = fragment.color;
+}
diff --git a/base/renderprogs/depth.vertex b/base/renderprogs/depth.vertex
new file mode 100644
index 0000000..fb4f018
--- /dev/null
+++ b/base/renderprogs/depth.vertex
@@ -0,0 +1,53 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position : POSITION;
+	float2 texcoord	: TEXCOORD0;
+	float4 color 	: COLOR;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+	
+	result.texcoord0 = vertex.texcoord;
+	
+	float4 vertexColor = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+	result.color =  vertexColor * rpColor;	
+}
\ No newline at end of file
diff --git a/base/renderprogs/environment.pixel b/base/renderprogs/environment.pixel
new file mode 100644
index 0000000..589ffed
--- /dev/null
+++ b/base/renderprogs/environment.pixel
@@ -0,0 +1,56 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform samplerCUBE	samp0 : register(s0); // texture 0 is the cube map
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float3 texcoord0	: TEXCOORD0_centroid;
+	float3 texcoord1	: TEXCOORD1_centroid;
+	float4 color		: COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	float3 globalNormal = normalize( fragment.texcoord1 );
+	float3 globalEye = normalize( fragment.texcoord0 );
+
+	float3 reflectionVector = _float3( dot3( globalEye, globalNormal ) );
+	reflectionVector *= globalNormal;
+	reflectionVector = ( reflectionVector * 2.0f ) - globalEye;
+
+	float4 envMap = texCUBE( samp0, reflectionVector );
+
+	result.color = float4( envMap.xyz, 1.0f ) * fragment.color;
+}
diff --git a/base/renderprogs/environment.vertex b/base/renderprogs/environment.vertex
new file mode 100644
index 0000000..bcd3667
--- /dev/null
+++ b/base/renderprogs/environment.vertex
@@ -0,0 +1,59 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float4 normal : NORMAL;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float3 texcoord0	: TEXCOORD0;
+	float3 texcoord1	: TEXCOORD1;
+	float4 color		: COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	float4 vNormal = vertex.normal * 2.0 - 1.0;
+
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	float4 toEye = rpLocalViewOrigin - vertex.position;
+
+	result.texcoord0 = toEye.xyz;
+	result.texcoord1 = vNormal.xyz;
+
+	result.color = rpColor;
+}
diff --git a/base/renderprogs/fog.pixel b/base/renderprogs/fog.pixel
new file mode 100644
index 0000000..9782b32
--- /dev/null
+++ b/base/renderprogs/fog.pixel
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+uniform sampler2D samp1 : register(s1);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+	float2 texcoord1 : TEXCOORD1_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	result.color = tex2D( samp0, fragment.texcoord0 ) * tex2D( samp1, fragment.texcoord1 ) * rpColor;
+}
+
diff --git a/base/renderprogs/fog.vertex b/base/renderprogs/fog.vertex
new file mode 100644
index 0000000..b0f341d
--- /dev/null
+++ b/base/renderprogs/fog.vertex
@@ -0,0 +1,56 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+	float2 texcoord1 : TEXCOORD1;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0.x = dot4( vertex.position, rpTexGen0S );
+	result.texcoord0.y = dot4( vertex.position, rpTexGen0T );
+
+	result.texcoord1.x = dot4( vertex.position, rpTexGen1S );
+	result.texcoord1.y = dot4( vertex.position, rpTexGen1T );
+}
diff --git a/base/renderprogs/fxaa.pixel b/base/renderprogs/fxaa.pixel
new file mode 100644
index 0000000..fd4d866
--- /dev/null
+++ b/base/renderprogs/fxaa.pixel
@@ -0,0 +1,110 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+#define FXAA_GREEN_AS_LUMA 1
+#define FXAA_EARLY_EXIT 0
+#include "Fxaa3_11.h"
+
+uniform sampler2D samp0 : register(s0);
+uniform sampler2D samp1 : register(s1); // exponent bias -1
+uniform sampler2D samp2 : register(s2); // exponent bias -2
+
+uniform float4 rpUser0 : register( c128 );
+uniform float4 rpUser1 : register( c129 );
+uniform float4 rpUser2 : register( c130 );
+uniform float4 rpUser3 : register( c131 );
+uniform float4 rpUser4 : register( c132 );
+uniform float4 rpUser5 : register( c133 );
+uniform float4 rpUser6 : register( c134 );
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+};
+
+struct PS_OUT {	
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	const float4 FXAAQualityRCPFrame = rpUser0;
+	const float4 FXAAConsoleRcpFrameOpt = rpUser1;
+	const float4 FXAAConsoleRcpFrameOpt2 = rpUser2;
+	const float4 FXAAConsole360RcpFrameOpt2 = rpUser3;
+	const float4 FXAAQualityParms = rpUser4;
+	const float4 FXAAConsoleEdgeParms = rpUser5;
+	const float4 FXAAConsole360ConstDir = rpUser6;
+
+	// Inputs - see more info in fxaa3_11.hfile
+	FxaaFloat2	fxaaPos = fragment.texcoord0;
+	FxaaFloat4	fxaaConsolePos;
+
+	float2 halfPixelOffset = float2( 0.5, 0.5 ) * FXAAQualityRCPFrame.xy;
+	fxaaConsolePos.xy = fxaaPos.xy - ( halfPixelOffset );
+	fxaaConsolePos.zw = fxaaPos.xy + ( halfPixelOffset );
+	FxaaFloat2	fxaaQualityRcpFrame = FXAAQualityRCPFrame.xy;
+	FxaaFloat4	fxaaConsoleRcpFrameOpt = FXAAConsoleRcpFrameOpt;
+	FxaaFloat4	fxaaConsoleRcpFrameOpt2 = FXAAConsoleRcpFrameOpt2;
+	FxaaFloat4	fxaaConsole360RcpFrameOpt2 = FXAAConsole360RcpFrameOpt2;
+
+	// Quality parms
+	FxaaFloat	fxaaQualitySubpix = FXAAQualityParms.x;
+	FxaaFloat	fxaaQualityEdgeThreshold = FXAAQualityParms.y;
+	FxaaFloat	fxaaQualityEdgeThresholdMin = FXAAQualityParms.z;
+
+	// Console specific Parms
+	FxaaFloat	fxaaConsoleEdgeSharpness = FXAAConsoleEdgeParms.x;
+	FxaaFloat	fxaaConsoleEdgeThreshold = FXAAConsoleEdgeParms.y;
+	FxaaFloat	fxaaConsoleEdgeThresholdMin = FXAAConsoleEdgeParms.z;
+
+	// 360 specific parms these have to come from a constant register so that the compiler
+	// does not unoptimize the shader
+	FxaaFloat4	fxaaConsole360ConstDir = FXAAConsole360ConstDir;
+
+
+	float4 colorSample = FxaaPixelShader(	fxaaPos,
+											fxaaConsolePos,
+											samp0,
+											samp1,
+											samp2,
+											fxaaQualityRcpFrame,
+											fxaaConsoleRcpFrameOpt,
+											fxaaConsoleRcpFrameOpt2,
+											fxaaConsole360RcpFrameOpt2,
+											fxaaQualitySubpix,
+											fxaaQualityEdgeThreshold,
+											fxaaQualityEdgeThresholdMin,
+											fxaaConsoleEdgeSharpness,
+											fxaaConsoleEdgeThreshold,
+											fxaaConsoleEdgeThresholdMin,
+											fxaaConsole360ConstDir );
+											
+	result.color = colorSample;
+}
\ No newline at end of file
diff --git a/base/renderprogs/fxaa.vertex b/base/renderprogs/fxaa.vertex
new file mode 100644
index 0000000..9a2b7db
--- /dev/null
+++ b/base/renderprogs/fxaa.vertex
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position = vertex.position;
+	result.texcoord0 =  vertex.texcoord;
+}
\ No newline at end of file
diff --git a/base/renderprogs/global.inc b/base/renderprogs/global.inc
new file mode 100644
index 0000000..74f33ff
--- /dev/null
+++ b/base/renderprogs/global.inc
@@ -0,0 +1,176 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+uniform float4 rpScreenCorrectionFactor	:	register(c0);
+uniform float4 rpWindowCoord			:	register(c1);
+uniform float4 rpDiffuseModifier		:	register(c2);
+uniform float4 rpSpecularModifier		:	register(c3);
+
+uniform float4 rpLocalLightOrigin		:	register(c4);
+uniform float4 rpLocalViewOrigin		:	register(c5);
+
+uniform float4 rpLightProjectionS		:	register(c6);
+uniform float4 rpLightProjectionT		:	register(c7);
+uniform float4 rpLightProjectionQ		:	register(c8);
+uniform float4 rpLightFalloffS			:	register(c9);
+
+uniform float4 rpBumpMatrixS			:	register(c10);
+uniform float4 rpBumpMatrixT			:	register(c11);
+
+uniform float4 rpDiffuseMatrixS			:	register(c12);
+uniform float4 rpDiffuseMatrixT			:	register(c13);
+
+uniform float4 rpSpecularMatrixS		:	register(c14);
+uniform float4 rpSpecularMatrixT		:	register(c15);
+
+uniform float4 rpVertexColorModulate	:	register(c16);
+uniform float4 rpVertexColorAdd			:	register(c17);
+
+uniform float4 rpColor					:	register(c18);
+uniform float4 rpViewOrigin				:	register(c19);
+uniform float4 rpGlobalEyePos			:	register(c20);
+
+uniform float4 rpMVPmatrixX				:	register(c21);
+uniform float4 rpMVPmatrixY				:	register(c22);
+uniform float4 rpMVPmatrixZ				:	register(c23);
+uniform float4 rpMVPmatrixW				:	register(c24);
+
+uniform float4 rpModelMatrixX			:	register(c25);
+uniform float4 rpModelMatrixY			:	register(c26);
+uniform float4 rpModelMatrixZ			:	register(c27);
+uniform float4 rpModelMatrixW			:	register(c28);
+
+uniform float4 rpProjectionMatrixX		:	register(c29);
+uniform float4 rpProjectionMatrixY		:	register(c30);
+uniform float4 rpProjectionMatrixZ		:	register(c31);
+uniform float4 rpProjectionMatrixW		:	register(c32);
+
+uniform float4 rpModelViewMatrixX		:	register(c33);
+uniform float4 rpModelViewMatrixY		:	register(c34);
+uniform float4 rpModelViewMatrixZ		:	register(c35);
+uniform float4 rpModelViewMatrixW		:	register(c36);
+
+uniform float4 rpTextureMatrixS			:	register(c37);
+uniform float4 rpTextureMatrixT			:	register(c38);
+
+uniform float4 rpTexGen0S				:	register(c39);
+uniform float4 rpTexGen0T				:	register(c40);
+uniform float4 rpTexGen0Q				:	register(c41);
+uniform float4 rpTexGen0Enabled			:	register(c42);
+
+uniform float4 rpTexGen1S				:	register(c43);
+uniform float4 rpTexGen1T				:	register(c44);
+uniform float4 rpTexGen1Q				:	register(c45);
+uniform float4 rpTexGen1Enabled			:	register(c46);
+
+uniform float4 rpWobbleSkyX				:	register(c47);
+uniform float4 rpWobbleSkyY				:	register(c48);
+uniform float4 rpWobbleSkyZ				:	register(c49);
+
+uniform float4 rpOverbright				:	register(c50);
+uniform float4 rpEnableSkinning			:	register(c51);
+uniform float4 rpAlphaTest				:	register(c52);
+
+static float dot2( float2 a, float2 b ) { return dot( a, b ); }
+static float dot3( float3 a, float3 b ) { return dot( a, b ); }
+static float dot3( float3 a, float4 b ) { return dot( a, b.xyz ); }
+static float dot3( float4 a, float3 b ) { return dot( a.xyz, b ); }
+static float dot3( float4 a, float4 b ) { return dot( a.xyz, b.xyz ); }
+static float dot4( float4 a, float4 b ) { return dot( a, b ); }
+static float dot4( float2 a, float4 b ) { return dot( float4( a, 0, 1 ), b ); }
+
+// ----------------------
+// YCoCg Color Conversion
+// ----------------------
+static const half4 matrixRGB1toCoCg1YX = half4(  0.50,  0.0, -0.50, 0.50196078 );	// Co
+static const half4 matrixRGB1toCoCg1YY = half4( -0.25,  0.5, -0.25, 0.50196078 );	// Cg
+static const half4 matrixRGB1toCoCg1YZ = half4(  0.0,   0.0,  0.0,  1.0 );			// 1.0
+static const half4 matrixRGB1toCoCg1YW = half4(  0.25,  0.5,  0.25, 0.0 );			// Y
+
+static const half4 matrixCoCg1YtoRGB1X = half4(  1.0, -1.0,  0.0,        1.0 );
+static const half4 matrixCoCg1YtoRGB1Y = half4(  0.0,  1.0, -0.50196078, 1.0 ); // -0.5 * 256.0 / 255.0
+static const half4 matrixCoCg1YtoRGB1Z = half4( -1.0, -1.0,  1.00392156, 1.0 ); // +1.0 * 256.0 / 255.0
+
+static half3 ConvertYCoCgToRGB( half4 YCoCg ) {
+	half3 rgbColor;
+
+	YCoCg.z = ( YCoCg.z * 31.875 ) + 1.0;			//z = z * 255.0/8.0 + 1.0
+	YCoCg.z = 1.0 / YCoCg.z;
+	YCoCg.xy *= YCoCg.z;
+	rgbColor.x = dot4( YCoCg, matrixCoCg1YtoRGB1X );
+	rgbColor.y = dot4( YCoCg, matrixCoCg1YtoRGB1Y );
+	rgbColor.z = dot4( YCoCg, matrixCoCg1YtoRGB1Z );
+	return rgbColor;
+}
+
+static float2 CenterScale( float2 inTC, float2 centerScale ) {
+	float scaleX = centerScale.x;
+	float scaleY = centerScale.y;
+	float4 tc0 = float4( scaleX, 0, 0, 0.5 - ( 0.5f * scaleX ) );
+	float4 tc1 = float4( 0, scaleY, 0, 0.5 - ( 0.5f * scaleY ) );
+
+	float2 finalTC;
+	finalTC.x = dot4( inTC, tc0 );
+	finalTC.y = dot4( inTC, tc1 );
+	return finalTC;
+}
+
+static float2 Rotate2D( float2 inTC, float2 cs ) {
+	float sinValue = cs.y;
+	float cosValue = cs.x;
+
+	float4 tc0 = float4( cosValue, -sinValue, 0, ( -0.5f * cosValue ) + ( 0.5f * sinValue ) + 0.5f );
+	float4 tc1 = float4( sinValue, cosValue, 0, ( -0.5f * sinValue ) + ( -0.5f * cosValue ) + 0.5f );
+
+	float2 finalTC;
+	finalTC.x = dot4( inTC, tc0 );
+	finalTC.y = dot4( inTC, tc1 );
+	return finalTC;
+}
+
+// better noise function available at https://github.com/ashima/webgl-noise
+float rand( float2 co ) {
+    return frac( sin( dot( co.xy, float2( 12.9898, 78.233 ) ) ) * 43758.5453 );
+}
+
+
+#define _half2( x )		half2( x )
+#define _half3( x )		half3( x )
+#define _half4( x )		half4( x )
+#define _float2( x )	float2( x )
+#define _float3( x )	float3( x )
+#define _float4( x )	float4( x )
+
+#define VPOS WPOS
+static float4 idtex2Dproj( sampler2D samp, float4 texCoords ) { return tex2Dproj( samp, texCoords.xyw ); }
+static float4 swizzleColor( float4 c ) { return c; }
+static float2 vposToScreenPosTexCoord( float2 vpos ) { return vpos.xy * rpWindowCoord.xy; }
+
+
+#define BRANCH
+#define IFANY
diff --git a/base/renderprogs/gui.pixel b/base/renderprogs/gui.pixel
new file mode 100644
index 0000000..22fa81a
--- /dev/null
+++ b/base/renderprogs/gui.pixel
@@ -0,0 +1,48 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+	float4 texcoord1 : TEXCOORD1_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	float4 color = ( tex2D( samp0, fragment.texcoord0 ) * fragment.color ) + fragment.texcoord1;
+	result.color.xyz = color.xyz * color.w;
+	result.color.w = color.w;
+}
\ No newline at end of file
diff --git a/base/renderprogs/gui.vertex b/base/renderprogs/gui.vertex
new file mode 100644
index 0000000..fbe8a53
--- /dev/null
+++ b/base/renderprogs/gui.vertex
@@ -0,0 +1,56 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+	float4 color2 : COLOR1;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+	float4 texcoord1 : TEXCOORD1;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0.xy = vertex.texcoord.xy;
+	result.texcoord1 = ( swizzleColor( vertex.color2 ) * 2 ) - 1;
+	result.color =  swizzleColor( vertex.color );
+}
diff --git a/base/renderprogs/heatHazeWithMask.pixel b/base/renderprogs/heatHazeWithMask.pixel
new file mode 100644
index 0000000..87b1e9a
--- /dev/null
+++ b/base/renderprogs/heatHazeWithMask.pixel
@@ -0,0 +1,66 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D	samp0 : register(s0); // texture 0 is _current Render
+uniform sampler2D	samp1 : register(s1); // texture 1 is the per-surface bump map
+uniform sampler2D	samp2 : register(s2); // texture 2 is the mask texture
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float4 texcoord0	: TEXCOORD0_centroid;
+	float4 texcoord1	: TEXCOORD1_centroid;
+	float4 texcoord2	: TEXCOORD2_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	// load the distortion map
+	float4 mask = tex2D( samp2, fragment.texcoord0.xy );
+
+	// kill the pixel if the distortion wound up being very small
+	mask.xy -= 0.01f;
+	clip( mask );
+
+	// load the filtered normal map and convert to -1 to 1 range
+	float4 bumpMap = ( tex2D( samp1, fragment.texcoord1.xy ) * 2.0f ) - 1.0f;
+	float2 localNormal = bumpMap.wy;
+	localNormal *= mask.xy;
+
+	// calculate the screen texcoord in the 0.0 to 1.0 range
+	float2 screenTexCoord = vposToScreenPosTexCoord( fragment.position.xy );
+	screenTexCoord += ( localNormal * fragment.texcoord2.xy );
+	screenTexCoord = saturate( screenTexCoord );
+
+	result.color = tex2D( samp0, screenTexCoord );
+}
\ No newline at end of file
diff --git a/base/renderprogs/heatHazeWithMask.vertex b/base/renderprogs/heatHazeWithMask.vertex
new file mode 100644
index 0000000..31e7fd9
--- /dev/null
+++ b/base/renderprogs/heatHazeWithMask.vertex
@@ -0,0 +1,84 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform matrices_ubo { float4 matrices[408]; };
+
+uniform float4 rpUser0 : register(c128); // rpScroll
+uniform	float4 rpUser1 : register(c129); // rpDeformMagnitude
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+	float4 color2 : COLOR1;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord0	: TEXCOORD0;
+	float4 texcoord1	: TEXCOORD1;
+	float4 texcoord2	: TEXCOORD2;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	#include "skinning.inc"
+
+	// texture 0 takes the texture coordinates unmodified
+	result.texcoord0 = float4( vertex.texcoord.xy, 0, 0 );
+
+	// texture 1 takes the texture coordinates and adds a scroll
+	const float4 textureScroll = rpUser0;
+	result.texcoord1 = float4( vertex.texcoord.xy, 0, 0 ) + textureScroll;
+
+	// texture 2 takes the deform magnitude and scales it by the projection distance
+	float4 vec = float4( 0, 1, 0, 1 );
+	vec.z  = dot4( modelPosition, rpModelViewMatrixZ );
+
+	// magicProjectionAdjust is a magic scalar that scales the projection since we changed from 
+	// using the X axis to the Y axis to calculate R1.  It is an approximation to closely match 
+	// what the original game did
+	const float magicProjectionAdjust = 0.43f;
+	float x = dot4 ( vec, rpProjectionMatrixY ) * magicProjectionAdjust;
+	float w = dot4 ( vec, rpProjectionMatrixW );
+
+	// don't let the recip get near zero for polygons that cross the view plane
+	w = max( w, 1.0 );
+	x /= w;
+	//x = x * ( 1.0f / ( w + 0.00001f ) );
+
+	// clamp the distance so the the deformations don't get too wacky near the view
+	x = min( x, 0.02 );
+
+	const float4 deformMagnitude = rpUser1;
+	result.texcoord2 = x * deformMagnitude;
+}
\ No newline at end of file
diff --git a/base/renderprogs/heatHazeWithMaskAndVertex.pixel b/base/renderprogs/heatHazeWithMaskAndVertex.pixel
new file mode 100644
index 0000000..cbe9a0f
--- /dev/null
+++ b/base/renderprogs/heatHazeWithMaskAndVertex.pixel
@@ -0,0 +1,68 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D	samp0 : register(s0); // texture 0 is _current Render
+uniform sampler2D	samp1 : register(s1); // texture 1 is the per-surface bump map
+uniform sampler2D	samp2 : register(s2); // texture 2 is the mask texture
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float4 texcoord0	: TEXCOORD0_centroid;
+	float4 texcoord1	: TEXCOORD1_centroid;
+	float4 texcoord2	: TEXCOORD2_centroid;
+	float4 color		: COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	// load the distortion map
+	float4 mask = tex2D( samp2, fragment.texcoord0.xy );
+
+	// kill the pixel if the distortion wound up being very small
+	mask.xy *= fragment.color.xy;
+	mask.xy -= 0.01f;
+	clip( mask );
+
+	// load the filtered normal map and convert to -1 to 1 range
+	float4 bumpMap = ( tex2D( samp1, fragment.texcoord1.xy ) * 2.0f ) - 1.0f;
+	float2 localNormal = bumpMap.wy;
+	localNormal *= mask.xy;
+
+	// calculate the screen texcoord in the 0.0 to 1.0 range
+	float2 screenTexCoord = vposToScreenPosTexCoord( fragment.position.xy );
+	screenTexCoord += ( localNormal * fragment.texcoord2.xy );
+	screenTexCoord = saturate( screenTexCoord );
+
+	result.color = tex2D( samp0, screenTexCoord );
+}
\ No newline at end of file
diff --git a/base/renderprogs/heatHazeWithMaskAndVertex.vertex b/base/renderprogs/heatHazeWithMaskAndVertex.vertex
new file mode 100644
index 0000000..e5a6c2f
--- /dev/null
+++ b/base/renderprogs/heatHazeWithMaskAndVertex.vertex
@@ -0,0 +1,86 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform matrices_ubo { float4 matrices[408]; };
+
+uniform float4 rpUser0 : register(c128); // rpScroll
+uniform	float4 rpUser1 : register(c129); // rpDeformMagnitude
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+	float4 color2 : COLOR1;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord0	: TEXCOORD0;
+	float4 texcoord1	: TEXCOORD1;
+	float4 texcoord2	: TEXCOORD2;
+	float4 color		: COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	#include "skinning.inc"
+
+	// texture 0 takes the texture coordinates unmodified
+	result.texcoord0 = float4( vertex.texcoord, 0 , 0 );
+
+	// texture 1 takes the texture coordinates and adds a scroll
+	const float4 textureScroll = rpUser0;
+	result.texcoord1 = float4( vertex.texcoord, 0, 0 ) + textureScroll;
+
+	// texture 2 takes the deform magnitude and scales it by the projection distance
+	float4 vec = float4( 0, 1, 0, 1 );
+	vec.z = dot4( modelPosition, rpModelViewMatrixZ );
+
+	// magicProjectionAdjust is a magic scalar that scales the projection since we changed from 
+	// using the X axis to the Y axis to calculate x.  It is an approximation to closely match 
+	// what the original game did
+	const float magicProjectionAdjust = 0.43f;
+	float x = dot4 ( vec, rpProjectionMatrixY ) * magicProjectionAdjust;
+	float w = dot4( vec, rpProjectionMatrixW );
+
+	// don't let the recip get near zero for polygons that cross the view plane
+	w = max( w, 1.0f );
+	x /= w;
+	//x = x * ( 1.0f / w );
+
+	// clamp the distance so the the deformations don't get too wacky near the view
+	x = min( x, 0.02f );
+
+	const float4 deformMagnitude = rpUser1;
+	result.texcoord2 = x * deformMagnitude;
+	result.color = swizzleColor( vertex.color );
+}
\ No newline at end of file
diff --git a/base/renderprogs/heathaze.pixel b/base/renderprogs/heathaze.pixel
new file mode 100644
index 0000000..c349be3
--- /dev/null
+++ b/base/renderprogs/heathaze.pixel
@@ -0,0 +1,57 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D	samp0 : register(s0); // texture 0 is _current Render
+uniform sampler2D	samp1 : register(s1); // texture 1 is the per-surface bump map
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float4 texcoord0	: TEXCOORD0_centroid;
+	float4 texcoord1	: TEXCOORD1_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	// load the filtered normal map and convert to -1 to 1 range
+	float4 bumpMap = ( tex2D( samp1, fragment.texcoord0.xy ) * 2.0f ) - 1.0f;
+	float2 localNormal = bumpMap.wy;
+
+	// calculate the screen texcoord in the 0.0 to 1.0 range
+	float2 screenTexCoord = vposToScreenPosTexCoord( fragment.position.xy );
+	screenTexCoord += ( localNormal * fragment.texcoord1.xy );
+	screenTexCoord = saturate( screenTexCoord );
+
+	// load the screen render
+	result.color = tex2D( samp0, screenTexCoord.xy );
+}
\ No newline at end of file
diff --git a/base/renderprogs/heathaze.vertex b/base/renderprogs/heathaze.vertex
new file mode 100644
index 0000000..b194add
--- /dev/null
+++ b/base/renderprogs/heathaze.vertex
@@ -0,0 +1,82 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+// User Renderparms start at 128 as per renderprogs.h
+
+uniform float4 rpUser0 : register(c128); // rpScroll
+uniform	float4 rpUser1 : register(c129); // rpDeformMagnitude
+
+uniform matrices_ubo { float4 matrices[408]; };
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+	float4 color2 : COLOR1;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord0	: TEXCOORD0;
+	float4 texcoord1	: TEXCOORD1;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	#include "skinning.inc"
+
+	//texture 0 takes the texture coordinates and adds a scroll
+	const float4 textureScroll = rpUser0;
+	result.texcoord0 = float4( vertex.texcoord.xy, 0, 0 ) + textureScroll;
+
+	//texture 1 takes the deform magnitude and scales it by the projection distance
+	float4	vec = float4( 0, 1, 0, 1 );
+	vec.z = dot4( modelPosition, rpModelViewMatrixZ ); // this is the modelview matrix
+
+	// magicProjectionAdjust is a magic scalar that scales the projection since we changed from 
+	// using the X axis to the Y axis to calculate x.  It is an approximation to closely match 
+	// what the original game did
+	const float magicProjectionAdjust = 0.43f;
+	float x = dot4( vec, rpProjectionMatrixY ) * magicProjectionAdjust;
+	float w = dot4( vec, rpProjectionMatrixW );
+
+	//don't let the recip get near zero for polygons that cross the view plane
+	w = max( w, 1.0 );
+	x /= w;
+	//x = x * ( 1.0f / w );
+
+	// clamp the distance so the the deformations don't get too wacky near the view
+	x = min( x, 0.02 );
+
+	const float4 deformMagnitude = rpUser1;
+	result.texcoord1 = x * deformMagnitude;
+}
\ No newline at end of file
diff --git a/base/renderprogs/interaction.pixel b/base/renderprogs/interaction.pixel
new file mode 100644
index 0000000..e330c60
--- /dev/null
+++ b/base/renderprogs/interaction.pixel
@@ -0,0 +1,75 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D	samp0 : register(s0); // texture 1 is the per-surface bump map
+uniform sampler2D	samp1 : register(s1); // texture 2 is the light falloff texture
+uniform sampler2D	samp2 : register(s2); // texture 3 is the light projection texture
+uniform sampler2D	samp3 : register(s3); // texture 4 is the per-surface diffuse map
+uniform sampler2D	samp4 : register(s4); // texture 5 is the per-surface specular map
+
+struct PS_IN {
+	half4 position	: VPOS;
+	half4 texcoord0	: TEXCOORD0_centroid;
+	half4 texcoord1	: TEXCOORD1_centroid;
+	half4 texcoord2	: TEXCOORD2_centroid;
+	half4 texcoord3	: TEXCOORD3_centroid;
+	half4 texcoord4	: TEXCOORD4_centroid;
+	half4 texcoord5	: TEXCOORD5_centroid;
+	half4 texcoord6	: TEXCOORD6_centroid;
+	half4 color		: COLOR0;
+};
+
+struct PS_OUT {
+	half4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	half4 bumpMap =			tex2D( samp0, fragment.texcoord1.xy );
+	half4 lightFalloff =	idtex2Dproj( samp1, fragment.texcoord2 );
+	half4 lightProj	=		idtex2Dproj( samp2, fragment.texcoord3 );
+	half4 diffuseMap =		tex2D( samp3, fragment.texcoord4.xy );
+	half4 specMap =			tex2D( samp4, fragment.texcoord5.xy );
+
+	half3 lightVector = normalize( fragment.texcoord0.xyz );
+
+	half3 localNormal;
+	localNormal = normalize( 2.0 * bumpMap.wyz - 1.0 );
+
+	const half specularPower = 10.0f;
+	half hDotN = dot3( normalize( fragment.texcoord6.xyz ), localNormal );
+	half3 specularContribution = _half3( pow( hDotN, specularPower ) );
+
+	half3 diffuseColor = diffuseMap.xyz * rpDiffuseModifier.xyz;
+	half3 specularColor = specMap.xyz * specularContribution * rpSpecularModifier.xyz;
+	half3 lightColor = dot3( lightVector, localNormal ) * lightProj.xyz * lightFalloff.xyz;
+
+	result.color.xyz = ( diffuseColor + specularColor ) * lightColor * fragment.color.xyz;
+	result.color.w = 1.0;
+}
diff --git a/base/renderprogs/interaction.vertex b/base/renderprogs/interaction.vertex
new file mode 100644
index 0000000..e77e410
--- /dev/null
+++ b/base/renderprogs/interaction.vertex
@@ -0,0 +1,113 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position 	: POSITION;
+	float2 texcoord 	: TEXCOORD0;
+	float3 normal 		: NORMAL;
+	float3 tangent 		: TANGENT;
+	float3 bitangent 	: BITANGENT;
+	float4 color 		: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord0	: TEXCOORD0;
+	float4 texcoord1	: TEXCOORD1;
+	float4 texcoord2	: TEXCOORD2;
+	float4 texcoord3	: TEXCOORD3;
+	float4 texcoord4	: TEXCOORD4;
+	float4 texcoord5	: TEXCOORD5;
+	float4 texcoord6	: TEXCOORD6;
+	float4 color		: COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	float3x3 tangentToWorld = float3x3( vertex.tangent, vertex.bitangent, vertex.normal );
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+
+	float4 defaultTexCoord = float4( 0.0f, 0.5f, 0.0f, 1.0f );
+
+	//calculate vector to light in R0
+	float4 toLight = rpLocalLightOrigin - vertexPos;
+
+	//result.texcoord0
+	result.texcoord0.xyz = toLight.xyz * tangentToWorld;
+
+	//textures 1 takes the base coordinates by the texture matrix
+	result.texcoord1 = defaultTexCoord;
+	result.texcoord1.x = dot4( vertex.texcoord.xy, rpBumpMatrixS );
+	result.texcoord1.y = dot4( vertex.texcoord.xy, rpBumpMatrixT );
+
+	//# texture 2 has one texgen
+	result.texcoord2 = defaultTexCoord;
+	result.texcoord2.x = dot4( vertexPos, rpLightFalloffS );
+
+	//# texture 3 has three texgens
+	result.texcoord3.x = dot4( vertexPos, rpLightProjectionS );
+	result.texcoord3.y = dot4( vertexPos, rpLightProjectionT );
+	result.texcoord3.z = 0.0f;
+	result.texcoord3.w = dot4( vertexPos, rpLightProjectionQ );
+
+	//# textures 4 takes the base coordinates by the texture matrix
+	result.texcoord4 = defaultTexCoord;
+	result.texcoord4.x = dot4( vertex.texcoord.xy, rpDiffuseMatrixS );
+	result.texcoord4.y = dot4( vertex.texcoord.xy, rpDiffuseMatrixT );
+
+	//# textures 5 takes the base coordinates by the texture matrix
+	result.texcoord5 = defaultTexCoord;
+	result.texcoord5.x = dot4( vertex.texcoord.xy, rpSpecularMatrixS );
+	result.texcoord5.y = dot4( vertex.texcoord.xy, rpSpecularMatrixT );
+
+	//# texture 6's texcoords will be the halfangle in texture space
+
+	//# calculate normalized vector to light in R0
+	toLight = normalize( toLight );
+
+	//# calculate normalized vector to viewer in R1
+	float4 toView = normalize( rpLocalViewOrigin - vertexPos );
+	
+	//# add together to become the half angle vector in object space (non-normalized)
+	float4 halfAngleVector = toLight + toView;
+
+	//# put into texture space
+	result.texcoord6.xyz = halfAngleVector.xyz * tangentToWorld;
+	result.texcoord6.w = 1.0f;
+
+	//# generate the vertex color, which can be 1.0, color, or 1.0 - color
+	//# for 1.0 : env[16] = 0, env[17] = 1
+	//# for color : env[16] = 1, env[17] = 0
+	//# for 1.0-color : env[16] = -1, env[17] = 1	
+	result.color = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+}
\ No newline at end of file
diff --git a/base/renderprogs/interactionAmbient.pixel b/base/renderprogs/interactionAmbient.pixel
new file mode 100644
index 0000000..c606cf1
--- /dev/null
+++ b/base/renderprogs/interactionAmbient.pixel
@@ -0,0 +1,67 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D	samp0 : register(s0); // texture 1 is the per-surface bump map
+uniform sampler2D	samp1 : register(s1); // texture 2 is the light falloff texture
+uniform sampler2D	samp2 : register(s2); // texture 3 is the light projection texture
+uniform sampler2D	samp3 : register(s3); // texture 4 is the per-surface diffuse map
+uniform sampler2D	samp4 : register(s4); // texture 5 is the per-surface specular map
+
+struct PS_IN {
+	half4 position	: VPOS;
+	half4 texcoord1	: TEXCOORD1_centroid;
+	half4 texcoord2	: TEXCOORD2_centroid;
+	half4 texcoord3	: TEXCOORD3_centroid;
+	half4 texcoord4	: TEXCOORD4_centroid;
+	half4 color		: COLOR0;
+};
+
+struct PS_OUT {
+	half4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	half4 bumpMap =			tex2D( samp0, fragment.texcoord1.xy );
+	half4 lightFalloff =	idtex2Dproj( samp1, fragment.texcoord2 );
+	half4 lightProj	=		idtex2Dproj( samp2, fragment.texcoord3 );
+	half4 diffuseMap =		tex2D( samp3, fragment.texcoord4.xy );
+
+	const half3 ambientLightVector = half3( 0.5f, 9.5f - 0.385f, 0.8925f );
+	half3 lightVector = normalize( ambientLightVector );
+
+	half3 localNormal;
+	localNormal = normalize( 2.0 * bumpMap.wyz - 1.0 );
+
+	half3 diffuseColor = diffuseMap.xyz * rpDiffuseModifier.xyz;
+	half3 lightColor = dot3( lightVector, localNormal ) * lightProj.xyz * lightFalloff.xyz;
+
+	result.color.xyz = diffuseColor * lightColor * fragment.color.xyz;
+	result.color.w = 1.0;
+}
diff --git a/base/renderprogs/interactionAmbient.vertex b/base/renderprogs/interactionAmbient.vertex
new file mode 100644
index 0000000..f316c9d
--- /dev/null
+++ b/base/renderprogs/interactionAmbient.vertex
@@ -0,0 +1,84 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position 	: POSITION;
+	float2 texcoord 	: TEXCOORD0;
+	float3 normal 		: NORMAL;
+	float3 tangent 		: TANGENT;
+	float3 bitangent 	: BITANGENT;
+	float4 color 		: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord1	: TEXCOORD1;
+	float4 texcoord2	: TEXCOORD2;
+	float4 texcoord3	: TEXCOORD3;
+	float4 texcoord4	: TEXCOORD4;
+	float4 color		: COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+
+	float3x3 tangentToWorld = float3x3( vertex.tangent, vertex.bitangent, vertex.normal );
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+
+	float4 defaultTexCoord = float4( 0.0f, 0.5f, 0.0f, 1.0f );
+
+	//textures 1 takes the base coordinates by the texture matrix
+	result.texcoord1 = defaultTexCoord;
+	result.texcoord1.x = dot4( vertex.texcoord.xy, rpBumpMatrixS );
+	result.texcoord1.y = dot4( vertex.texcoord.xy, rpBumpMatrixT );
+
+	//# texture 2 has one texgen
+	result.texcoord2 = defaultTexCoord;
+	result.texcoord2.x = dot4( vertexPos, rpLightFalloffS );
+
+	//# texture 3 has three texgens
+	result.texcoord3.x = dot4( vertexPos, rpLightProjectionS );
+	result.texcoord3.y = dot4( vertexPos, rpLightProjectionT );
+	result.texcoord3.z = 0.0f;
+	result.texcoord3.w = dot4( vertexPos, rpLightProjectionQ );
+
+	//# textures 4 takes the base coordinates by the texture matrix
+	result.texcoord4 = defaultTexCoord;
+	result.texcoord4.x = dot4( vertex.texcoord.xy, rpDiffuseMatrixS );
+	result.texcoord4.y = dot4( vertex.texcoord.xy, rpDiffuseMatrixT );
+
+	//# generate the vertex color, which can be 1.0, color, or 1.0 - color
+	//# for 1.0 : env[16] = 0, env[17] = 1
+	//# for color : env[16] = 1, env[17] = 0
+	//# for 1.0-color : env[16] = -1, env[17] = 1	
+	result.color = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+}
\ No newline at end of file
diff --git a/base/renderprogs/motionBlur.pixel b/base/renderprogs/motionBlur.pixel
new file mode 100644
index 0000000..d486e10
--- /dev/null
+++ b/base/renderprogs/motionBlur.pixel
@@ -0,0 +1,92 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);   // view color
+uniform sampler2D samp1 : register(s1);   // view depth
+
+struct PS_IN {
+	float2 texcoord0 : TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+#if 0
+    if ( fragment.texcoord0.x < 0.5 ) {
+    // only draw on half the screen for comparison
+        discard;
+    }
+#endif
+	// don't motion blur the hands, which were drawn with alpha = 0
+	if ( tex2D( samp0, fragment.texcoord0 ).w == 0.0 ) {
+		discard;
+	}
+
+	// derive clip space from the depth buffer and screen position
+	float windowZ = tex2D( samp1, fragment.texcoord0 ).x;
+	float3 ndc = float3( fragment.texcoord0 * 2.0 - 1.0, windowZ * 2.0 - 1.0 );
+	float clipW = -rpProjectionMatrixZ.w / ( -rpProjectionMatrixZ.z - ndc.z );
+
+	float4 clip = float4( ndc * clipW, clipW );
+
+	// convert from clip space this frame to clip space previous frame
+	float4 reClip;
+	reClip.x = dot( rpMVPmatrixX, clip );
+	reClip.y = dot( rpMVPmatrixY, clip );
+	reClip.z = dot( rpMVPmatrixZ, clip );
+	reClip.w = dot( rpMVPmatrixW, clip );
+
+	// convert to NDC values
+	float2 prevTexCoord;
+	prevTexCoord.x = ( reClip.x / reClip.w ) * 0.5 + 0.5;
+	prevTexCoord.y = ( reClip.y / reClip.w ) * 0.5 + 0.5;
+
+	// sample along the line from prevTexCoord to fragment.texcoord0
+
+	float2 texCoord = prevTexCoord; //fragment.texcoord0;
+	float2 delta = ( fragment.texcoord0 - prevTexCoord );
+
+	float3 sum = float3( 0.0 );
+	float goodSamples = 0;
+	float samples = rpOverbright.x;
+
+	for ( float i = 0 ; i < samples ; i = i + 1 ) {
+		float2 pos = fragment.texcoord0 + delta * ( ( i / ( samples - 1 ) ) - 0.5 );
+		float4 color = tex2D( samp0, pos );
+		// only take the values that are not part of the weapon
+		sum += color.xyz * color.w;
+		goodSamples += color.w;
+	}
+	float invScale = 1.0 / goodSamples;
+
+	result.color = float4( sum * invScale, 1.0 );
+}
diff --git a/base/renderprogs/motionBlur.vertex b/base/renderprogs/motionBlur.vertex
new file mode 100644
index 0000000..752a938
--- /dev/null
+++ b/base/renderprogs/motionBlur.vertex
@@ -0,0 +1,44 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position = vertex.position;
+	result.texcoord0 = vertex.texcoord;
+}
\ No newline at end of file
diff --git a/base/renderprogs/postprocess.pixel b/base/renderprogs/postprocess.pixel
new file mode 100644
index 0000000..5a0b3eb
--- /dev/null
+++ b/base/renderprogs/postprocess.pixel
@@ -0,0 +1,45 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0		: register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	float2 tCoords = fragment.texcoord0;
+	result.color = tex2D( samp0, tCoords );
+}
diff --git a/base/renderprogs/postprocess.vertex b/base/renderprogs/postprocess.vertex
new file mode 100644
index 0000000..87df0f0
--- /dev/null
+++ b/base/renderprogs/postprocess.vertex
@@ -0,0 +1,52 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position = vertex.position;
+
+	//result.position.x = vertex.position; //dot4( vertex.position, rpMVPmatrixX );
+	//result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	//result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	//result.position.w = dot4( vertex.position, rpMVPmatrixW );
+	result.texcoord0 =  vertex.texcoord;
+}
\ No newline at end of file
diff --git a/base/renderprogs/shadow.pixel b/base/renderprogs/shadow.pixel
new file mode 100644
index 0000000..d967be7
--- /dev/null
+++ b/base/renderprogs/shadow.pixel
@@ -0,0 +1,38 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( out PS_OUT result ) {
+	result.color = rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/shadow.vertex b/base/renderprogs/shadow.vertex
new file mode 100644
index 0000000..6f101a1
--- /dev/null
+++ b/base/renderprogs/shadow.vertex
@@ -0,0 +1,46 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4 vPos = vertex.position - rpLocalLightOrigin;
+	vPos = ( vPos.wwww * rpLocalLightOrigin ) + vPos;
+
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	result.position = mvpMatrix * vPos;
+}
\ No newline at end of file
diff --git a/base/renderprogs/shadowDebug.pixel b/base/renderprogs/shadowDebug.pixel
new file mode 100644
index 0000000..d967be7
--- /dev/null
+++ b/base/renderprogs/shadowDebug.pixel
@@ -0,0 +1,38 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( out PS_OUT result ) {
+	result.color = rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/shadowDebug.vertex b/base/renderprogs/shadowDebug.vertex
new file mode 100644
index 0000000..2a2c5f4
--- /dev/null
+++ b/base/renderprogs/shadowDebug.vertex
@@ -0,0 +1,44 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4 vPos = ( vertex.position.w * rpLocalLightOrigin + vertex.position - rpLocalLightOrigin );
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	result.position = mvpMatrix * vPos;
+}
\ No newline at end of file
diff --git a/base/renderprogs/simpleshade.pixel b/base/renderprogs/simpleshade.pixel
new file mode 100644
index 0000000..c7c0aea
--- /dev/null
+++ b/base/renderprogs/simpleshade.pixel
@@ -0,0 +1,62 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct PS_IN {
+	float4 position		: VPOS;
+	float4 texcoord0	: TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+uniform sampler2D	samp0 : register(s0);
+
+static float2 screenPosToTexcoord( float2 pos, float4 bias_scale ) { return ( pos * bias_scale.zw + bias_scale.xy ); }
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	const float renderWidth = 1280.0f;
+	const float renderHeight = 720.0f;
+	const float4 positionToViewTexture = float4( 0.5f / renderWidth, 0.5f / renderHeight, 1.0f / renderWidth, 1.0f / renderHeight );
+	
+	float interpolatedZOverW = ( 1.0 - ( fragment.texcoord0.z / fragment.texcoord0.w ) );
+
+	float3 pos;
+	pos.z = 1.0 / interpolatedZOverW;
+	pos.xy = pos.z * ( 2.0 * screenPosToTexcoord( fragment.position.xy, positionToViewTexture ) - 1.0 );
+
+	float3 normal = normalize( cross( ddy( pos ), ddx( pos ) ) );
+
+	// light is above and to the right in the eye plane
+	float3 L = normalize( float3( 1.0, 1.0, 0.0 ) - pos );
+
+	result.color.xyz = _float3( dot3( normal, L ) * 0.75 );
+	result.color.w = 1.0;
+}
\ No newline at end of file
diff --git a/base/renderprogs/simpleshade.vertex b/base/renderprogs/simpleshade.vertex
new file mode 100644
index 0000000..22c8912
--- /dev/null
+++ b/base/renderprogs/simpleshade.vertex
@@ -0,0 +1,53 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position		: POSITION;
+	float4 texcoord0	: TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4 position;
+	position.x = dot4( vertex.position, rpMVPmatrixX );
+	position.y = dot4( vertex.position, rpMVPmatrixY );
+	position.z = dot4( vertex.position, rpMVPmatrixZ );
+	position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.position = position;
+	result.texcoord0 = position;
+}
\ No newline at end of file
diff --git a/base/renderprogs/skybox.pixel b/base/renderprogs/skybox.pixel
new file mode 100644
index 0000000..1cc2507
--- /dev/null
+++ b/base/renderprogs/skybox.pixel
@@ -0,0 +1,45 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform samplerCUBE samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float3 texcoord0 : TEXCOORD0_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	result.color = texCUBE( samp0, fragment.texcoord0 ) * fragment.color;
+}
diff --git a/base/renderprogs/skybox.vertex b/base/renderprogs/skybox.vertex
new file mode 100644
index 0000000..e6b711a
--- /dev/null
+++ b/base/renderprogs/skybox.vertex
@@ -0,0 +1,54 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float3 texcoord0 : TEXCOORD0;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0 = vertex.position.xyz - rpLocalViewOrigin.xyz;
+	
+	result.color = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+}
diff --git a/base/renderprogs/stereoDeGhost.pixel b/base/renderprogs/stereoDeGhost.pixel
new file mode 100644
index 0000000..2726f00
--- /dev/null
+++ b/base/renderprogs/stereoDeGhost.pixel
@@ -0,0 +1,39 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( out PS_OUT result ) {
+	result.color = rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/stereoDeGhost.vertex b/base/renderprogs/stereoDeGhost.vertex
new file mode 100644
index 0000000..e330f16
--- /dev/null
+++ b/base/renderprogs/stereoDeGhost.vertex
@@ -0,0 +1,48 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+}
\ No newline at end of file
diff --git a/base/renderprogs/stereoInterlace.pixel b/base/renderprogs/stereoInterlace.pixel
new file mode 100644
index 0000000..6049d37
--- /dev/null
+++ b/base/renderprogs/stereoInterlace.pixel
@@ -0,0 +1,49 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+uniform sampler2D samp1 : register(s1);
+
+struct PS_IN {
+	float2 texcoord0 : TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+    // texcoords will run from 0 to 1 across the entire screen
+    if ( fract( fragment.position.y * 0.5 ) < 0.5 ) {
+        result.color = tex2D( samp0, vec2( fragment.texcoord0 ) );
+    } else {
+        result.color = tex2D( samp1, vec2( fragment.texcoord0 ) );
+    }
+}
\ No newline at end of file
diff --git a/base/renderprogs/stereoInterlace.vertex b/base/renderprogs/stereoInterlace.vertex
new file mode 100644
index 0000000..85831d1
--- /dev/null
+++ b/base/renderprogs/stereoInterlace.vertex
@@ -0,0 +1,48 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	result.texcoord0 = vertex.texcoord;
+}
\ No newline at end of file
diff --git a/base/renderprogs/stereoWarp.pixel b/base/renderprogs/stereoWarp.pixel
new file mode 100644
index 0000000..17319e3
--- /dev/null
+++ b/base/renderprogs/stereoWarp.pixel
@@ -0,0 +1,74 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+/*
+
+This shader will cover a square block of pixel coordinates, but some of them might
+be scissored off if the edges of the screen or the midpoint divider are visible through
+the optics.
+
+*/
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	vec4 texcoord0	: TEXCOORD0_centroid;
+};
+
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+    const float screenWarp_range   = 1.45;
+
+    const vec2    warpCenter = vec2( 0.5, 0.5 );
+    vec2    centeredTexcoord = fragment.texcoord0.xy - warpCenter;
+
+	float	radialLength = length( centeredTexcoord );
+	vec2	radialDir = normalize( centeredTexcoord );
+
+	// get it down into the 0 - PI/2 range
+	float	range = screenWarp_range;
+	float	scaledRadialLength = radialLength * range;
+	float	tanScaled = tan( scaledRadialLength );
+
+    float   rescaleValue = tan( 0.5 * range );
+
+    // If radialLength was 0.5, we want rescaled to also come out
+    // as 0.5, so the edges of the rendered image are at the edges
+    // of the warped image.
+	float	rescaled = tanScaled / rescaleValue;
+
+    vec2	warped = warpCenter + vec2( 0.5, 0.5 ) * radialDir * rescaled;
+
+	result.color = tex2D( samp0, warped );
+}
diff --git a/base/renderprogs/stereoWarp.vertex b/base/renderprogs/stereoWarp.vertex
new file mode 100644
index 0000000..dcf8fcc
--- /dev/null
+++ b/base/renderprogs/stereoWarp.vertex
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float4 texcoord : TEXCOORD0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float4 texcoord0: TEXCOORD0;        // 0 to 1 box
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+	result.texcoord0 = vertex.texcoord;
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture.pixel b/base/renderprogs/texture.pixel
new file mode 100644
index 0000000..88fa820
--- /dev/null
+++ b/base/renderprogs/texture.pixel
@@ -0,0 +1,44 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	result.color = tex2D( samp0, fragment.texcoord0 ) * rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture.vertex b/base/renderprogs/texture.vertex
new file mode 100644
index 0000000..aa2c685
--- /dev/null
+++ b/base/renderprogs/texture.vertex
@@ -0,0 +1,58 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float3 normal 	: NORMAL;
+	float3 tangent 	: TANGENT;
+	float4 color 	: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+	
+	// compute oldschool texgen or multiply by texture matrix
+	BRANCH if ( rpTexGen0Enabled.x > 0.0 ) {
+		result.texcoord0.x = dot4( vertexPos, rpTexGen0S );
+		result.texcoord0.y = dot4( vertexPos, rpTexGen0T );
+	} else {
+		result.texcoord0.x = dot4( vertex.texcoord.xy, rpTextureMatrixS );
+		result.texcoord0.y = dot4( vertex.texcoord.xy, rpTextureMatrixT );
+	}
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture_color.pixel b/base/renderprogs/texture_color.pixel
new file mode 100644
index 0000000..590f851
--- /dev/null
+++ b/base/renderprogs/texture_color.pixel
@@ -0,0 +1,47 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float2 texcoord0 : TEXCOORD0_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	float4 color = tex2D( samp0, fragment.texcoord0 ) * fragment.color;
+	clip( color.a - rpAlphaTest.x );
+	result.color = color;
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture_color.vertex b/base/renderprogs/texture_color.vertex
new file mode 100644
index 0000000..63688a1
--- /dev/null
+++ b/base/renderprogs/texture_color.vertex
@@ -0,0 +1,62 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float3 normal 	: NORMAL;
+	float3 tangent 	: TANGENT;
+	float4 color 	: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float2 texcoord0 : TEXCOORD0;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+
+	// compute oldschool texgen or multiply by texture matrix
+	BRANCH if ( rpTexGen0Enabled.x > 0.0 ) {
+		result.texcoord0.x = dot4( vertexPos, rpTexGen0S );
+		result.texcoord0.y = dot4( vertexPos, rpTexGen0T );
+	} else {
+		result.texcoord0.x = dot4( vertex.texcoord.xy, rpTextureMatrixS );
+		result.texcoord0.y = dot4( vertex.texcoord.xy, rpTextureMatrixT );
+	}
+
+	float4 vertexColor = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+	result.color =  vertexColor * rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture_color_texgen.pixel b/base/renderprogs/texture_color_texgen.pixel
new file mode 100644
index 0000000..1c222a2
--- /dev/null
+++ b/base/renderprogs/texture_color_texgen.pixel
@@ -0,0 +1,52 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform sampler2D samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float4 texcoord0 : TEXCOORD0_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+
+	// we always do a projective texture lookup so that we can support texgen
+	// materials without a separate shader. Basic materials will have texture
+	// coordinates with w = 1 which will result in a NOP projection when tex2Dproj
+	// gets called.
+	float4 texSample = idtex2Dproj( samp0, fragment.texcoord0 );
+
+	result.color = texSample * fragment.color;
+}
\ No newline at end of file
diff --git a/base/renderprogs/texture_color_texgen.vertex b/base/renderprogs/texture_color_texgen.vertex
new file mode 100644
index 0000000..7e554f3
--- /dev/null
+++ b/base/renderprogs/texture_color_texgen.vertex
@@ -0,0 +1,66 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float3 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float3 normal 	: NORMAL;
+	float3 tangent 	: TANGENT;
+	float4 color 	: COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float4 texcoord0 : TEXCOORD0;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	float4x4 mvpMatrix = float4x4( rpMVPmatrixX, rpMVPmatrixY, rpMVPmatrixZ, rpMVPmatrixW );
+
+	float4 vertexPos = float4( vertex.position, 1.0f );
+	result.position = mvpMatrix * vertexPos;
+
+	float4 tc0;
+	tc0.x = dot4( vertexPos, rpTexGen0S );
+	tc0.y = dot4( vertexPos, rpTexGen0T );
+
+	tc0.z = 0.0f;
+	tc0.w = dot4( vertexPos, rpTexGen0Q ); 
+
+	// multiply the texture matrix in
+	result.texcoord0.x = dot4( tc0, rpTextureMatrixS );
+	result.texcoord0.y = dot4( tc0, rpTextureMatrixT );
+	result.texcoord0.zw = tc0.zw;
+
+	// compute vertex modulation
+	float4 vertexColor = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+	result.color =  vertexColor * rpColor;
+}
\ No newline at end of file
diff --git a/base/renderprogs/wobblesky.pixel b/base/renderprogs/wobblesky.pixel
new file mode 100644
index 0000000..1cc2507
--- /dev/null
+++ b/base/renderprogs/wobblesky.pixel
@@ -0,0 +1,45 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+uniform samplerCUBE samp0 : register(s0);
+
+struct PS_IN {
+	float4 position : VPOS;
+	float3 texcoord0 : TEXCOORD0_centroid;
+	float4 color : COLOR0;
+};
+
+struct PS_OUT {
+	float4 color : COLOR;
+};
+
+void main( PS_IN fragment, out PS_OUT result ) {
+	result.color = texCUBE( samp0, fragment.texcoord0 ) * fragment.color;
+}
diff --git a/base/renderprogs/wobblesky.vertex b/base/renderprogs/wobblesky.vertex
new file mode 100644
index 0000000..b85c732
--- /dev/null
+++ b/base/renderprogs/wobblesky.vertex
@@ -0,0 +1,57 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "global.inc"
+
+struct VS_IN {
+	float4 position : POSITION;
+	float2 texcoord : TEXCOORD0;
+	float4 normal : NORMAL;
+	float4 tangent : TANGENT;
+	float4 color : COLOR0;
+};
+
+struct VS_OUT {
+	float4 position : POSITION;
+	float3 texcoord0 : TEXCOORD0;
+	float4 color : COLOR0;
+};
+
+void main( VS_IN vertex, out VS_OUT result ) {
+	result.position.x = dot4( vertex.position, rpMVPmatrixX );
+	result.position.y = dot4( vertex.position, rpMVPmatrixY );
+	result.position.z = dot4( vertex.position, rpMVPmatrixZ );
+	result.position.w = dot4( vertex.position, rpMVPmatrixW );
+
+	float3 t0 = vertex.position.xyz - rpLocalViewOrigin.xyz;
+	result.texcoord0.x = dot3( t0, rpWobbleSkyX );
+	result.texcoord0.y = dot3( t0, rpWobbleSkyY );
+	result.texcoord0.z = dot3( t0, rpWobbleSkyZ );
+	
+	result.color = ( swizzleColor( vertex.color ) * rpVertexColorModulate ) + rpVertexColorAdd;
+}
diff --git a/neo/CMakeLists.txt b/neo/CMakeLists.txt
index b1ccf93..2342f5e 100644
--- a/neo/CMakeLists.txt
+++ b/neo/CMakeLists.txt
@@ -26,10 +26,11 @@ include(GNUInstallDirs OPTIONAL RESULT_VARIABLE GNUINSTALLDIRS)
 
 option(CORE			"Build the core" ON)
 option(BASE			"Build the base game code" ON)
-option(D3XP			"Build the d3xp game code" ON)
-option(DEDICATED	"Build the dedicated server" OFF)
-option(ONATIVE		"Optimize for the host CPU" OFF)
-option(SDL2			"Use SDL2 instead of SDL1.2" OFF)
+option(D3XP			"Build the d3xp game code" OFF)
+option(DEDICATED		"Build the dedicated server" OFF)
+option(ONATIVE			"Optimize for the host CPU" OFF)
+option(SDL2			"Use SDL2 instead of SDL1.2" ON)
+option(GLSL			"Use GLSL backend" ON)
 
 if(NOT CMAKE_SYSTEM_PROCESSOR)
 	message(FATAL_ERROR "No target CPU architecture set")
@@ -304,6 +305,13 @@ set(src_renderer
 	renderer/Model_prt.cpp
 	renderer/Model_sprite.cpp
 	renderer/RenderEntity.cpp
+
+##	if(GLSL)
+	        renderer/RenderLog.cpp
+        	renderer/RenderProgs.cpp
+		renderer/RenderProgs_GLSL.cpp
+##	endif()
+
 	renderer/RenderSystem.cpp
 	renderer/RenderSystem_init.cpp
 	renderer/RenderWorld.cpp
diff --git a/neo/idlib/Heap.h b/neo/idlib/Heap.h
index db17a95..b001046 100644
--- a/neo/idlib/Heap.h
+++ b/neo/idlib/Heap.h
@@ -2,9 +2,9 @@
 ===========================================================================
 
 Doom 3 GPL Source Code
-Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
+Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 
 
-This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").  
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -40,7 +40,7 @@ If you have questions concerning this license or the applicable additional terms
 	This is a replacement for the compiler heap code (i.e. "C" malloc() and
 	free() calls). On average 2.5-3.0 times faster than MSVC malloc()/free().
 	Worst case performance is 1.65 times faster and best case > 70 times.
-
+ 
 ===============================================================================
 */
 
@@ -143,6 +143,77 @@ __inline void operator delete[]( void *p ) {
 
 
 /*
+================================================
+idTempArray is an array that is automatically free'd when it goes out of scope.
+There is no "cast" operator because these are very unsafe.
+
+The template parameter MUST BE POD!
+
+Compile time asserting POD-ness of the template parameter is complicated due
+to our vector classes that need a default constructor but are otherwise
+considered POD.
+================================================
+*/
+template < class T >
+class idTempArray {
+public:
+	idTempArray( idTempArray<T> & other );
+	idTempArray( unsigned int num );
+
+	~idTempArray();
+
+	T & operator [](unsigned int i) { assert( i < num ); return buffer[i]; }
+	const T & operator [](unsigned int i) const { assert( i < num ); return buffer[i]; }
+
+	T * Ptr() { return buffer; }
+	const T* Ptr() const { return buffer; }
+
+	size_t Size() const { return num * sizeof(T); }
+	unsigned int Num() const { return num; }
+
+	void Zero() { memset( Ptr(), 0, Size() ); }
+
+private:
+	T *				buffer;		// Ensure this buffer comes first, so this == &this->buffer
+	unsigned int	num;
+};
+
+/*
+========================
+idTempArray::idTempArray
+========================
+*/
+template < class T >
+ID_INLINE idTempArray<T>::idTempArray( idTempArray<T> & other ) {
+	this->num = other.num;
+	this->buffer = other.buffer;
+	other.num = 0;
+	other.buffer = NULL;
+}
+
+/*
+========================
+idTempArray::idTempArray
+========================
+*/
+template < class T >
+ID_INLINE idTempArray<T>::idTempArray( unsigned int num ) {
+	this->num = num;
+	buffer = (T*)Mem_Alloc( num * sizeof(T) );
+}
+
+/*
+========================
+idTempArray::~idTempArray
+========================
+*/
+template < class T >
+ID_INLINE idTempArray<T>::~idTempArray() {
+	Mem_Free( buffer );
+}
+
+
+/*
 ===============================================================================
 
 	Block based allocator for fixed size objects.
diff --git a/neo/idlib/Lexer.cpp b/neo/idlib/Lexer.cpp
index 4629a58..83e5296 100644
--- a/neo/idlib/Lexer.cpp
+++ b/neo/idlib/Lexer.cpp
@@ -353,6 +353,92 @@ int idLexer::ReadWhiteSpace( void ) {
 	return 1;
 }
 
+ /*
+========================
+idLexer::SkipWhiteSpace
+
+Reads spaces, tabs, C-like comments etc. When a newline character is found, the scripts line 
+counter is increased. Returns false if there is no token left to be read.
+========================
+*/
+bool idLexer::SkipWhiteSpace( bool currentLine ) {
+	while( 1 ) {
+		assert( script_p <= end_p );
+		if ( script_p == end_p ) {
+			return false;
+		}
+		// skip white space
+		while( *script_p <= ' ' ) {
+			if ( script_p == end_p ) {
+				return false;
+			}
+			if ( !*script_p ) {
+				return false;
+			}
+			if ( *script_p == '\n' ) {
+				line++;
+				if ( currentLine ) {
+					script_p++;
+					return true;
+				}
+			}
+			script_p++;
+		}
+		// skip comments
+		if ( *script_p == '/' ) {
+			// comments //
+			if ( *(script_p+1) == '/' ) {
+				script_p++;
+				do {
+					script_p++;
+					if ( !*script_p ) {
+						return false;
+					}
+				}
+				while( *script_p != '\n' );
+				line++;
+				script_p++;
+				if ( currentLine ) {
+					return true;
+				}
+				if ( !*script_p ) {
+					return false;
+				}
+				continue;
+			}
+			// comments /* */
+			else if ( *(script_p+1) == '*' ) {
+				script_p++;
+				while( 1 ) {
+					script_p++;
+					if ( !*script_p ) {
+						return false;
+					}
+					if ( *script_p == '\n' ) {
+						line++;
+					}
+					else if ( *script_p == '/' ) {
+						if ( *(script_p-1) == '*' ) {
+							break;
+						}
+						if ( *(script_p+1) == '*' ) {
+							Warning( "nested comment" );
+						}
+					}
+				}
+				script_p++;
+				if ( !*script_p ) {
+					return false;
+				}
+				continue;
+			}
+		}
+		break;
+	}
+	return true;
+}
+
+
 /*
 ================
 idLexer::ReadEscapeCharacter
@@ -829,6 +915,12 @@ int idLexer::ReadToken( idToken *token ) {
 		return 0;
 	}
 
+	if ( script_p == NULL ) {
+
+	        return 0;
+
+	}
+
 	// if there is a token available (from unreadToken)
 	if ( tokenavailable ) {
 		tokenavailable = 0;
diff --git a/neo/idlib/Lexer.h b/neo/idlib/Lexer.h
index 09d7da4..f569b67 100644
--- a/neo/idlib/Lexer.h
+++ b/neo/idlib/Lexer.h
@@ -180,6 +180,8 @@ public:
 	int				SkipRestOfLine( void );
 					// skip the braced section
 	int				SkipBracedSection( bool parseFirstBrace = true );
+	                                // skips spaces, tabs, C-like comments etc. Returns false if there is no token left to read.
+	bool                    SkipWhiteSpace( bool currentLine );
 					// unread the given token
 	void			UnreadToken( const idToken *token );
 					// read a token only if on the same line
diff --git a/neo/idlib/Parser.cpp b/neo/idlib/Parser.cpp
index a461a0e..d0b7740 100644
--- a/neo/idlib/Parser.cpp
+++ b/neo/idlib/Parser.cpp
@@ -2715,6 +2715,75 @@ const char *idParser::ParseBracedSection( idStr &out, int tabs ) {
 }
 
 /*
+========================
+idParser::ParseBracedSection
+
+The next token should be an open brace. Parses until a matching close brace is found. Internal 
+brace depths are properly skipped.
+========================
+*/
+const char* idParser::ParseBracedSection( idStr& out, int tabs, bool parseFirstBrace, char intro, char outro ) {
+	idToken token;
+	int i, depth;
+	bool doTabs;
+
+	char temp[ 2 ] = { 0, 0 };
+	*temp = intro;
+
+	out.Empty();
+	if ( parseFirstBrace ) {
+		if ( !ExpectTokenString( temp ) ) {
+			return out.c_str();
+		}
+		out = temp;
+	}
+	depth = 1;
+	doTabs = ( tabs >= 0 );
+	do {
+		if ( !ReadToken( &token ) ) {
+			Error( "missing closing brace" );
+			return out.c_str();
+		}
+
+		// if the token is on a new line
+		for ( i = 0; i < token.linesCrossed; i++ ) {
+			out += "\r\n";
+		}
+
+		if ( doTabs && token.linesCrossed ) {
+			i = tabs;
+			if ( token[ 0 ] == outro && i > 0 ) {
+				i--;
+			}
+			while( i-- > 0 ) {
+				out += "\t";
+			}
+		}
+		if ( token.type == TT_STRING ) {
+			out += "\"" + token + "\"";
+		} else if ( token.type == TT_LITERAL ) {
+			out += "\'" + token + "\'";
+		} else {
+			if ( token[ 0 ] == intro ) {
+				depth++;
+				if ( doTabs ) {
+					tabs++;
+				}
+			} else if ( token[ 0 ] == outro ) {
+				depth--;
+				if ( doTabs ) {
+					tabs--;
+				}
+			}
+			out += token;
+		}
+		out += " ";
+	} while( depth );
+
+	return out.c_str();
+}
+
+/*
 =================
 idParser::ParseRestOfLine
 
@@ -3250,3 +3319,16 @@ idParser::~idParser
 idParser::~idParser( void ) {
 	idParser::FreeSource( false );
 }
+
+/*
+========================
+idParser::EndOfFile
+========================
+*/
+bool idParser::EndOfFile() {
+	if ( scriptstack != NULL ) {
+		return (bool) scriptstack->EndOfFile();
+	}
+	return true;
+}
+
diff --git a/neo/idlib/Parser.h b/neo/idlib/Parser.h
index 88f9896..377345e 100644
--- a/neo/idlib/Parser.h
+++ b/neo/idlib/Parser.h
@@ -2,9 +2,9 @@
 ===========================================================================
 
 Doom 3 GPL Source Code
-Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
+Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 
 
-This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").  
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -119,6 +119,8 @@ public:
 	int				SkipBracedSection( bool parseFirstBrace = true );
 					// parse a braced section into a string
 	const char *	ParseBracedSection( idStr &out, int tabs = -1 );
+					// parse a braced section into a string
+	const char*		ParseBracedSection( idStr& out, int tabs, bool parseFirstBrace, char intro, char outro );
 					// parse a braced section into a string, maintaining indents and newlines
 	const char *	ParseBracedSectionExact( idStr &out, int tabs = -1 );
 					// parse the rest of the line
@@ -171,7 +173,8 @@ public:
 	void			Error( const char *str, ... ) const id_attribute((format(printf,2,3)));
 					// print a warning message
 	void			Warning( const char *str, ... ) const id_attribute((format(printf,2,3)));
-
+	// returns true if at the end of the file
+	bool			EndOfFile();
 					// add a global define that will be added to all opened sources
 	static int		AddGlobalDefine( const char *string );
 					// remove the given global define
diff --git a/neo/idlib/Str.cpp b/neo/idlib/Str.cpp
index 2271c73..0924bd0 100644
--- a/neo/idlib/Str.cpp
+++ b/neo/idlib/Str.cpp
@@ -466,6 +466,28 @@ int idStr::Last( const char c ) const {
 }
 
 /*
+========================
+idStr::Format
+
+perform a threadsafe sprintf to the string
+========================
+*/
+void idStr::Format( const char *fmt, ... ) {
+	va_list argptr;
+	char text[8192];
+
+	va_start( argptr, fmt );
+	int len = idStr::vsnPrintf( text, sizeof( text ) - 1, fmt, argptr );
+	va_end( argptr );
+	text[ sizeof( text ) - 1 ] = '\0';
+
+	if ( (size_t)len >= sizeof( text ) - 1 ) {
+		idLib::common->FatalError( "Tried to set a large buffer using %s", fmt );
+	}
+	*this = text;
+}
+
+/*
 ============
 idStr::StripLeading
 ============
diff --git a/neo/idlib/Str.h b/neo/idlib/Str.h
index 3ac1cd6..84647a7 100644
--- a/neo/idlib/Str.h
+++ b/neo/idlib/Str.h
@@ -39,6 +39,8 @@ If you have questions concerning this license or the applicable additional terms
 ===============================================================================
 */
 
+#define ASSERT_ENUM_STRING( string, index )		( 1 / (int)!( string - index ) ) ? #string : ""
+
 // these library functions should not be used for cross platform compatibility
 #ifndef IDSTR_NO_REDIRECT
 #define strcmp			idStr::Cmp		// use_idStr_Cmp
@@ -224,6 +226,7 @@ public:
 	idStr				Left( int len ) const;							// return the leftmost 'len' characters
 	idStr				Right( int len ) const;							// return the rightmost 'len' characters
 	idStr				Mid( int start, int len ) const;				// return 'len' characters starting at 'start'
+	void				Format( const char *fmt, ... );					// perform a threadsafe sprintf to the string
 	void				StripLeading( const char c );					// strip char from front as many times as the char occurs
 	void				StripLeading( const char *string );				// strip string from front as many times as the string occurs
 	bool				StripLeadingOnce( const char *string );			// strip string from front just once if it occurs
diff --git a/neo/idlib/containers/List.h b/neo/idlib/containers/List.h
index 7a328f0..0661740 100644
--- a/neo/idlib/containers/List.h
+++ b/neo/idlib/containers/List.h
@@ -29,7 +29,8 @@ If you have questions concerning this license or the applicable additional terms
 #ifndef __LIST_H__
 #define __LIST_H__
 
-#include "sys/platform.h"
+#include "idlib/containers/Sort.h"
+
 /*
 ===============================================================================
 
@@ -128,6 +129,7 @@ public:
 	bool			RemoveIndex( int index );							// remove the element at the given index
 	bool			Remove( const type & obj );							// remove the element
 	void			Sort( cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
+	void			SortWithTemplate( const idSort<type>& sort = idSort_QuickDefault<type>() );
 	void			SortSubSection( int startIndex, int endIndex, cmp_t *compare = ( cmp_t * )&idListSortCompare<type> );
 	void			Swap( idList<type> &other );						// swap the contents of the lists
 	void			DeleteContents( bool clear );						// delete the contents of the list
@@ -918,6 +920,24 @@ ID_INLINE void idList<type>::Sort( cmp_t *compare ) {
 }
 
 /*
+========================
+idList<type>::SortWithTemplate
+
+Performs a QuickSort on the list using the supplied sort algorithm.
+
+Note:	The data is merely moved around the list, so any pointers to data within the list may
+		no longer be valid.
+========================
+*/
+template<typename type>
+ID_INLINE void idList<type>::SortWithTemplate( const idSort<type>& sort ) {
+	if( list == NULL ) {
+		return;
+	}
+	sort.Sort( Ptr(), Num() );
+}
+
+/*
 ================
 idList<type>::SortSubSection
 
diff --git a/neo/idlib/containers/Sort.h b/neo/idlib/containers/Sort.h
new file mode 100644
index 0000000..7642b49
--- /dev/null
+++ b/neo/idlib/containers/Sort.h
@@ -0,0 +1,338 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+#ifndef __SORT_H__
+#define __SORT_H__
+
+/*
+================================================================================================
+Contains the generic templated sort algorithms for quick-sort, heap-sort and insertion-sort.
+
+The sort algorithms do not use class operators or overloaded functions to compare
+objects because it is often desireable to sort the same objects in different ways
+based on different keys (not just ascending and descending but sometimes based on
+name and other times based on say priority). So instead, for each different sort a
+separate class is implemented with a Compare() function.
+
+This class is derived from one of the classes that implements a sort algorithm.
+The Compare() member function does not only define how objects are sorted, the class
+can also store additional data that can be used by the Compare() function. This, for
+instance, allows a list of indices to be sorted where the indices point to objects
+in an array. The base pointer of the array with objects can be stored on the class
+that implements the Compare() function such that the Compare() function can use keys
+that are stored on the objects.
+
+The Compare() function is not virtual because this would incur significant overhead.
+Do NOT make the Compare() function virtual on the derived class!
+The sort implementations also explicitely call the Compare() function of the derived
+class. This is to avoid various compiler bugs with using overloaded compare functions
+and the inability of various compilers to find the right overloaded compare function.
+
+To sort an array, an idList or an idStaticList, a new sort class, typically derived from
+idSort_Quick, is implemented as follows:
+
+class idSort_MySort : public idSort_Quick< idMyObject, idSort_MySort > {
+public:
+	int Compare( const idMyObject & a, const idMyObject & b ) const {
+		if ( a should come before b ) {
+			return -1; // or any negative integer
+		} if ( a should come after b ) {
+			return 1;  // or any positive integer
+		} else {
+			return 0;
+		}
+	}
+};
+
+To sort an array:
+
+idMyObject array[100];
+idSort_MySort().Sort( array, 100 );
+
+To sort an idList:
+
+idList< idMyObject > list;
+list.Sort( idSort_MySort() );
+
+The sort implementations never create temporaries of the template type. Only the
+'SwapValues' template is used to move data around. This 'SwapValues' template can be
+specialized to implement fast swapping of data. For instance, when sorting a list with
+objects of some string class it is important to implement a specialized 'SwapValues' for
+this string class to avoid excessive re-allocation and copying of strings.
+
+================================================================================================
+*/
+
+/*
+========================
+SwapValues
+========================
+*/
+template< typename _type_ >
+ID_INLINE void SwapValues( _type_ & a, _type_ & b ) {
+	_type_ c = a;
+	a = b;
+	b = c;
+}
+
+/*
+================================================
+idSort is an abstract template class for sorting an array of objects of the specified data type.
+The array of objects is sorted such that: Compare( array[i], array[i+1] ) <= 0 for all i
+================================================
+*/
+template< typename _type_ >
+class idSort {
+public:
+	virtual			~idSort() {}
+	virtual void	Sort( _type_ * base, unsigned int num ) const = 0;
+};
+
+/*
+================================================
+idSort_Quick is a sort template that implements the
+quick-sort algorithm on an array of objects of the specified data type.
+================================================
+*/
+template< typename _type_, typename _derived_ >
+class idSort_Quick : public idSort< _type_ > {
+public:
+	virtual void Sort( _type_ * base, unsigned int num ) const {
+		if ( num <= 0 ) {
+			return;
+		}
+
+		const int64_t MAX_LEVELS = 128;
+		int64_t lo[MAX_LEVELS], hi[MAX_LEVELS];
+
+		// 'lo' is the lower index, 'hi' is the upper index
+		// of the region of the array that is being sorted.
+		lo[0] = 0;
+		hi[0] = num - 1;
+
+		for ( int64_t level = 0; level >= 0; ) {
+			int64_t i = lo[level];
+			int64_t j = hi[level];
+
+			// Only use quick-sort when there are 4 or more elements in this region and we are below MAX_LEVELS.
+			// Otherwise fall back to an insertion-sort.
+			if ( ( ( j - i ) >= 4 ) && ( level < ( MAX_LEVELS - 1 ) ) ) {
+
+				// Use the center element as the pivot.
+				// The median of a multi point sample could be used
+				// but simply taking the center works quite well.
+				int64_t pi = ( i + j ) / 2;
+
+				// Move the pivot element to the end of the region.
+				SwapValues( base[j], base[pi] );
+
+				// Get a reference to the pivot element.
+				_type_ & pivot = base[j--];
+
+				// Partition the region.
+				do {
+					while( static_cast< const _derived_ * >( this )->Compare( base[i], pivot ) < 0 ) { if ( ++i >= j ) break; }
+					while( static_cast< const _derived_ * >( this )->Compare( base[j], pivot ) > 0 ) { if ( --j <= i ) break; }
+					if ( i >= j ) break;
+					SwapValues( base[i], base[j] );
+				} while( ++i < --j );
+
+				// Without these iterations sorting of arrays with many duplicates may
+				// become really slow because the partitioning can be very unbalanced.
+				// However, these iterations are unnecessary if all elements are unique.
+				while ( static_cast< const _derived_ * >( this )->Compare( base[i], pivot ) <= 0 && i < hi[level] ) { i++; }
+				while ( static_cast< const _derived_ * >( this )->Compare( base[j], pivot ) >= 0 && lo[level] < j ) { j--; }
+
+				// Move the pivot element in place.
+				SwapValues( pivot, base[i] );
+
+				assert( level < MAX_LEVELS - 1 );
+				lo[level+1] = i;
+				hi[level+1] = hi[level];
+				hi[level] = j;
+				level++;
+
+			} else {
+
+				// Insertion-sort of the remaining elements.
+				for( ; i < j; j-- ) {
+					int64_t m = i;
+					for ( int64_t k = i + 1; k <= j; k++ ) {
+						if ( static_cast< const _derived_ * >( this )->Compare( base[k], base[m] ) > 0 ) {
+							m = k;
+						}
+					}
+					SwapValues( base[m], base[j] );
+				}
+				level--;
+			}
+		}
+	}
+};
+
+/*
+================================================
+Default quick-sort comparison function that can
+be used to sort scalars from small to large.
+================================================
+*/
+template< typename _type_ >
+class idSort_QuickDefault : public idSort_Quick< _type_, idSort_QuickDefault< _type_ > > {
+public:
+	int Compare( const _type_ & a, const _type_ & b ) const { return a - b; }
+};
+
+/*
+================================================
+Specialization for floating point values to avoid an float-to-int
+conversion for every comparison.
+================================================
+*/
+template<>
+class idSort_QuickDefault< float > : public idSort_Quick< float, idSort_QuickDefault< float > > {
+public:
+	int Compare( const float & a, const float & b ) const {
+		if ( a < b ) {
+			return -1;
+		}
+		if ( a > b ) {
+			return 1;
+		}
+		return 0;
+	}
+};
+
+/*
+================================================
+idSort_Heap is a sort template class that implements the
+heap-sort algorithm on an array of objects of the specified data type.
+================================================
+*/
+template< typename _type_, typename _derived_ >
+class idSort_Heap : public idSort< _type_ > {
+public:
+	virtual void Sort( _type_ * base, unsigned int num ) const {
+		// get all elements in heap order
+#if 1
+		// O( n )
+		for ( unsigned int i = num / 2; i > 0; i-- ) {
+			// sift down
+			unsigned int parent = i - 1;
+			for ( unsigned int child = parent * 2 + 1; child < num; child = parent * 2 + 1 ) {
+				if ( child + 1 < num && static_cast< const _derived_ * >( this )->Compare( base[child + 1], base[child] ) > 0 ) {
+					child++;
+				}
+				if ( static_cast< const _derived_ * >( this )->Compare( base[child], base[parent] ) <= 0 ) {
+					break;
+				}
+				SwapValues( base[parent], base[child] );
+				parent = child;
+			}
+		}
+#else
+		// O(n log n)
+		for ( unsigned int i = 1; i < num; i++ ) {
+			// sift up
+			for ( unsigned int child = i; child > 0; ) {
+				unsigned int parent = ( child - 1 ) / 2;
+				if ( static_cast< const _derived_ * >( this )->Compare( base[parent], base[child] ) > 0 ) {
+					break;
+				}
+				SwapValues( base[child], base[parent] );
+				child = parent;
+			}
+		}
+#endif
+		// get sorted elements while maintaining heap order
+		for ( unsigned int i = num - 1; i > 0; i-- ) {
+			SwapValues( base[0], base[i] );
+			// sift down
+			unsigned int parent = 0;
+			for ( unsigned int child = parent * 2 + 1; child < i; child = parent * 2 + 1 ) {
+				if ( child + 1 < i && static_cast< const _derived_ * >( this )->Compare( base[child + 1], base[child] ) > 0 ) {
+					child++;
+				}
+				if ( static_cast< const _derived_ * >( this )->Compare( base[child], base[parent] ) <= 0 ) {
+					break;
+				}
+				SwapValues( base[parent], base[child] );
+				parent = child;
+			}
+		}
+	}
+};
+
+/*
+================================================
+Default heap-sort comparison function that can
+be used to sort scalars from small to large.
+================================================
+*/
+template< typename _type_ >
+class idSort_HeapDefault : public idSort_Heap< _type_, idSort_HeapDefault< _type_ > > {
+public:
+	int Compare( const _type_ & a, const _type_ & b ) const { return a - b; }
+};
+
+/*
+================================================
+idSort_Insertion is a sort template class that implements the
+insertion-sort algorithm on an array of objects of the specified data type.
+================================================
+*/
+template< typename _type_, typename _derived_ >
+class idSort_Insertion : public idSort< _type_ > {
+public:
+	virtual void Sort( _type_ * base, unsigned int num ) const {
+		_type_ * lo = base;
+		_type_ * hi = base + ( num - 1 );
+		while( hi > lo ) {
+			_type_ * max = lo;
+			for ( _type_ * p = lo + 1; p <= hi; p++ ) {
+				if ( static_cast< const _derived_ * >( this )->Compare( (*p), (*max) ) > 0 ) {
+					max = p;
+				}
+			}
+			SwapValues( *max, *hi );
+			hi--;
+		}
+	}
+};
+
+/*
+================================================
+Default insertion-sort comparison function that can
+be used to sort scalars from small to large.
+================================================
+*/
+template< typename _type_ >
+class idSort_InsertionDefault : public idSort_Insertion< _type_, idSort_InsertionDefault< _type_ > > {
+public:
+	int Compare( const _type_ & a, const _type_ & b ) const { return a - b; }
+};
+
+#endif // !__SORT_H__
diff --git a/neo/renderer/GuiModel.cpp b/neo/renderer/GuiModel.cpp
index 08fdb2c..3350dbf 100644
--- a/neo/renderer/GuiModel.cpp
+++ b/neo/renderer/GuiModel.cpp
@@ -333,7 +333,7 @@ SetColor
 =============
 */
 void idGuiModel::SetColor( float r, float g, float b, float a ) {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 	if ( r == surf->color[0] && g == surf->color[1]
@@ -359,7 +359,7 @@ DrawStretchPic
 */
 void idGuiModel::DrawStretchPic( const idDrawVert *dverts, const glIndex_t *dindexes, int vertCount, int indexCount, const idMaterial *hShader,
 									   bool clip, float min_x, float min_y, float max_x, float max_y ) {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 	if ( !( dverts && dindexes && vertCount && indexCount && hShader ) ) {
@@ -461,7 +461,7 @@ void idGuiModel::DrawStretchPic( float x, float y, float w, float h, float s1, f
 	idDrawVert verts[4];
 	glIndex_t indexes[6];
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 	if ( !hShader ) {
@@ -572,7 +572,7 @@ void idGuiModel::DrawStretchTri( idVec2 p1, idVec2 p2, idVec2 p3, idVec2 t1, idV
 	int vertCount = 3;
 	int indexCount = 3;
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 	if ( !material ) {
diff --git a/neo/renderer/Image_init.cpp b/neo/renderer/Image_init.cpp
index 20deaf6..bd7240e 100644
--- a/neo/renderer/Image_init.cpp
+++ b/neo/renderer/Image_init.cpp
@@ -57,7 +57,6 @@ idCVar idImageManager::image_useNormalCompression( "image_useNormalCompression",
 idCVar idImageManager::image_usePrecompressedTextures( "image_usePrecompressedTextures", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_BOOL, "use .dds files if present" );
 idCVar idImageManager::image_writePrecompressedTextures( "image_writePrecompressedTextures", "0", CVAR_RENDERER | CVAR_BOOL, "write .dds files if necessary" );
 idCVar idImageManager::image_writeNormalTGA( "image_writeNormalTGA", "0", CVAR_RENDERER | CVAR_BOOL, "write .tgas of the final normal maps for debugging" );
-idCVar idImageManager::image_writeNormalTGAPalletized( "image_writeNormalTGAPalletized", "0", CVAR_RENDERER | CVAR_BOOL, "write .tgas of the final palletized normal maps for debugging" );
 idCVar idImageManager::image_writeTGA( "image_writeTGA", "0", CVAR_RENDERER | CVAR_BOOL, "write .tgas of the non normal maps for debugging" );
 idCVar idImageManager::image_useOffLineCompression( "image_useOfflineCompression", "0", CVAR_RENDERER | CVAR_BOOL, "write a batch file for offline compression of DDS files" );
 idCVar idImageManager::image_cacheMinK( "image_cacheMinK", "200", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "maximum KB of precompressed files to read at specification time" );
@@ -148,78 +147,6 @@ static void R_RampImage( idImage *image ) {
 
 /*
 ================
-R_SpecularTableImage
-
-Creates a ramp that matches our fudged specular calculation
-================
-*/
-static void R_SpecularTableImage( idImage *image ) {
-	int		x;
-	byte	data[256][4];
-
-	for (x=0 ; x<256 ; x++) {
-		float f = x/255.f;
-#if 0
-		f = pow(f, 16);
-#else
-		// this is the behavior of the hacked up fragment programs that
-		// can't really do a power function
-		f = (f-0.75)*4;
-		if ( f < 0 ) {
-			f = 0;
-		}
-		f = f * f;
-#endif
-		int		b = (int)(f * 255);
-
-		data[x][0] =
-		data[x][1] =
-		data[x][2] =
-		data[x][3] = b;
-	}
-
-	image->GenerateImage( (byte *)data, 256, 1,
-		TF_LINEAR, false, TR_CLAMP, TD_HIGH_QUALITY );
-}
-
-
-/*
-================
-R_Specular2DTableImage
-
-Create a 2D table that calculates ( reflection dot , specularity )
-================
-*/
-static void R_Specular2DTableImage( idImage *image ) {
-	int		x, y;
-	byte	data[256][256][4];
-
-	memset( data, 0, sizeof( data ) );
-		for ( x = 0 ; x < 256 ; x++ ) {
-			float f = x / 255.0f;
-		for ( y = 0; y < 256; y++ ) {
-
-			int b = (int)( pow( f, y ) * 255.0f );
-			if ( b == 0 ) {
-				// as soon as b equals zero all remaining values in this column are going to be zero
-				// we early out to avoid pow() underflows
-				break;
-			}
-
-			data[y][x][0] =
-			data[y][x][1] =
-			data[y][x][2] =
-			data[y][x][3] = b;
-		}
-	}
-
-	image->GenerateImage( (byte *)data, 256, 256, TF_LINEAR, false, TR_CLAMP, TD_HIGH_QUALITY );
-}
-
-
-
-/*
-================
 R_AlphaRampImage
 
 Creates a 0-255 ramp image
@@ -363,7 +290,7 @@ static void R_BorderClampImage( idImage *image ) {
 	image->GenerateImage( (byte *)data, BORDER_CLAMP_SIZE, BORDER_CLAMP_SIZE,
 		TF_LINEAR /* TF_NEAREST */, false, TR_CLAMP_TO_BORDER, TD_DEFAULT );
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		// can't call qglTexParameterfv yet
 		return;
 	}
@@ -989,11 +916,8 @@ static const filterName_t textureFilters[] = {
 		case TT_2D:
 			texEnum = GL_TEXTURE_2D;
 			break;
-		case TT_3D:
-			texEnum = GL_TEXTURE_3D;
-			break;
 		case TT_CUBIC:
-			texEnum = GL_TEXTURE_CUBE_MAP_EXT;
+			texEnum = GL_TEXTURE_CUBE_MAP;
 			break;
 		}
 
@@ -1195,8 +1119,8 @@ void R_ListImages_f( const idCmdArgs &args ) {
 		image = globalImages->images[ i ];
 
 		if ( uncompressedOnly ) {
-			if ( ( image->internalFormat >= GL_COMPRESSED_RGB_S3TC_DXT1_EXT && image->internalFormat <= GL_COMPRESSED_RGBA_S3TC_DXT5_EXT )
-				|| image->internalFormat == GL_COLOR_INDEX8_EXT ) {
+			if ( ( image->internalFormat >= GL_COMPRESSED_RGB_S3TC_DXT1_EXT && image->internalFormat <= GL_COMPRESSED_RGBA_S3TC_DXT5_EXT ) ) {
+
 				continue;
 			}
 		}
@@ -1301,108 +1225,6 @@ void R_ListImages_f( const idCmdArgs &args ) {
 
 }
 
-/*
-==================
-SetNormalPalette
-
-Create a 256 color palette to be used by compressed normal maps
-==================
-*/
-void idImageManager::SetNormalPalette( void ) {
-	int		i, j;
-	idVec3	v;
-	float	t;
-	//byte temptable[768];
-	byte	*temptable = compressedPalette;
-	int		compressedToOriginal[16];
-
-	// make an ad-hoc separable compression mapping scheme
-	for ( i = 0 ; i < 8 ; i++ ) {
-		float	f, y;
-
-		f = ( i + 1 ) / 8.5;
-		y = idMath::Sqrt( 1.0 - f * f );
-		y = 1.0 - y;
-
-		compressedToOriginal[7-i] = 127 - (int)( y * 127 + 0.5 );
-		compressedToOriginal[8+i] = 128 + (int)( y * 127 + 0.5 );
-	}
-
-	for ( i = 0 ; i < 256 ; i++ ) {
-		if ( i <= compressedToOriginal[0] ) {
-			originalToCompressed[i] = 0;
-		} else if ( i >= compressedToOriginal[15] ) {
-			originalToCompressed[i] = 15;
-		} else {
-			for ( j = 0 ; j < 14 ; j++ ) {
-				if ( i <= compressedToOriginal[j+1] ) {
-					break;
-				}
-			}
-			if ( i - compressedToOriginal[j] < compressedToOriginal[j+1] - i ) {
-				originalToCompressed[i] = j;
-			} else {
-				originalToCompressed[i] = j + 1;
-			}
-		}
-	}
-
-#if 0
-	for ( i = 0; i < 16; i++ ) {
-		for ( j = 0 ; j < 16 ; j++ ) {
-
-			v[0] = ( i - 7.5 ) / 8;
-			v[1] = ( j - 7.5 ) / 8;
-
-			t = 1.0 - ( v[0]*v[0] + v[1]*v[1] );
-			if ( t < 0 ) {
-				t = 0;
-			}
-			v[2] = idMath::Sqrt( t );
-
-			temptable[(i*16+j)*3+0] = 128 + floor( 127 * v[0] + 0.5 );
-			temptable[(i*16+j)*3+1] = 128 + floor( 127 * v[1] );
-			temptable[(i*16+j)*3+2] = 128 + floor( 127 * v[2] );
-		}
-	}
-#else
-	for ( i = 0; i < 16; i++ ) {
-		for ( j = 0 ; j < 16 ; j++ ) {
-
-			v[0] = ( compressedToOriginal[i] - 127.5 ) / 128;
-			v[1] = ( compressedToOriginal[j] - 127.5 ) / 128;
-
-			t = 1.0 - ( v[0]*v[0] + v[1]*v[1] );
-			if ( t < 0 ) {
-				t = 0;
-			}
-			v[2] = idMath::Sqrt( t );
-
-			temptable[(i*16+j)*3+0] = (byte)(128 + floor( 127 * v[0] + 0.5 ));
-			temptable[(i*16+j)*3+1] = (byte)(128 + floor( 127 * v[1] ));
-			temptable[(i*16+j)*3+2] = (byte)(128 + floor( 127 * v[2] ));
-		}
-	}
-#endif
-
-	// color 255 will be the "nullnormal" color for no reflection
-	temptable[255*3+0] =
-	temptable[255*3+1] =
-	temptable[255*3+2] = 128;
-
-	if ( !glConfig.sharedTexturePaletteAvailable ) {
-		return;
-	}
-
-	qglColorTableEXT( GL_SHARED_TEXTURE_PALETTE_EXT,
-					   GL_RGB,
-					   256,
-					   GL_RGB,
-					   GL_UNSIGNED_BYTE,
-					   temptable );
-
-	qglEnable( GL_SHARED_TEXTURE_PALETTE_EXT );
-}
 
 /*
 ==============
@@ -1687,9 +1509,6 @@ ReloadAllImages
 void idImageManager::ReloadAllImages() {
 	idCmdArgs args;
 
-	// build the compressed normal map palette
-	SetNormalPalette();
-
 	args.TokenizeString( "reloadImages reload", false );
 	R_ReloadImages_f( args );
 }
@@ -1932,9 +1751,7 @@ void idImageManager::BindNull() {
 	tmu = &backEnd.glState.tmu[backEnd.glState.currenttmu];
 
 	if ( tmu->textureType == TT_CUBIC ) {
-		qglDisable( GL_TEXTURE_CUBE_MAP_EXT );
-	} else if ( tmu->textureType == TT_3D ) {
-		qglDisable( GL_TEXTURE_3D );
+		qglDisable( GL_TEXTURE_CUBE_MAP );
 	} else if ( tmu->textureType == TT_2D ) {
 		qglDisable( GL_TEXTURE_2D );
 	}
@@ -1966,14 +1783,11 @@ void idImageManager::Init() {
 	borderClampImage = ImageFromFunction( "_borderClamp", R_BorderClampImage );
 	flatNormalMap = ImageFromFunction( "_flat", R_FlatNormalImage );
 	ambientNormalMap = ImageFromFunction( "_ambient", R_AmbientNormalImage );
-	specularTableImage = ImageFromFunction( "_specularTable", R_SpecularTableImage );
-	specular2DTableImage = ImageFromFunction( "_specular2DTable", R_Specular2DTableImage );
 	rampImage = ImageFromFunction( "_ramp", R_RampImage );
 	alphaRampImage = ImageFromFunction( "_alphaRamp", R_RampImage );
 	alphaNotchImage = ImageFromFunction( "_alphaNotch", R_AlphaNotchImage );
 	fogImage = ImageFromFunction( "_fog", R_FogImage );
 	fogEnterImage = ImageFromFunction( "_fogEnter", R_FogEnterImage );
-	normalCubeMapImage = ImageFromFunction( "_normalCubeMap", makeNormalizeVectorCubeMap );
 	noFalloffImage = ImageFromFunction( "_noFalloff", R_CreateNoFalloffImage );
 	ImageFromFunction( "_quadratic", R_QuadraticImage );
 
diff --git a/neo/renderer/Image_load.cpp b/neo/renderer/Image_load.cpp
index 505793d..5ecb670 100644
--- a/neo/renderer/Image_load.cpp
+++ b/neo/renderer/Image_load.cpp
@@ -2,9 +2,9 @@
 ===========================================================================
 
 Doom 3 GPL Source Code
-Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
+Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 
 
-This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").  
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -37,7 +37,7 @@ PROBLEM: compressed textures may break the zero clamp rule!
 */
 
 static bool FormatIsDXT( int internalFormat ) {
-	if ( internalFormat < GL_COMPRESSED_RGB_S3TC_DXT1_EXT
+	if ( internalFormat < GL_COMPRESSED_RGB_S3TC_DXT1_EXT 
 	|| internalFormat > GL_COMPRESSED_RGBA_S3TC_DXT5_EXT ) {
 		return false;
 	}
@@ -90,10 +90,6 @@ int idImage::BitsForInternalFormat( int internalFormat ) const {
 		return 16;
 	case GL_RGB5:
 		return 16;
-	case GL_COLOR_INDEX8_EXT:
-		return 8;
-	case GL_COLOR_INDEX:
-		return 8;
 	case GL_COMPRESSED_RGB_ARB:
 		return 4;			// not sure
 	case GL_COMPRESSED_RGBA_ARB:
@@ -104,77 +100,6 @@ int idImage::BitsForInternalFormat( int internalFormat ) const {
 	return 0;
 }
 
-/*
-==================
-UploadCompressedNormalMap
-
-Create a 256 color palette to be used by compressed normal maps
-==================
-*/
-void idImage::UploadCompressedNormalMap( int width, int height, const byte *rgba, int mipLevel ) {
-	byte	*normals;
-	const byte	*in;
-	byte	*out;
-	int		i, j;
-	int		x, y, z;
-	int		row;
-
-	// OpenGL's pixel packing rule
-	row = width < 4 ? 4 : width;
-
-	normals = (byte *)_alloca( row * height );
-	if ( !normals ) {
-		common->Error( "R_UploadCompressedNormalMap: _alloca failed" );
-	}
-
-	in = rgba;
-	out = normals;
-	for ( i = 0 ; i < height ; i++, out += row, in += width * 4 ) {
-		for ( j = 0 ; j < width ; j++ ) {
-			x = in[ j * 4 + 0 ];
-			y = in[ j * 4 + 1 ];
-			z = in[ j * 4 + 2 ];
-
-			int c;
-			if ( x == 128 && y == 128 && z == 128 ) {
-				// the "nullnormal" color
-				c = 255;
-			} else {
-				c = ( globalImages->originalToCompressed[x] << 4 ) | globalImages->originalToCompressed[y];
-				if ( c == 255 ) {
-					c = 254;	// don't use the nullnormal color
-				}
-			}
-			out[j] = c;
-		}
-	}
-
-	if ( mipLevel == 0 ) {
-		// Optionally write out the paletized normal map to a .tga
-		if ( globalImages->image_writeNormalTGAPalletized.GetBool() ) {
-			char filename[MAX_IMAGE_NAME];
-			ImageProgramStringToCompressedFileName( imgName, filename );
-			char *ext = strrchr(filename, '.');
-			if ( ext ) {
-				strcpy(ext, "_pal.tga");
-				R_WritePalTGA( filename, normals, globalImages->compressedPalette, width, height);
-			}
-		}
-	}
-
-	if ( glConfig.sharedTexturePaletteAvailable ) {
-		qglTexImage2D( GL_TEXTURE_2D,
-					mipLevel,
-					GL_COLOR_INDEX8_EXT,
-					width,
-					height,
-					0,
-					GL_COLOR_INDEX,
-					GL_UNSIGNED_BYTE,
-					normals );
-	}
-}
-
 
 //=======================================================================
 
@@ -232,7 +157,7 @@ GLenum idImage::SelectInternalFormat( const byte **dataPtrs, int numDataPtrs, in
 
 			cor = scan[0] | scan[1] | scan[2];
 			cand = scan[0] & scan[1] & scan[2];
-
+			
 			// if rgb are all the same, the or and and will match
 			rgbDiffer |= ( cor ^ cand );
 
@@ -259,15 +184,12 @@ GLenum idImage::SelectInternalFormat( const byte **dataPtrs, int numDataPtrs, in
 
 	// catch normal maps first
 	if ( minimumDepth == TD_BUMP ) {
-		if ( globalImages->image_useCompression.GetBool() && globalImages->image_useNormalCompression.GetInteger() == 1 && glConfig.sharedTexturePaletteAvailable ) {
-			// image_useNormalCompression should only be set to 1 on nv_10 and nv_20 paths
-			return GL_COLOR_INDEX8_EXT;
-		} else if ( globalImages->image_useCompression.GetBool() && globalImages->image_useNormalCompression.GetInteger() && glConfig.textureCompressionAvailable ) {
+		if ( globalImages->image_useCompression.GetBool() && globalImages->image_useNormalCompression.GetInteger() && glConfig.textureCompressionAvailable ) {
 			// image_useNormalCompression == 2 uses rxgb format which produces really good quality for medium settings
 			return GL_COMPRESSED_RGBA_S3TC_DXT5_EXT;
 		} else {
 			// we always need the alpha channel for bump maps for swizzling
-			return GL_RGBA8;
+			return GL_RGBA8; 
 		}
 	}
 
@@ -495,8 +417,8 @@ There is no way to specify explicit mip map levels
 
 ================
 */
-void idImage::GenerateImage( const byte *pic, int width, int height,
-					   textureFilter_t filterParm, bool allowDownSizeParm,
+void idImage::GenerateImage( const byte *pic, int width, int height, 
+					   textureFilter_t filterParm, bool allowDownSizeParm, 
 					   textureRepeat_t repeatParm, textureDepth_t depthParm ) {
 	bool	preserveBorder;
 	byte		*scaledBuffer;
@@ -514,7 +436,7 @@ void idImage::GenerateImage( const byte *pic, int width, int height,
 	// have filled in the parms.  We must have the values set, or
 	// an image match from a shader before OpenGL starts would miss
 	// the generated texture
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -611,26 +533,7 @@ void idImage::GenerateImage( const byte *pic, int width, int height,
 		char *ext = strrchr(filename, '.');
 		if ( ext ) {
 			strcpy( ext, ".tga" );
-			// swap the red/alpha for the write
-			/*
-			if ( depth == TD_BUMP ) {
-				for ( int i = 0; i < scaled_width * scaled_height * 4; i += 4 ) {
-					scaledBuffer[ i ] = scaledBuffer[ i + 3 ];
-					scaledBuffer[ i + 3 ] = 0;
-				}
-			}
-			*/
 			R_WriteTGA( filename, scaledBuffer, scaled_width, scaled_height, false );
-
-			// put it back
-			/*
-			if ( depth == TD_BUMP ) {
-				for ( int i = 0; i < scaled_width * scaled_height * 4; i += 4 ) {
-					scaledBuffer[ i + 3 ] = scaledBuffer[ i ];
-					scaledBuffer[ i ] = 0;
-				}
-			}
-			*/
 		}
 	}
 
@@ -645,23 +548,11 @@ void idImage::GenerateImage( const byte *pic, int width, int height,
 			scaledBuffer[ i ] = 0;
 		}
 	}
+
 	// upload the main image level
 	Bind();
 
-
-	if ( internalFormat == GL_COLOR_INDEX8_EXT ) {
-		/*
-		if ( depth == TD_BUMP ) {
-			for ( int i = 0; i < scaled_width * scaled_height * 4; i += 4 ) {
-				scaledBuffer[ i ] = scaledBuffer[ i + 3 ];
-				scaledBuffer[ i + 3 ] = 0;
-			}
-		}
-		*/
-		UploadCompressedNormalMap( scaled_width, scaled_height, scaledBuffer, 0 );
-	} else {
-		qglTexImage2D( GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
-	}
+	qglTexImage2D( GL_TEXTURE_2D, 0, internalFormat, scaled_width, scaled_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 
 	// create and upload the mip map levels, which we do in all cases, even if we don't think they are needed
 	int		miplevel;
@@ -692,12 +583,8 @@ void idImage::GenerateImage( const byte *pic, int width, int height,
 		}
 
 		// upload the mip map
-		if ( internalFormat == GL_COLOR_INDEX8_EXT ) {
-			UploadCompressedNormalMap( scaled_width, scaled_height, scaledBuffer, miplevel );
-		} else {
-			qglTexImage2D( GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height,
-				0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
-		}
+		qglTexImage2D( GL_TEXTURE_2D, miplevel, internalFormat, scaled_width, scaled_height, 
+			0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
 	}
 
 	if ( scaledBuffer != 0 ) {
@@ -712,148 +599,14 @@ void idImage::GenerateImage( const byte *pic, int width, int height,
 
 
 /*
-==================
-Generate3DImage
-==================
-*/
-void idImage::Generate3DImage( const byte *pic, int width, int height, int picDepth,
-					   textureFilter_t filterParm, bool allowDownSizeParm,
-					   textureRepeat_t repeatParm, textureDepth_t minDepthParm ) {
-	int			scaled_width, scaled_height, scaled_depth;
-
-	PurgeImage();
-
-	filter = filterParm;
-	allowDownSize = allowDownSizeParm;
-	repeat = repeatParm;
-	depth = minDepthParm;
-
-	// if we don't have a rendering context, just return after we
-	// have filled in the parms.  We must have the values set, or
-	// an image match from a shader before OpenGL starts would miss
-	// the generated texture
-	if ( !glConfig.isInitialized ) {
-		return;
-	}
-
-	// make sure it is a power of 2
-	scaled_width = MakePowerOfTwo( width );
-	scaled_height = MakePowerOfTwo( height );
-	scaled_depth = MakePowerOfTwo( picDepth );
-	if ( scaled_width != width || scaled_height != height || scaled_depth != picDepth ) {
-		common->Error( "R_Create3DImage: not a power of 2 image" );
-	}
-
-	// FIXME: allow picmip here
-
-	// generate the texture number
-	qglGenTextures( 1, &texnum );
-
-	// select proper internal format before we resample
-	// this function doesn't need to know it is 3D, so just make it very "tall"
-	internalFormat = SelectInternalFormat( &pic, 1, width, height * picDepth, minDepthParm );
-
-	uploadHeight = scaled_height;
-	uploadWidth = scaled_width;
-	uploadDepth = scaled_depth;
-
-
-	type = TT_3D;
-
-	// upload the main image level
-	Bind();
-
-	qglTexImage3D(GL_TEXTURE_3D, 0, internalFormat, scaled_width, scaled_height, scaled_depth,
-		0, GL_RGBA, GL_UNSIGNED_BYTE, pic );
-
-	// create and upload the mip map levels
-	int		miplevel;
-	byte	*scaledBuffer, *shrunk;
-
-	scaledBuffer = (byte *)R_StaticAlloc( scaled_width * scaled_height * scaled_depth * 4 );
-	memcpy( scaledBuffer, pic, scaled_width * scaled_height * scaled_depth * 4 );
-	miplevel = 0;
-	while ( scaled_width > 1 || scaled_height > 1 || scaled_depth > 1 ) {
-		// preserve the border after mip map unless repeating
-		shrunk = R_MipMap3D( scaledBuffer, scaled_width, scaled_height, scaled_depth,
-			(bool)(repeat != TR_REPEAT) );
-		R_StaticFree( scaledBuffer );
-		scaledBuffer = shrunk;
-
-		scaled_width >>= 1;
-		scaled_height >>= 1;
-		scaled_depth >>= 1;
-		if ( scaled_width < 1 ) {
-			scaled_width = 1;
-		}
-		if ( scaled_height < 1 ) {
-			scaled_height = 1;
-		}
-		if ( scaled_depth < 1 ) {
-			scaled_depth = 1;
-		}
-		miplevel++;
-
-		// upload the mip map
-		qglTexImage3D(GL_TEXTURE_3D, miplevel, internalFormat, scaled_width, scaled_height, scaled_depth,
-			0, GL_RGBA, GL_UNSIGNED_BYTE, scaledBuffer );
-	}
-	R_StaticFree( scaledBuffer );
-
-	// set the minimize / maximize filtering
-	switch( filter ) {
-	case TF_DEFAULT:
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, globalImages->textureMinFilter );
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, globalImages->textureMaxFilter );
-		break;
-	case TF_LINEAR:
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
-		break;
-	case TF_NEAREST:
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-		qglTexParameterf(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
-		break;
-	default:
-		common->FatalError( "R_CreateImage: bad texture filter" );
-	}
-
-	// set the wrap/clamp modes
-	switch( repeat ) {
-	case TR_REPEAT:
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_REPEAT );
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_REPEAT );
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_REPEAT );
-		break;
-	case TR_CLAMP_TO_BORDER:
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER );
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER );
-		break;
-	case TR_CLAMP_TO_ZERO:
-	case TR_CLAMP_TO_ZERO_ALPHA:
-	case TR_CLAMP:
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
-		qglTexParameterf( GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE );
-		break;
-	default:
-		common->FatalError( "R_CreateImage: bad texture repeat" );
-	}
-
-	// see if we messed anything up
-	GL_CheckErrors();
-}
-
-
-/*
 ====================
 GenerateCubeImage
 
 Non-square cube sides are not allowed
 ====================
 */
-void idImage::GenerateCubeImage( const byte *pic[6], int size,
-					   textureFilter_t filterParm, bool allowDownSizeParm,
+void idImage::GenerateCubeImage( const byte *pic[6], int size, 
+					   textureFilter_t filterParm, bool allowDownSizeParm, 
 					   textureDepth_t depthParm ) {
 	int			scaled_width, scaled_height;
 	int			width, height;
@@ -871,11 +624,7 @@ void idImage::GenerateCubeImage( const byte *pic[6], int size,
 	// have filled in the parms.  We must have the values set, or
 	// an image match from a shader before OpenGL starts would miss
 	// the generated texture
-	if ( !glConfig.isInitialized ) {
-		return;
-	}
-
-	if ( ! glConfig.cubeMapAvailable ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -897,35 +646,33 @@ void idImage::GenerateCubeImage( const byte *pic[6], int size,
 	Bind();
 
 	// no other clamp mode makes sense
-	qglTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-	qglTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+	qglTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+	qglTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
 
 	// set the minimize / maximize filtering
 	switch( filter ) {
 	case TF_DEFAULT:
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MIN_FILTER, globalImages->textureMinFilter );
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MAG_FILTER, globalImages->textureMaxFilter );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, globalImages->textureMinFilter );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, globalImages->textureMaxFilter );
 		break;
 	case TF_LINEAR:
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
 		break;
 	case TF_NEAREST:
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
-		qglTexParameterf(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
+		qglTexParameterf( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
 		break;
 	default:
 		common->FatalError( "R_CreateImage: bad texture filter" );
 	}
 
 	// upload the base level
-	// FIXME: support GL_COLOR_INDEX8_EXT?
 	for ( i = 0 ; i < 6 ; i++ ) {
-		qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, internalFormat, scaled_width, scaled_height, 0,
+		qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, internalFormat, scaled_width, scaled_height, 0, 
 			GL_RGBA, GL_UNSIGNED_BYTE, pic[i] );
 	}
 
-
 	// create and upload the mip map levels
 	int		miplevel;
 	byte	*shrunk[6];
@@ -939,8 +686,8 @@ void idImage::GenerateCubeImage( const byte *pic[6], int size,
 		for ( i = 0 ; i < 6 ; i++ ) {
 			byte	*shrunken;
 
-			qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, miplevel, internalFormat,
-				scaled_width / 2, scaled_height / 2, 0,
+			qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, miplevel, internalFormat, 
+				scaled_width / 2, scaled_height / 2, 0, 
 				GL_RGBA, GL_UNSIGNED_BYTE, shrunk[i] );
 
 			if ( scaled_width > 2 ) {
@@ -1036,7 +783,7 @@ void idImage::WritePrecompressedImage() {
 		}
 	}
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -1056,13 +803,6 @@ void idImage::WritePrecompressedImage() {
 	int altInternalFormat = 0;
 	int bitSize = 0;
 	switch ( internalFormat ) {
-		case GL_COLOR_INDEX8_EXT:
-		case GL_COLOR_INDEX:
-			// this will not work with dds viewers but we need it in this format to save disk
-			// load speed ( i.e. size )
-			altInternalFormat = GL_COLOR_INDEX;
-			bitSize = 24;
-		break;
 		case 1:
 		case GL_INTENSITY8:
 		case GL_LUMINANCE8:
@@ -1131,8 +871,7 @@ void idImage::WritePrecompressedImage() {
 		header.dwFlags |= DDSF_LINEARSIZE;
 		header.dwPitchOrLinearSize = ( ( uploadWidth + 3 ) / 4 ) * ( ( uploadHeight + 3 ) / 4 )*
 			(altInternalFormat <= GL_COMPRESSED_RGBA_S3TC_DXT1_EXT ? 8 : 16);
-	}
-	else {
+	} else {
 		// 4 Byte aligned line width (from nv_dds)
 		header.dwFlags |= DDSF_PITCH;
 		header.dwPitchOrLinearSize = ( ( uploadWidth * bitSize + 31 ) & -32 ) >> 3;
@@ -1165,7 +904,7 @@ void idImage::WritePrecompressedImage() {
 			break;
 		}
 	} else {
-		header.ddspf.dwFlags = ( internalFormat == GL_COLOR_INDEX8_EXT ) ? DDSF_RGB | DDSF_ID_INDEXCOLOR : DDSF_RGB;
+		header.ddspf.dwFlags = DDSF_RGB;
 		header.ddspf.dwRGBBitCount = bitSize;
 		switch ( altInternalFormat ) {
 		case GL_BGRA_EXT:
@@ -1318,7 +1057,7 @@ If fullLoad is false, only the small mip levels of the image will be loaded
 ================
 */
 bool idImage::CheckPrecompressedImage( bool fullLoad ) {
-	if ( !glConfig.isInitialized || !glConfig.textureCompressionAvailable ) {
+	if ( !R_IsInitialized() || !glConfig.textureCompressionAvailable ) {
 		return false;
 	}
 
@@ -1332,12 +1071,7 @@ bool idImage::CheckPrecompressedImage( bool fullLoad ) {
 	if ( depth == TD_BUMP && globalImages->image_useNormalCompression.GetInteger() != 2 ) {
 		return false;
 	}
-
-	// god i love last minute hacks :-)
-	if ( com_machineSpec.GetInteger() >= 1 && imgName.Icmpn( "lights/", 7 ) == 0 ) {
-		return false;
-	}
-
+	
 	char filename[MAX_IMAGE_NAME];
 	ImageProgramStringToCompressedFileName( imgName, filename );
 
@@ -1383,7 +1117,7 @@ bool idImage::CheckPrecompressedImage( bool fullLoad ) {
 
 	fileSystem->CloseFile( f );
 
-	unsigned int magic = LittleInt( *(unsigned int *)data );
+	unsigned long magic = LittleInt( *(unsigned long *)data );
 	ddsFileHeader_t	*_header = (ddsFileHeader_t *)(data + 4);
 	int ddspf_dwFlags = LittleInt( _header->ddspf.dwFlags );
 
@@ -1393,9 +1127,8 @@ bool idImage::CheckPrecompressedImage( bool fullLoad ) {
 		return false;
 	}
 
-	// if we don't support color index textures, we must load the full image
-	// should we just expand the 256 color image to 32 bit for upload?
-	if ( ddspf_dwFlags & DDSF_ID_INDEXCOLOR && !glConfig.sharedTexturePaletteAvailable ) {
+	// we don't support color index textures, we must load the full image
+	if ( ddspf_dwFlags & DDSF_ID_INDEXCOLOR ) {
 		R_StaticFree( data );
 		return false;
 	}
@@ -1478,13 +1211,8 @@ void idImage::UploadPrecompressedImage( byte *data, int len ) {
 		externalFormat = GL_BGRA_EXT;
 		internalFormat = GL_RGBA8;
 	} else if ( ( header->ddspf.dwFlags & DDSF_RGB ) && header->ddspf.dwRGBBitCount == 24 ) {
-		if ( header->ddspf.dwFlags & DDSF_ID_INDEXCOLOR ) {
-			externalFormat = GL_COLOR_INDEX;
-			internalFormat = GL_COLOR_INDEX8_EXT;
-		} else {
-			externalFormat = GL_BGR_EXT;
-			internalFormat = GL_RGB8;
-		}
+		externalFormat = GL_BGR_EXT;
+		internalFormat = GL_RGB8;
 	} else if ( header->ddspf.dwRGBBitCount == 8 ) {
 		externalFormat = GL_ALPHA;
 		internalFormat = GL_ALPHA8;
@@ -1613,19 +1341,7 @@ void	idImage::ActuallyLoadImage( bool checkForPrecompressed, bool fromBackEnd )
 			MakeDefault();
 			return;
 		}
-/*
-		// swap the red and alpha for rxgb support
-		// do this even on tga normal maps so we only have to use
-		// one fragment program
-		// if the image is precompressed ( either in palletized mode or true rxgb mode )
-		// then it is loaded above and the swap never happens here
-		if ( depth == TD_BUMP && globalImages->image_useNormalCompression.GetInteger() != 1 ) {
-			for ( int i = 0; i < width * height * 4; i += 4 ) {
-				pic[ i + 3 ] = pic[ i ];
-				pic[ i ] = 0;
-			}
-		}
-*/
+
 		// build a hash for checking duplicate image files
 		// NOTE: takes about 10% of image load times (SD)
 		// may not be strictly necessary, but some code uses it, so let's leave it in
@@ -1651,14 +1367,16 @@ PurgeImage
 */
 void idImage::PurgeImage() {
 	if ( texnum != TEXTURE_NOT_LOADED ) {
-		qglDeleteTextures( 1, &texnum );	// this should be the ONLY place it is ever called!
+		// sometimes is NULL when exiting with an error
+		if ( qglDeleteTextures ) {
+			qglDeleteTextures( 1, &texnum );	// this should be the ONLY place it is ever called!
+		}
 		texnum = TEXTURE_NOT_LOADED;
 	}
 
 	// clear all the current binding caches, so the next bind will do a real one
 	for ( int i = 0 ; i < MAX_MULTITEXTURE_UNITS ; i++ ) {
 		backEnd.glState.tmu[i].current2DMap = -1;
-		backEnd.glState.tmu[i].current3DMap = -1;
 		backEnd.glState.tmu[i].currentCubeMap = -1;
 	}
 }
@@ -1667,7 +1385,7 @@ void idImage::PurgeImage() {
 ==============
 Bind
 
-Automatically enables 2D mapping, cube mapping, or 3D texturing if needed
+Automatically enables 2D mapping or cube mapping if needed
 ==============
 */
 void idImage::Bind() {
@@ -1713,17 +1431,13 @@ void idImage::Bind() {
 	// enable or disable apropriate texture modes
 	if ( tmu->textureType != type && ( backEnd.glState.currenttmu <	glConfig.maxTextureUnits ) ) {
 		if ( tmu->textureType == TT_CUBIC ) {
-			qglDisable( GL_TEXTURE_CUBE_MAP_EXT );
-		} else if ( tmu->textureType == TT_3D ) {
-			qglDisable( GL_TEXTURE_3D );
+			qglDisable( GL_TEXTURE_CUBE_MAP );
 		} else if ( tmu->textureType == TT_2D ) {
 			qglDisable( GL_TEXTURE_2D );
 		}
 
 		if ( type == TT_CUBIC ) {
-			qglEnable( GL_TEXTURE_CUBE_MAP_EXT );
-		} else if ( type == TT_3D ) {
-			qglEnable( GL_TEXTURE_3D );
+			qglEnable( GL_TEXTURE_CUBE_MAP );
 		} else if ( type == TT_2D ) {
 			qglEnable( GL_TEXTURE_2D );
 		}
@@ -1739,12 +1453,7 @@ void idImage::Bind() {
 	} else if ( type == TT_CUBIC ) {
 		if ( tmu->currentCubeMap != texnum ) {
 			tmu->currentCubeMap = texnum;
-			qglBindTexture( GL_TEXTURE_CUBE_MAP_EXT, texnum );
-		}
-	} else if ( type == TT_3D ) {
-		if ( tmu->current3DMap != texnum ) {
-			tmu->current3DMap = texnum;
-			qglBindTexture( GL_TEXTURE_3D, texnum );
+			qglBindTexture( GL_TEXTURE_CUBE_MAP, texnum );
 		}
 	}
 
@@ -1803,12 +1512,8 @@ void idImage::BindFragment() {
 	// bind the texture
 	if ( type == TT_2D ) {
 		qglBindTexture( GL_TEXTURE_2D, texnum );
-	} else if ( type == TT_RECT ) {
-		qglBindTexture( GL_TEXTURE_RECTANGLE_NV, texnum );
 	} else if ( type == TT_CUBIC ) {
-		qglBindTexture( GL_TEXTURE_CUBE_MAP_EXT, texnum );
-	} else if ( type == TT_3D ) {
-		qglBindTexture( GL_TEXTURE_3D, texnum );
+		qglBindTexture( GL_TEXTURE_CUBE_MAP, texnum );
 	}
 }
 
@@ -1952,22 +1657,22 @@ void idImage::UploadScratch( const byte *data, int cols, int rows ) {
 
 			// upload the base level
 			for ( i = 0 ; i < 6 ; i++ ) {
-				qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, GL_RGB8, cols, rows, 0,
+				qglTexImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, GL_RGB8, cols, rows, 0, 
 					GL_RGBA, GL_UNSIGNED_BYTE, data + cols*rows*4*i );
 			}
 		} else {
 			// otherwise, just subimage upload it so that drivers can tell we are going to be changing
 			// it and don't try and do a texture compression
 			for ( i = 0 ; i < 6 ; i++ ) {
-				qglTexSubImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, 0, 0, cols, rows,
+				qglTexSubImage2D( GL_TEXTURE_CUBE_MAP_POSITIVE_X_EXT+i, 0, 0, 0, cols, rows, 
 					GL_RGBA, GL_UNSIGNED_BYTE, data + cols*rows*4*i );
 			}
 		}
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );
 		// no other clamp mode makes sense
-		qglTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
-		qglTexParameteri(GL_TEXTURE_CUBE_MAP_EXT, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+		qglTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
+		qglTexParameteri( GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
 	} else {
 		// otherwise, it is a 2D image
 		if ( type != TT_2D ) {
@@ -1994,10 +1699,10 @@ void idImage::UploadScratch( const byte *data, int cols, int rows ) {
 		// a smear across the entire polygon
 #if 1
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT );	
 #else
 		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE );
-		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );
+		qglTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE );	
 #endif
 	}
 }
@@ -2024,9 +1729,6 @@ int idImage::StorageSize() const {
 	case TT_2D:
 		baseSize = uploadWidth*uploadHeight;
 		break;
-	case TT_3D:
-		baseSize = uploadWidth*uploadHeight*uploadDepth;
-		break;
 	case TT_CUBIC:
 		baseSize = 6 * uploadWidth*uploadHeight;
 		break;
@@ -2060,15 +1762,9 @@ void idImage::Print() const {
 	case TT_2D:
 		common->Printf( " " );
 		break;
-	case TT_3D:
-		common->Printf( "3" );
-		break;
 	case TT_CUBIC:
 		common->Printf( "C" );
 		break;
-	case TT_RECT:
-		common->Printf( "R" );
-		break;
 	default:
 		common->Printf( "<BAD TYPE:%i>", type );
 		break;
@@ -2136,12 +1832,6 @@ void idImage::Print() const {
 	case GL_RGB5:
 		common->Printf( "RGB5  " );
 		break;
-	case GL_COLOR_INDEX8_EXT:
-		common->Printf( "CI8   " );
-		break;
-	case GL_COLOR_INDEX:
-		common->Printf( "CI    " );
-		break;
 	case GL_COMPRESSED_RGB_ARB:
 		common->Printf( "RGBC  " );
 		break;
@@ -2173,7 +1863,7 @@ void idImage::Print() const {
 		common->Printf( "<BAD REPEAT:%i>", repeat );
 		break;
 	}
-
+	
 	common->Printf( "%4ik ", StorageSize() / 1024 );
 
 	common->Printf( " %s\n", imgName.c_str() );
diff --git a/neo/renderer/Interaction.cpp b/neo/renderer/Interaction.cpp
index 6f215d8..6355649 100644
--- a/neo/renderer/Interaction.cpp
+++ b/neo/renderer/Interaction.cpp
@@ -1131,20 +1131,7 @@ void idInteraction::AddActiveInteraction( void ) {
 					// touch the ambient surface so it won't get purged
 					vertexCache.Touch( lightTris->ambientCache );
 
-					// regenerate the lighting cache (for non-vertex program cards) if it has been purged
-					if ( !lightTris->lightingCache ) {
-						if ( !R_CreateLightingCache( entityDef, lightDef, lightTris ) ) {
-							// skip if we are out of vertex memory
-							continue;
-						}
-					}
-					// touch the light surface so it won't get purged
-					// (vertex program cards won't have a light cache at all)
-					if ( lightTris->lightingCache ) {
-						vertexCache.Touch( lightTris->lightingCache );
-					}
-
-					if ( !lightTris->indexCache && r_useIndexBuffers.GetBool() ) {
+					if ( !lightTris->indexCache ) {
 						vertexCache.Alloc( lightTris->indexes, lightTris->numIndexes * sizeof( lightTris->indexes[0] ), &lightTris->indexCache, true );
 					}
 					if ( lightTris->indexCache ) {
@@ -1226,7 +1213,7 @@ void idInteraction::AddActiveInteraction( void ) {
 			// touch the shadow surface so it won't get purged
 			vertexCache.Touch( shadowTris->shadowCache );
 
-			if ( !shadowTris->indexCache && r_useIndexBuffers.GetBool() ) {
+			if ( !shadowTris->indexCache ) {
 				vertexCache.Alloc( shadowTris->indexes, shadowTris->numIndexes * sizeof( shadowTris->indexes[0] ), &shadowTris->indexCache, true );
 				vertexCache.Touch( shadowTris->indexCache );
 			}
diff --git a/neo/renderer/RenderLog.cpp b/neo/renderer/RenderLog.cpp
new file mode 100644
index 0000000..d98a28f
--- /dev/null
+++ b/neo/renderer/RenderLog.cpp
@@ -0,0 +1,437 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "sys/platform.h"
+
+#include "renderer/tr_local.h"
+
+/*
+================================================================================================
+Contains the RenderLog implementation.
+
+TODO:	Emit statistics to the logfile at the end of views and frames.
+================================================================================================
+*/
+
+idCVar r_logLevel( "r_logLevel", "2", CVAR_INTEGER, "1 = blocks only, 2 = everything", 1, 2 );
+
+static const int LOG_LEVEL_BLOCKS_ONLY	= 1;
+static const int LOG_LEVEL_EVERYTHING	= 2;
+
+const char * renderLogMainBlockLabels[] = {
+	ASSERT_ENUM_STRING( MRB_NONE,							0 ),
+	ASSERT_ENUM_STRING( MRB_BEGIN_DRAWING_VIEW,				1 ),
+	ASSERT_ENUM_STRING( MRB_FILL_DEPTH_BUFFER,				2 ),
+	ASSERT_ENUM_STRING( MRB_DRAW_INTERACTIONS,				3 ),
+	ASSERT_ENUM_STRING( MRB_DRAW_SHADER_PASSES,				4 ),
+	ASSERT_ENUM_STRING( MRB_FOG_ALL_LIGHTS,					5 ),
+	ASSERT_ENUM_STRING( MRB_DRAW_SHADER_PASSES_POST,		6 ),
+	ASSERT_ENUM_STRING( MRB_DRAW_DEBUG_TOOLS,				7 ),
+	ASSERT_ENUM_STRING( MRB_CAPTURE_COLORBUFFER,			8 ),
+	ASSERT_ENUM_STRING( MRB_POSTPROCESS,					9 ),
+	ASSERT_ENUM_STRING( MRB_GPU_SYNC,						10 ),
+	ASSERT_ENUM_STRING( MRB_END_FRAME,						11 ),
+	ASSERT_ENUM_STRING( MRB_TOTAL,							12 ),
+	ASSERT_ENUM_STRING( MRB_MAX,							13 )
+};
+
+unsigned int Sys_Milliseconds( void );
+/*
+================================================================================================
+
+PIX events on all platforms
+
+================================================================================================
+*/
+
+
+/*
+================================================
+pixEvent_t 
+================================================
+*/
+struct pixEvent_t {
+	char		name[256];
+	u_int64_t	cpuTime;
+	u_int64_t	gpuTime;
+};
+
+idCVar r_pix( "r_pix", "0", CVAR_INTEGER, "print GPU/CPU event timing" );
+
+static const int	MAX_PIX_EVENTS = 256;
+// defer allocation of this until needed, so we don't waste lots of memory
+pixEvent_t *		pixEvents;	// [MAX_PIX_EVENTS]
+int					numPixEvents;
+int					numPixLevels;
+static GLuint		timeQueryIds[MAX_PIX_EVENTS];
+
+/*
+========================
+PC_BeginNamedEvent
+
+FIXME: this is not thread safe on the PC
+========================
+*/
+void PC_BeginNamedEvent( const char *szName, ... ) {
+#if 0
+	if ( !r_pix.GetBool() ) {
+		return;
+	}
+	if ( !pixEvents ) {
+		// lazy allocation to not waste memory
+		pixEvents = (pixEvent_t *)Mem_ClearedAlloc( sizeof( *pixEvents ) * MAX_PIX_EVENTS );
+	}
+	if ( numPixEvents >= MAX_PIX_EVENTS ) {
+		common->FatalError( "PC_BeginNamedEvent: event overflow" );
+	}
+	if ( ++numPixLevels > 1 ) {
+		return;	// only get top level timing information
+	}
+	if ( !qglGetQueryObjectui64vEXT ) {
+		return;
+	}
+
+	GL_CheckErrors();
+	if ( timeQueryIds[0] == 0 ) {
+		qglGenQueriesARB( MAX_PIX_EVENTS, timeQueryIds );
+	}
+	qglFinish();
+	qglBeginQueryARB( GL_TIME_ELAPSED_EXT, timeQueryIds[numPixEvents] );
+	GL_CheckErrors();
+
+	pixEvent_t *ev = &pixEvents[numPixEvents++];
+	strncpy( ev->name, szName, sizeof( ev->name ) - 1 );
+	ev->cpuTime = Sys_Milliseconds() * 1000;
+#endif
+}
+
+/*
+========================
+PC_EndNamedEvent
+========================
+*/
+void PC_EndNamedEvent() {
+#if 0
+	if ( !r_pix.GetBool() ) {
+		return;
+	}
+	if ( numPixLevels <= 0 ) {
+		common->FatalError( "PC_EndNamedEvent: level underflow" );
+	}
+	if ( --numPixLevels > 0 ) {
+		// only do timing on top level events
+		return;
+	}
+	if ( !qglGetQueryObjectui64vEXT ) {
+		return;
+	}
+
+	pixEvent_t *ev = &pixEvents[numPixEvents-1];
+	ev->cpuTime = ( Sys_Milliseconds() * 1000 ) - ev->cpuTime;
+
+	GL_CheckErrors();
+	qglEndQueryARB( GL_TIME_ELAPSED_EXT );
+	GL_CheckErrors();
+#endif
+}
+
+/*
+========================
+PC_EndFrame
+========================
+*/
+void PC_EndFrame() {
+#if 0
+	if ( !r_pix.GetBool() ) {
+		return;
+	}
+
+	int_64_t totalGPU = 0;
+	int_64_t totalCPU = 0;
+
+	common->Printf( "----- GPU Events -----\n" );
+	for ( int i = 0 ; i < numPixEvents ; i++ ) {
+		pixEvent_t *ev = &pixEvents[i];
+
+		int_64_t gpuTime = 0;
+		qglGetQueryObjectui64vEXT( timeQueryIds[i], GL_QUERY_RESULT, (GLuint64EXT *)&gpuTime );
+		ev->gpuTime = gpuTime;
+
+		common->Printf( "%2d: %1.2f (GPU) %1.3f (CPU) = %s\n", i, ev->gpuTime / 1000000.0f, ev->cpuTime / 1000.0f, ev->name );
+		totalGPU += ev->gpuTime;
+		totalCPU += ev->cpuTime;
+	}
+	common->Printf( "%2d: %1.2f (GPU) %1.3f (CPU) = total\n", numPixEvents, totalGPU / 1000000.0f, totalCPU / 1000.0f );
+	memset( pixEvents, 0, numPixLevels * sizeof( pixEvents[0] ) );
+	
+	numPixEvents = 0;
+	numPixLevels = 0;
+#endif
+}
+
+
+/*
+================================================================================================
+
+idRenderLog
+
+================================================================================================
+*/
+
+idRenderLog	renderLog;
+
+#if !defined( STUB_RENDER_LOG )
+
+/*
+========================
+idRenderLog::idRenderLog
+========================
+*/
+idRenderLog::idRenderLog() {
+	activeLevel = 0;
+	indentString[0] = '\0';
+	indentLevel = 0;
+	logFile = NULL;
+
+	frameStartTime = 0;
+	closeBlockTime = 0;
+	logLevel = 0;
+}
+
+/*
+========================
+idRenderLog::StartFrame
+========================
+*/
+void idRenderLog::StartFrame() {
+	if ( r_logFile.GetInteger() == 0 ) {
+		return;
+	}
+
+	// open a new logfile
+	indentLevel = 0;
+	indentString[0] = '\0';
+	activeLevel = r_logLevel.GetInteger();
+
+	struct tm		*newtime;
+	time_t			aclock;
+
+	char qpath[128];
+	sprintf( qpath, "renderlogPC_%04i.txt", r_logFile.GetInteger() );
+
+	common->SetRefreshOnPrint( false );	// problems are caused if this print causes a refresh...
+
+	if ( logFile != NULL ) {
+		fileSystem->CloseFile( logFile );
+		logFile = NULL;
+	}
+
+	logFile = fileSystem->OpenFileWrite( qpath );
+	if ( logFile == NULL ) {
+		common->Warning( "Failed to open logfile %s", qpath );
+		return;
+	}
+	common->Printf( "Opened logfile %s\n", qpath );
+
+	// write the time out to the top of the file
+	time( &aclock );
+	newtime = localtime( &aclock );
+	const char *str = asctime( newtime );
+	logFile->Printf( "// %s", str );
+	logFile->Printf( "// %s\n\n", com_version.GetString() );
+
+	frameStartTime = Sys_Milliseconds() * 1000;
+	closeBlockTime = frameStartTime;
+	OpenBlock( "Frame" );
+}
+
+/*
+========================
+idRenderLog::EndFrame
+========================
+*/
+void idRenderLog::EndFrame() {
+	PC_EndFrame();
+
+	if ( logFile != NULL ) {
+		if ( r_logFile.GetInteger() == 1 ) {
+			Close();
+		}
+		// log is open, so decrement r_logFile and stop if it is zero
+		r_logFile.SetInteger( r_logFile.GetInteger() - 1 );
+		common->Printf( "Frame logged.\n" );
+		return;
+	}
+}
+
+/*
+========================
+idRenderLog::Close
+========================
+*/
+void idRenderLog::Close() {
+	if ( logFile != NULL ) {
+		CloseBlock();
+		common->Printf( "Closing logfile\n" );
+		fileSystem->CloseFile( logFile );
+		logFile = NULL;
+		activeLevel = 0;
+	}
+}
+
+/*
+========================
+idRenderLog::OpenMainBlock
+========================
+*/
+void idRenderLog::OpenMainBlock( renderLogMainBlock_t block ) {
+}
+
+/*
+========================
+idRenderLog::CloseMainBlock
+========================
+*/
+void idRenderLog::CloseMainBlock() {
+}
+
+/*
+========================
+idRenderLog::OpenBlock
+========================
+*/
+void idRenderLog::OpenBlock( const char *label ) {
+	// Allow the PIX functionality even when logFile is not running.
+	PC_BeginNamedEvent( label );
+
+	if ( logFile != NULL ) {
+		LogOpenBlock( RENDER_LOG_INDENT_MAIN_BLOCK, label, NULL );
+	}
+}
+
+/*
+========================
+idRenderLog::CloseBlock
+========================
+*/
+void idRenderLog::CloseBlock() {
+	PC_EndNamedEvent();
+
+	if ( logFile != NULL ) {
+		LogCloseBlock( RENDER_LOG_INDENT_MAIN_BLOCK );
+	}
+}
+
+/*
+========================
+idRenderLog::Printf
+========================
+*/
+void idRenderLog::Printf( const char *fmt, ... ) {
+	if ( activeLevel <= LOG_LEVEL_BLOCKS_ONLY ) {
+		return;
+	}
+
+	if ( logFile == NULL ) {
+		return;
+	}
+
+	va_list marker;
+	logFile->Printf( "%s", indentString );
+	va_start( marker, fmt );
+	logFile->VPrintf( fmt, marker );
+	va_end( marker );
+//	logFile->Flush();		this makes it take waaaay too long
+}
+
+/*
+========================
+idRenderLog::LogOpenBlock
+========================
+*/
+void idRenderLog::LogOpenBlock( renderLogIndentLabel_t label, const char * fmt, va_list args ) {
+
+	u_int64_t now = Sys_Milliseconds() * 1000;
+
+	if ( logFile != NULL ) {
+		if ( now - closeBlockTime >= 1000 ) {
+			logFile->Printf( "%s%1.1f msec gap from last closeblock\n", indentString, ( now - closeBlockTime ) * ( 1.0f / 1000.0f ) );
+		}
+		logFile->Printf( "%s", indentString );
+		logFile->VPrintf( fmt, args );
+		logFile->Printf( " {\n" );
+	}
+
+	Indent( label );
+
+	if ( logLevel >= MAX_LOG_LEVELS ) {
+		common->Warning( "logLevel %d >= MAX_LOG_LEVELS", logLevel );
+	}
+
+
+	logLevel++;
+}
+
+/*
+========================
+idRenderLog::LogCloseBlock
+========================
+*/
+void idRenderLog::LogCloseBlock( renderLogIndentLabel_t label ) {
+	closeBlockTime = Sys_Milliseconds() * 1000;
+
+	assert( logLevel > 0 );
+	logLevel--;
+
+	Outdent( label );
+
+	if ( logFile != NULL ) {
+	}
+}
+
+#else	// !STUB_RENDER_LOG
+
+/*
+========================
+idRenderLog::OpenBlock
+========================
+*/
+void idRenderLog::OpenBlock( const char *label ) {
+	PC_BeginNamedEvent( label );
+}
+
+/*
+========================
+idRenderLog::CloseBlock
+========================
+*/
+void idRenderLog::CloseBlock() {
+	PC_EndNamedEvent();
+}
+
+#endif // !STUB_RENDER_LOG
diff --git a/neo/renderer/RenderLog.h b/neo/renderer/RenderLog.h
new file mode 100644
index 0000000..fbdcc81
--- /dev/null
+++ b/neo/renderer/RenderLog.h
@@ -0,0 +1,185 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+#ifndef __RENDERLOG_H__
+#define __RENDERLOG_H__
+
+/*
+================================================================================================
+Contains the RenderLog declaration.
+================================================================================================
+*/
+
+#if defined(ID_RETAIL)
+//#define STUB_RENDER_LOG
+#endif
+
+enum renderLogMainBlock_t {
+	MRB_NONE,
+	MRB_BEGIN_DRAWING_VIEW,
+	MRB_FILL_DEPTH_BUFFER,
+	MRB_DRAW_INTERACTIONS,
+	MRB_DRAW_SHADER_PASSES,
+	MRB_FOG_ALL_LIGHTS,
+	MRB_DRAW_SHADER_PASSES_POST,
+	MRB_DRAW_DEBUG_TOOLS,
+	MRB_CAPTURE_COLORBUFFER,
+	MRB_POSTPROCESS,
+	MRB_GPU_SYNC,
+	MRB_END_FRAME,
+	MRB_TOTAL,
+	MRB_MAX
+};
+
+// these are used to make sure each Indent() is properly paired with an Outdent()
+enum renderLogIndentLabel_t {
+	RENDER_LOG_INDENT_DEFAULT,
+	RENDER_LOG_INDENT_MAIN_BLOCK,
+	RENDER_LOG_INDENT_BLOCK,
+	RENDER_LOG_INDENT_TEST
+};
+
+// using this macro avoids printf parameter overhead if the renderlog isn't active
+#define RENDERLOG_PRINTF( ... ) if ( renderLog.activeLevel ) renderLog.Printf( __VA_ARGS__ );
+
+#if !defined( STUB_RENDER_LOG )
+
+/*
+================================================
+idRenderLog contains block-based performance-tuning information. It combines 
+logfile, and msec accumulation code.
+================================================
+*/
+class idRenderLog {
+public:
+				idRenderLog();
+
+	void		StartFrame();
+	void		EndFrame();
+	void		Close();
+	int			Active() { return activeLevel; }	// returns greater than 1 for more detailed logging
+
+	// The label must be a constant string literal and may not point to a temporary.
+	void		OpenMainBlock( renderLogMainBlock_t block );
+	void		CloseMainBlock();
+
+	void		OpenBlock( const char * label );
+	void		CloseBlock();
+
+	void		Indent( renderLogIndentLabel_t label = RENDER_LOG_INDENT_DEFAULT );
+	void		Outdent( renderLogIndentLabel_t label = RENDER_LOG_INDENT_DEFAULT );
+
+	void		Printf( const char *fmt, ... );
+
+	static const int		MAX_LOG_LEVELS = 20;
+
+	int						activeLevel;
+	renderLogIndentLabel_t	indentLabel[MAX_LOG_LEVELS];
+	char					indentString[MAX_LOG_LEVELS * 4];
+	int						indentLevel;
+	const char *			lastLabel;
+	renderLogMainBlock_t	lastMainBlock;
+	idFile*					logFile;
+
+	struct logStats_t {
+		u_int64_t	startTiming;
+		int		startDraws;
+		int		startIndexes;
+	};
+
+	u_int64_t					frameStartTime;
+	u_int64_t					closeBlockTime;
+	logStats_t				logStats[MAX_LOG_LEVELS];
+	int						logLevel;
+
+	void					LogOpenBlock( renderLogIndentLabel_t label, const char * fmt, va_list args );
+	void					LogCloseBlock( renderLogIndentLabel_t label );
+};
+
+/*
+========================
+idRenderLog::Indent
+========================
+*/
+ID_INLINE void idRenderLog::Indent( renderLogIndentLabel_t label ) {
+	if ( logFile != NULL ) {
+		indentLabel[indentLevel] = label;
+		indentLevel++;
+		for ( int i = 4; i > 0; i-- ) {
+			indentString[indentLevel * 4 - i] = ' ';
+		}
+		indentString[indentLevel * 4] = '\0';
+	}
+}
+
+/*
+========================
+idRenderLog::Outdent
+========================
+*/
+ID_INLINE void idRenderLog::Outdent( renderLogIndentLabel_t label ) {
+	if ( logFile != NULL && indentLevel > 0 ) {
+		indentLevel--;
+		assert( indentLabel[indentLevel] == label );	// indent and outdent out of sync ?
+		indentString[indentLevel * 4] = '\0';
+	}
+}
+
+#else	// !STUB_RENDER_LOG
+
+/*
+================================================
+idRenderLog stubbed version for the SPUs and high
+performance rendering in retail builds.
+================================================
+*/
+class idRenderLog {
+public:
+				idRenderLog() {}
+
+	void		StartFrame() {}
+	void		EndFrame() {}
+	void		Close() {}
+	int			Active() { return 0; }
+
+	void		OpenBlock( const char * label );
+	void		CloseBlock();
+	void		OpenMainBlock( renderLogMainBlock_t block ){}
+	void		CloseMainBlock(){}
+	void		Indent( renderLogIndentLabel_t label = RENDER_LOG_INDENT_DEFAULT ) {}
+	void		Outdent( renderLogIndentLabel_t label = RENDER_LOG_INDENT_DEFAULT ) {}
+
+	void		Printf( const char *fmt, ... ) {}
+
+	int			activeLevel;
+};
+
+#endif	// !STUB_RENDER_LOG
+
+extern idRenderLog renderLog;
+
+#endif // !__RENDERLOG_H__
diff --git a/neo/renderer/RenderProgs.cpp b/neo/renderer/RenderProgs.cpp
new file mode 100644
index 0000000..91567b5
--- /dev/null
+++ b/neo/renderer/RenderProgs.cpp
@@ -0,0 +1,298 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "sys/platform.h"
+
+#include "renderer/tr_local.h"
+
+
+idRenderProgManager renderProgManager;
+
+/*
+================================================================================================
+idRenderProgManager::idRenderProgManager()
+================================================================================================
+*/
+idRenderProgManager::idRenderProgManager() {
+}
+
+/*
+================================================================================================
+idRenderProgManager::~idRenderProgManager()
+================================================================================================
+*/
+idRenderProgManager::~idRenderProgManager() {
+}
+
+/*
+================================================================================================
+R_ReloadShaders
+================================================================================================
+*/
+static void R_ReloadShaders( const idCmdArgs &args ) {	
+	renderProgManager.KillAllShaders();
+	renderProgManager.LoadAllShaders();
+}
+
+/*
+================================================================================================
+idRenderProgManager::Init()
+================================================================================================
+*/
+void idRenderProgManager::Init() {
+	common->Printf( "----- Initializing Render Shaders -----\n" );
+
+	for ( int i = 0; i < MAX_BUILTINS; i++ ) {
+		builtinShaders[i] = -1;
+	}
+	struct builtinShaders_t {
+		int index;
+		const char * name;
+	} builtins[] = {
+//		{ BUILTIN_GUI, "gui.vfp" },
+		{ BUILTIN_COLOR, "color.vfp" },
+//		{ BUILTIN_SIMPLESHADE, "simpleshade.vfp" },
+		{ BUILTIN_TEXTURED, "texture.vfp" },
+		{ BUILTIN_TEXTURE_VERTEXCOLOR, "texture_color.vfp" },
+		{ BUILTIN_TEXTURE_TEXGEN_VERTEXCOLOR, "texture_color_texgen.vfp" },
+		{ BUILTIN_INTERACTION, "interaction.vfp" },
+		{ BUILTIN_INTERACTION_AMBIENT, "interactionAmbient.vfp" },
+//		{ BUILTIN_ENVIRONMENT, "environment.vfp" },
+//		{ BUILTIN_BUMPY_ENVIRONMENT, "bumpyEnvironment.vfp" },
+
+		{ BUILTIN_DEPTH, "depth.vfp" },
+		{ BUILTIN_SHADOW_DEBUG, "shadowDebug.vfp" },
+
+/*
+		{ BUILTIN_BLENDLIGHT, "blendlight.vfp" },
+		{ BUILTIN_FOG, "fog.vfp" },
+		{ BUILTIN_SKYBOX, "skybox.vfp" },
+		{ BUILTIN_WOBBLESKY, "wobblesky.vfp" },
+		{ BUILTIN_POSTPROCESS, "postprocess.vfp" },
+		{ BUILTIN_STEREO_DEGHOST, "stereoDeGhost.vfp" },
+		{ BUILTIN_STEREO_WARP, "stereoWarp.vfp" },
+		{ BUILTIN_STEREO_INTERLACE, "stereoInterlace.vfp" },
+		{ BUILTIN_MOTION_BLUR, "motionBlur.vfp" },
+*/
+	};
+	int numBuiltins = sizeof( builtins ) / sizeof( builtins[0] );
+	vertexShaders.SetNum( numBuiltins );
+	fragmentShaders.SetNum( numBuiltins );
+	glslPrograms.SetNum( numBuiltins );
+
+	for ( int i = 0; i < numBuiltins; i++ ) {
+		vertexShaders[i].name = builtins[i].name;
+		fragmentShaders[i].name = builtins[i].name;
+		builtinShaders[builtins[i].index] = i;
+		LoadVertexShader( i );
+		LoadFragmentShader( i );
+		LoadGLSLProgram( i, i, i );
+	}
+
+	// Special case handling for fastZ shaders
+	builtinShaders[BUILTIN_SHADOW] = FindVertexShader( "shadow.vp" );
+	FindGLSLProgram( "shadow.vp", builtinShaders[BUILTIN_SHADOW], -1 );
+
+	glslUniforms.SetNum( RENDERPARM_USER + MAX_GLSL_USER_PARMS );
+
+	cmdSystem->AddCommand( "reloadShaders", R_ReloadShaders, CMD_FL_RENDERER, "reloads shaders" );
+}
+
+/*
+================================================================================================
+idRenderProgManager::LoadAllShaders()
+================================================================================================
+*/
+void idRenderProgManager::LoadAllShaders() {
+	for ( int i = 0; i < vertexShaders.Num(); i++ ) {
+		LoadVertexShader( i );
+	}
+	for ( int i = 0; i < fragmentShaders.Num(); i++ ) {
+		LoadFragmentShader( i );
+	}
+
+	for ( int i = 0; i < glslPrograms.Num(); ++i ) {
+		LoadGLSLProgram( i, glslPrograms[i].vertexShaderIndex, glslPrograms[i].fragmentShaderIndex );
+	}
+}
+
+/*
+================================================================================================
+idRenderProgManager::KillAllShaders()
+================================================================================================
+*/
+void idRenderProgManager::KillAllShaders() {
+	Unbind();
+	for ( int i = 0; i < vertexShaders.Num(); i++ ) {
+		if ( vertexShaders[i].progId != INVALID_PROGID ) {
+			qglDeleteShader( vertexShaders[i].progId );
+			vertexShaders[i].progId = INVALID_PROGID;
+		}
+	}
+	for ( int i = 0; i < fragmentShaders.Num(); i++ ) {
+		if ( fragmentShaders[i].progId != INVALID_PROGID ) {
+			qglDeleteShader( fragmentShaders[i].progId );
+			fragmentShaders[i].progId = INVALID_PROGID;
+		}
+	}
+	for ( int i = 0; i < glslPrograms.Num(); ++i ) {
+		if ( glslPrograms[i].progId != INVALID_PROGID ) {
+			qglDeleteProgram( glslPrograms[i].progId );
+			glslPrograms[i].progId = INVALID_PROGID;
+		}
+	}
+}
+
+/*
+================================================================================================
+idRenderProgManager::Shutdown()
+================================================================================================
+*/
+void idRenderProgManager::Shutdown() {
+	KillAllShaders();
+}
+
+/*
+================================================================================================
+idRenderProgManager::FindVertexShader
+================================================================================================
+*/
+int idRenderProgManager::FindVertexShader( const char * name ) {
+	for ( int i = 0; i < vertexShaders.Num(); i++ ) {
+		if ( vertexShaders[i].name.Icmp( name ) == 0 ) {
+			LoadVertexShader( i );
+			return i;
+		}
+	}
+	vertexShader_t shader;
+	shader.name = name;
+	int index = vertexShaders.Append( shader );
+	LoadVertexShader( index );
+	currentVertexShader = index;
+
+	return index;
+}
+
+/*
+================================================================================================
+idRenderProgManager::FindFragmentShader
+================================================================================================
+*/
+int idRenderProgManager::FindFragmentShader( const char * name ) {
+	for ( int i = 0; i < fragmentShaders.Num(); i++ ) {
+		if ( fragmentShaders[i].name.Icmp( name ) == 0 ) {
+			LoadFragmentShader( i );
+			return i;
+		}
+	}
+	fragmentShader_t shader;
+	shader.name = name;
+	int index = fragmentShaders.Append( shader );
+	LoadFragmentShader( index );
+	currentFragmentShader = index;
+	return index;
+}
+
+
+
+
+/*
+================================================================================================
+idRenderProgManager::LoadVertexShader
+================================================================================================
+*/
+void idRenderProgManager::LoadVertexShader( int index ) {
+	if ( vertexShaders[index].progId != INVALID_PROGID ) {
+		return; // Already loaded
+	}
+	vertexShaders[index].progId = ( GLuint ) LoadGLSLShader( GL_VERTEX_SHADER, vertexShaders[index].name, vertexShaders[index].uniforms );
+}
+
+/*
+================================================================================================
+idRenderProgManager::LoadFragmentShader
+================================================================================================
+*/
+void idRenderProgManager::LoadFragmentShader( int index ) {
+	if ( fragmentShaders[index].progId != INVALID_PROGID ) {
+		return; // Already loaded
+	}
+	fragmentShaders[index].progId = ( GLuint ) LoadGLSLShader( GL_FRAGMENT_SHADER, fragmentShaders[index].name, fragmentShaders[index].uniforms );
+}
+
+/*
+================================================================================================
+idRenderProgManager::BindShader
+================================================================================================
+*/
+void idRenderProgManager::BindShader( int vIndex, int fIndex ) {
+	if ( currentVertexShader == vIndex && currentFragmentShader == fIndex ) {
+		return;
+	}
+	currentVertexShader = vIndex;
+	currentFragmentShader = fIndex;
+	// vIndex denotes the GLSL program
+	if ( vIndex >= 0 && vIndex < glslPrograms.Num() ) {
+		currentRenderProgram = vIndex;
+		RENDERLOG_PRINTF( "Binding GLSL Program %s\n", glslPrograms[vIndex].name.c_str() );
+		qglUseProgram( glslPrograms[vIndex].progId );
+	}
+}
+
+/*
+================================================================================================
+idRenderProgManager::Unbind
+================================================================================================
+*/
+void idRenderProgManager::Unbind() {
+	currentVertexShader = -1;
+	currentFragmentShader = -1;
+
+	qglUseProgram( 0 );
+}
+
+/*
+================================================================================================
+idRenderProgManager::SetRenderParms
+================================================================================================
+*/
+void idRenderProgManager::SetRenderParms( renderParm_t rp, const float * value, int num ) {
+	for ( int i = 0; i < num; i++ ) {
+		SetRenderParm( (renderParm_t)(rp + i), value + ( i * 4 ) );
+	}
+}
+
+/*
+================================================================================================
+idRenderProgManager::SetRenderParm
+================================================================================================
+*/
+void idRenderProgManager::SetRenderParm( renderParm_t rp, const float * value ) {
+	SetUniformValue( rp, value );
+}
+
diff --git a/neo/renderer/RenderProgs.h b/neo/renderer/RenderProgs.h
new file mode 100644
index 0000000..5b72ccb
--- /dev/null
+++ b/neo/renderer/RenderProgs.h
@@ -0,0 +1,271 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+#ifndef __RENDERPROGS_H__
+#define __RENDERPROGS_H__
+
+#include "idlib/containers/StaticList.h"
+
+static const int PC_ATTRIB_INDEX_VERTEX		= 0;
+static const int PC_ATTRIB_INDEX_COLOR		= 3;
+static const int PC_ATTRIB_INDEX_ST			= 8;
+static const int PC_ATTRIB_INDEX_TANGENT	= 9;
+static const int PC_ATTRIB_INDEX_BITANGENT	= 10;
+static const int PC_ATTRIB_INDEX_NORMAL		= 11;
+
+// This enum list corresponds to the global constant register indecies as defined in global.inc for all
+// shaders.  We used a shared pool to keeps things simple.  If something changes here then it also
+// needs to change in global.inc and vice versa
+enum renderParm_t {
+	// For backwards compatibility, do not change the order of the first 17 items
+	RENDERPARM_SCREENCORRECTIONFACTOR = 0,
+	RENDERPARM_WINDOWCOORD,
+	RENDERPARM_DIFFUSEMODIFIER,
+	RENDERPARM_SPECULARMODIFIER,
+
+	RENDERPARM_LOCALLIGHTORIGIN,
+	RENDERPARM_LOCALVIEWORIGIN,
+
+	RENDERPARM_LIGHTPROJECTION_S,
+	RENDERPARM_LIGHTPROJECTION_T,
+	RENDERPARM_LIGHTPROJECTION_Q,
+	RENDERPARM_LIGHTFALLOFF_S,
+
+	RENDERPARM_BUMPMATRIX_S,
+	RENDERPARM_BUMPMATRIX_T,
+
+	RENDERPARM_DIFFUSEMATRIX_S,
+	RENDERPARM_DIFFUSEMATRIX_T,
+
+	RENDERPARM_SPECULARMATRIX_S,
+	RENDERPARM_SPECULARMATRIX_T,
+
+	RENDERPARM_VERTEXCOLOR_MODULATE,
+	RENDERPARM_VERTEXCOLOR_ADD,
+
+	// The following are new and can be in any order
+	
+	RENDERPARM_COLOR,
+	RENDERPARM_VIEWORIGIN,
+	RENDERPARM_GLOBALEYEPOS,
+
+	RENDERPARM_MVPMATRIX_X,
+	RENDERPARM_MVPMATRIX_Y,
+	RENDERPARM_MVPMATRIX_Z,
+	RENDERPARM_MVPMATRIX_W,
+
+	RENDERPARM_MODELMATRIX_X,
+	RENDERPARM_MODELMATRIX_Y,
+	RENDERPARM_MODELMATRIX_Z,
+	RENDERPARM_MODELMATRIX_W,
+
+	RENDERPARM_PROJMATRIX_X,
+	RENDERPARM_PROJMATRIX_Y,
+	RENDERPARM_PROJMATRIX_Z,
+	RENDERPARM_PROJMATRIX_W,
+
+	RENDERPARM_MODELVIEWMATRIX_X,
+	RENDERPARM_MODELVIEWMATRIX_Y,
+	RENDERPARM_MODELVIEWMATRIX_Z,
+	RENDERPARM_MODELVIEWMATRIX_W,
+
+	RENDERPARM_TEXTUREMATRIX_S,
+	RENDERPARM_TEXTUREMATRIX_T,
+
+	RENDERPARM_TEXGEN_0_S,
+	RENDERPARM_TEXGEN_0_T,
+	RENDERPARM_TEXGEN_0_Q,
+	RENDERPARM_TEXGEN_0_ENABLED,
+
+	RENDERPARM_TEXGEN_1_S,
+	RENDERPARM_TEXGEN_1_T,
+	RENDERPARM_TEXGEN_1_Q,
+	RENDERPARM_TEXGEN_1_ENABLED,
+
+	RENDERPARM_WOBBLESKY_X,
+	RENDERPARM_WOBBLESKY_Y,
+	RENDERPARM_WOBBLESKY_Z,
+
+	RENDERPARM_OVERBRIGHT,
+	RENDERPARM_ENABLE_SKINNING,
+	RENDERPARM_ALPHA_TEST,
+
+	RENDERPARM_TOTAL,
+	RENDERPARM_USER = 128,
+};
+
+
+struct glslUniformLocation_t {
+	int		parmIndex;
+	GLint	uniformIndex;
+};
+
+
+
+/*
+================================================================================================
+idRenderProgManager
+================================================================================================
+*/
+class idRenderProgManager {
+public:
+	idRenderProgManager();
+	virtual ~idRenderProgManager();
+
+	void	Init();
+	void	Shutdown();
+
+	void	SetRenderParm( renderParm_t rp, const float * value );
+	void	SetRenderParms( renderParm_t rp, const float * values, int numValues );
+
+	int		FindVertexShader( const char * name );
+	int		FindFragmentShader( const char * name );
+
+	void	BindShader( int vIndex, int fIndex );
+
+	void	BindShader_GUI( ) { BindShader_Builtin( BUILTIN_GUI ); }
+	void	BindShader_Color( ) { BindShader_Builtin( BUILTIN_COLOR ); }
+	void	BindShader_Texture( ) { BindShader_Builtin( BUILTIN_TEXTURED ); }
+	void	BindShader_TextureVertexColor() { BindShader_Builtin( BUILTIN_TEXTURE_VERTEXCOLOR ); };
+	void	BindShader_TextureTexGenVertexColor() { BindShader_Builtin( BUILTIN_TEXTURE_TEXGEN_VERTEXCOLOR ); };
+	void	BindShader_Interaction()  { BindShader_Builtin( BUILTIN_INTERACTION ); }
+	void	BindShader_InteractionAmbient()  { BindShader_Builtin( BUILTIN_INTERACTION_AMBIENT ); }
+	void	BindShader_SimpleShade() { BindShader_Builtin( BUILTIN_SIMPLESHADE ); }
+	void	BindShader_Environment() { BindShader_Builtin( BUILTIN_ENVIRONMENT ); }
+	void	BindShader_BumpyEnvironment() { BindShader_Builtin( BUILTIN_BUMPY_ENVIRONMENT ); }
+
+	void	BindShader_Depth() { BindShader_Builtin( BUILTIN_DEPTH ); }
+	void	BindShader_Shadow() { BindShader( builtinShaders[BUILTIN_SHADOW], -1 ); }
+	void	BindShader_ShadowDebug() { BindShader_Builtin( BUILTIN_SHADOW_DEBUG ); }
+
+	void	BindShader_BlendLight() { BindShader_Builtin( BUILTIN_BLENDLIGHT ); }
+	void	BindShader_Fog() { BindShader_Builtin( BUILTIN_FOG ); }
+	void	BindShader_SkyBox() { BindShader_Builtin( BUILTIN_SKYBOX ); }
+	void	BindShader_WobbleSky() { BindShader_Builtin( BUILTIN_WOBBLESKY ); }
+	void	BindShader_StereoDeGhost() { BindShader_Builtin( BUILTIN_STEREO_DEGHOST ); }
+	void	BindShader_StereoWarp() { BindShader_Builtin( BUILTIN_STEREO_WARP ); }
+	void	BindShader_StereoInterlace() { BindShader_Builtin( BUILTIN_STEREO_INTERLACE ); }
+	void	BindShader_PostProcess() { BindShader_Builtin( BUILTIN_POSTPROCESS ); }
+	void	BindShader_MotionBlur() { BindShader_Builtin( BUILTIN_MOTION_BLUR); }
+
+	// unbind the currently bound render program
+	void	Unbind();
+
+	// this should only be called via the reload shader console command
+	void	LoadAllShaders();
+	void	KillAllShaders();
+
+	static const int	MAX_GLSL_USER_PARMS = 8;
+	const char*	GetGLSLParmName( int rp ) const;
+	int			GetGLSLCurrentProgram() const { return currentRenderProgram; }
+	void		SetUniformValue( const renderParm_t rp, const float * value );
+	void		CommitUniforms();
+	int			FindGLSLProgram( const char* name, int vIndex, int fIndex );
+	void		ZeroUniforms();
+
+protected:
+	void	LoadVertexShader( int index );
+	void	LoadFragmentShader( int index );
+
+	enum {
+		BUILTIN_GUI,
+		BUILTIN_COLOR,
+		BUILTIN_SIMPLESHADE,
+		BUILTIN_TEXTURED,
+		BUILTIN_TEXTURE_VERTEXCOLOR,
+		BUILTIN_TEXTURE_TEXGEN_VERTEXCOLOR,
+		BUILTIN_INTERACTION,
+		BUILTIN_INTERACTION_AMBIENT,
+		BUILTIN_ENVIRONMENT,
+		BUILTIN_BUMPY_ENVIRONMENT,
+
+		BUILTIN_DEPTH,
+		BUILTIN_SHADOW,
+		BUILTIN_SHADOW_DEBUG,
+
+		BUILTIN_BLENDLIGHT,
+		BUILTIN_FOG,
+		BUILTIN_SKYBOX,
+		BUILTIN_WOBBLESKY,
+		BUILTIN_POSTPROCESS,
+		BUILTIN_STEREO_DEGHOST,
+		BUILTIN_STEREO_WARP,
+		BUILTIN_STEREO_INTERLACE,
+		BUILTIN_MOTION_BLUR,
+
+		MAX_BUILTINS
+	};
+	int builtinShaders[MAX_BUILTINS];
+	void BindShader_Builtin( int i ) { BindShader( builtinShaders[i], builtinShaders[i] ); }
+
+	bool	CompileGLSL( GLenum target, const char * name );
+	GLuint	LoadGLSLShader( GLenum target, const char * name, idList<int> & uniforms );
+	void	LoadGLSLProgram( const int programIndex, const int vertexShaderIndex, const int fragmentShaderIndex );
+
+	static const GLuint INVALID_PROGID = 0xFFFFFFFF;
+
+	struct vertexShader_t {
+					vertexShader_t() : progId( INVALID_PROGID ) {}
+		idStr		name;
+		GLuint		progId;
+		idList<int>	uniforms;
+	};
+	struct fragmentShader_t {
+					fragmentShader_t() : progId( INVALID_PROGID ) {}
+		idStr		name;
+		GLuint		progId;
+		idList<int>	uniforms;
+	};
+
+	struct glslProgram_t {
+		glslProgram_t() :	progId( INVALID_PROGID ),
+							vertexShaderIndex( -1 ),
+							fragmentShaderIndex( -1 ),
+							vertexUniformArray( -1 ),
+							fragmentUniformArray( -1 ) {}
+		idStr		name;
+		GLuint		progId;
+		int			vertexShaderIndex;
+		int			fragmentShaderIndex;
+		GLint		vertexUniformArray;
+		GLint		fragmentUniformArray;
+		idList<glslUniformLocation_t> uniformLocations;
+	};
+	int	currentRenderProgram;
+	idList<glslProgram_t> glslPrograms;
+	idStaticList<idVec4, RENDERPARM_USER + MAX_GLSL_USER_PARMS> glslUniforms;
+
+
+	int				currentVertexShader;
+	int				currentFragmentShader;
+	idList<vertexShader_t> vertexShaders;
+	idList<fragmentShader_t> fragmentShaders;
+};
+
+extern idRenderProgManager renderProgManager;
+
+#endif
diff --git a/neo/renderer/RenderProgs_GLSL.cpp b/neo/renderer/RenderProgs_GLSL.cpp
new file mode 100644
index 0000000..9222311
--- /dev/null
+++ b/neo/renderer/RenderProgs_GLSL.cpp
@@ -0,0 +1,1291 @@
+/*
+===========================================================================
+
+Doom 3 BFG Edition GPL Source Code
+Copyright (C) 1993-2012 id Software LLC, a ZeniMax Media company. 
+
+This file is part of the Doom 3 BFG Edition GPL Source Code ("Doom 3 BFG Edition Source Code").  
+
+Doom 3 BFG Edition Source Code is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+Doom 3 BFG Edition Source Code is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Doom 3 BFG Edition Source Code.  If not, see <http://www.gnu.org/licenses/>.
+
+In addition, the Doom 3 BFG Edition Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 BFG Edition Source Code.  If not, please request a copy in writing from id Software at the address below.
+
+If you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.
+
+===========================================================================
+*/
+
+#include "sys/platform.h"
+
+#include "renderer/tr_local.h"
+
+idCVar r_skipStripDeadCode( "r_skipStripDeadCode", "0", CVAR_BOOL, "Skip stripping dead code" );
+idCVar r_useUniformArrays( "r_useUniformArrays", "1", CVAR_BOOL, "" );
+
+
+#define VERTEX_UNIFORM_ARRAY_NAME				"_va_"
+#define FRAGMENT_UNIFORM_ARRAY_NAME				"_fa_"
+
+static const int AT_VS_IN  = BIT( 1 );
+static const int AT_VS_OUT = BIT( 2 );
+static const int AT_PS_IN  = BIT( 3 );
+static const int AT_PS_OUT = BIT( 4 );
+
+struct idCGBlock {
+	idStr prefix;	// tokens that comes before the name
+	idStr name;		// the name
+	idStr postfix;	// tokens that comes after the name
+	bool used;		// whether or not this block is referenced anywhere
+};
+
+/*
+================================================
+attribInfo_t
+================================================
+*/
+struct attribInfo_t {
+	const char *	type;
+	const char *	name;
+	const char *	semantic;
+	const char *	glsl;
+	int				bind;
+	int				flags;
+	int				vertexMask;
+};
+
+/*
+================================================
+vertexMask_t
+
+NOTE: There is a PS3 dependency between the bit flag specified here and the vertex
+attribute index and attribute semantic specified in DeclRenderProg.cpp because the
+stored render prog vertexMask is initialized with cellCgbGetVertexConfiguration().
+The ATTRIB_INDEX_ defines are used to make sure the vertexMask_t and attrib assignment
+in DeclRenderProg.cpp are in sync.
+
+Even though VERTEX_MASK_XYZ_SHORT and VERTEX_MASK_ST_SHORT are not real attributes,
+they come before the VERTEX_MASK_MORPH to reduce the range of vertex program
+permutations defined by the vertexMask_t bits on the Xbox 360 (see MAX_VERTEX_DECLARATIONS).
+================================================
+*/
+enum vertexMask_t {
+	VERTEX_MASK_XYZ			= BIT( PC_ATTRIB_INDEX_VERTEX ),
+	VERTEX_MASK_ST			= BIT( PC_ATTRIB_INDEX_ST ),
+	VERTEX_MASK_NORMAL		= BIT( PC_ATTRIB_INDEX_NORMAL ),
+	VERTEX_MASK_COLOR		= BIT( PC_ATTRIB_INDEX_COLOR ),
+	VERTEX_MASK_TANGENT		= BIT( PC_ATTRIB_INDEX_TANGENT ),
+	VERTEX_MASK_BITANGENT	= BIT( PC_ATTRIB_INDEX_BITANGENT ),
+};
+
+attribInfo_t attribsPC[] = {
+	// vertex attributes
+	{ "float3",		"position",		"POSITION",		"in_Position",			PC_ATTRIB_INDEX_VERTEX,			AT_VS_IN,		VERTEX_MASK_XYZ },
+	{ "float2",		"texcoord",		"TEXCOORD0",	"in_TexCoord",			PC_ATTRIB_INDEX_ST,				AT_VS_IN,		VERTEX_MASK_ST },
+	{ "float3",		"normal",		"NORMAL",		"in_Normal",			PC_ATTRIB_INDEX_NORMAL,			AT_VS_IN,		VERTEX_MASK_NORMAL },
+	{ "float3",		"tangent",		"TANGENT",		"in_Tangent",			PC_ATTRIB_INDEX_TANGENT,		AT_VS_IN,		VERTEX_MASK_TANGENT },
+	{ "float3",		"bitangent",	"BITANGENT",	"in_Bitangent",			PC_ATTRIB_INDEX_BITANGENT,		AT_VS_IN,		VERTEX_MASK_BITANGENT },
+	{ "float4",		"color",		"COLOR0",		"in_Color",				PC_ATTRIB_INDEX_COLOR,			AT_VS_IN,		VERTEX_MASK_COLOR },
+
+	// pre-defined vertex program output
+	{ "float4",		"position",		"POSITION",		"gl_Position",			0,	AT_VS_OUT,		0 },
+	{ "float",		"clip0",		"CLP0",			"gl_ClipDistance[0]",	0,	AT_VS_OUT,		0 },
+	{ "float",		"clip1",		"CLP1",			"gl_ClipDistance[1]",	0,	AT_VS_OUT,		0 },
+	{ "float",		"clip2",		"CLP2",			"gl_ClipDistance[2]",	0,	AT_VS_OUT,		0 },
+	{ "float",		"clip3",		"CLP3",			"gl_ClipDistance[3]",	0,	AT_VS_OUT,		0 },
+	{ "float",		"clip4",		"CLP4",			"gl_ClipDistance[4]",	0,	AT_VS_OUT,		0 },
+	{ "float",		"clip5",		"CLP5",			"gl_ClipDistance[5]",	0,	AT_VS_OUT,		0 },
+
+	// pre-defined fragment program input
+	{ "float4",		"position",		"WPOS",			"gl_FragCoord",			0,	AT_PS_IN,		0 },
+	{ "half4",		"hposition",	"WPOS",			"gl_FragCoord",			0,	AT_PS_IN,		0 },
+	{ "float",		"facing",		"FACE",			"gl_FrontFacing",		0,	AT_PS_IN,		0 },
+
+	// fragment program output
+	{ "float4",		"color",		"COLOR",		"gl_FragColor",		0,	AT_PS_OUT,		0 }, // GLSL version 1.2 doesn't allow for custom color name mappings
+	{ "half4",		"hcolor",		"COLOR",		"gl_FragColor",		0,	AT_PS_OUT,		0 },
+	{ "float4",		"color0",		"COLOR0",		"gl_FragColor",		0,	AT_PS_OUT,		0 },
+	{ "float4",		"color1",		"COLOR1",		"gl_FragColor",		1,	AT_PS_OUT,		0 },
+	{ "float4",		"color2",		"COLOR2",		"gl_FragColor",		2,	AT_PS_OUT,		0 },
+	{ "float4",		"color3",		"COLOR3",		"gl_FragColor",		3,	AT_PS_OUT,		0 },
+	{ "float",		"depth",		"DEPTH",		"gl_FragDepth",		4,	AT_PS_OUT,		0 },
+
+	// vertex to fragment program pass through
+	{ "float4",		"color",		"COLOR",		"gl_FrontColor",			0,	AT_VS_OUT,	0 },
+	{ "float4",		"color0",		"COLOR0",		"gl_FrontColor",			0,	AT_VS_OUT,	0 },
+	{ "float4",		"color1",		"COLOR1",		"gl_FrontSecondaryColor",	0,	AT_VS_OUT,	0 },
+
+
+	{ "float4",		"color",		"COLOR",		"gl_Color",				0,	AT_PS_IN,	0 },
+	{ "float4",		"color0",		"COLOR0",		"gl_Color",				0,	AT_PS_IN,	0 },
+	{ "float4",		"color1",		"COLOR1",		"gl_SecondaryColor",	0,	AT_PS_IN,	0 },
+
+	{ "half4",		"hcolor",		"COLOR",		"gl_Color",				0,	AT_PS_IN,		0 },
+	{ "half4",		"hcolor0",		"COLOR0",		"gl_Color",				0,	AT_PS_IN,		0 },
+	{ "half4",		"hcolor1",		"COLOR1",		"gl_SecondaryColor",	0,	AT_PS_IN,		0 },
+
+	{ "float4",		"texcoord0",	"TEXCOORD0_centroid",	"vofi_TexCoord0",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord1",	"TEXCOORD1_centroid",	"vofi_TexCoord1",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord2",	"TEXCOORD2_centroid",	"vofi_TexCoord2",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord3",	"TEXCOORD3_centroid",	"vofi_TexCoord3",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord4",	"TEXCOORD4_centroid",	"vofi_TexCoord4",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord5",	"TEXCOORD5_centroid",	"vofi_TexCoord5",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord6",	"TEXCOORD6_centroid",	"vofi_TexCoord6",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord7",	"TEXCOORD7_centroid",	"vofi_TexCoord7",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord8",	"TEXCOORD8_centroid",	"vofi_TexCoord8",	0,	AT_PS_IN,	0 },
+	{ "float4",		"texcoord9",	"TEXCOORD9_centroid",	"vofi_TexCoord9",	0,	AT_PS_IN,	0 },
+
+	{ "float4",		"texcoord0",	"TEXCOORD0",	"vofi_TexCoord0",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord1",	"TEXCOORD1",	"vofi_TexCoord1",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord2",	"TEXCOORD2",	"vofi_TexCoord2",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord3",	"TEXCOORD3",	"vofi_TexCoord3",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord4",	"TEXCOORD4",	"vofi_TexCoord4",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord5",	"TEXCOORD5",	"vofi_TexCoord5",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord6",	"TEXCOORD6",	"vofi_TexCoord6",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord7",	"TEXCOORD7",	"vofi_TexCoord7",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord8",	"TEXCOORD8",	"vofi_TexCoord8",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+	{ "float4",		"texcoord9",	"TEXCOORD9",	"vofi_TexCoord9",		0,	AT_VS_OUT | AT_PS_IN,	0 },
+
+	{ "half4",		"htexcoord0",	"TEXCOORD0",	"vofi_TexCoord0",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord1",	"TEXCOORD1",	"vofi_TexCoord1",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord2",	"TEXCOORD2",	"vofi_TexCoord2",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord3",	"TEXCOORD3",	"vofi_TexCoord3",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord4",	"TEXCOORD4",	"vofi_TexCoord4",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord5",	"TEXCOORD5",	"vofi_TexCoord5",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord6",	"TEXCOORD6",	"vofi_TexCoord6",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord7",	"TEXCOORD7",	"vofi_TexCoord7",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord8",	"TEXCOORD8",	"vofi_TexCoord8",		0,	AT_PS_IN,		0 },
+	{ "half4",		"htexcoord9",	"TEXCOORD9",	"vofi_TexCoord9",		0,	AT_PS_IN,		0 },
+	{ "float",		"fog",			"FOG",			"gl_FogFragCoord",		0,	AT_VS_OUT,		0 },
+	{ "float4",		"fog",			"FOG",			"gl_FogFragCoord",		0,	AT_PS_IN,		0 },
+	{ NULL,			NULL,			NULL,			NULL,					0,	0,				0 }
+};
+
+const char * types[] = {
+	"int",
+	"float",
+	"half",
+	"fixed",
+	"bool",
+	"cint",
+	"cfloat",
+	"void"
+};
+static const int numTypes = sizeof( types ) / sizeof( types[0] );
+
+const char * typePosts[] = {
+	"1", "2", "3", "4",
+	"1x1", "1x2", "1x3", "1x4",
+	"2x1", "2x2", "2x3", "2x4",
+	"3x1", "3x2", "3x3", "3x4",
+	"4x1", "4x2", "4x3", "4x4"
+};
+static const int numTypePosts = sizeof( typePosts ) / sizeof( typePosts[0] );
+
+const char * prefixes[] = {
+	"static",
+	"const",
+	"uniform",
+	"struct",
+
+	"sampler",
+
+	"sampler1D",
+	"sampler2D",
+	"sampler3D",
+	"samplerCUBE",
+
+	"sampler1DShadow",		// GLSL
+	"sampler2DShadow",		// GLSL
+	"sampler3DShadow",		// GLSL
+	"samplerCubeShadow",	// GLSL
+
+	"sampler2DMS",			// GLSL
+};
+static const int numPrefixes = sizeof( prefixes ) / sizeof( prefixes[0] );
+
+// For GLSL we need to have the names for the renderparms so we can look up their run time indices within the renderprograms
+static const char * GLSLParmNames[] = {
+	"rpScreenCorrectionFactor",
+	"rpWindowCoord",
+	"rpDiffuseModifier",
+	"rpSpecularModifier",
+
+	"rpLocalLightOrigin",
+	"rpLocalViewOrigin",
+
+	"rpLightProjectionS",
+	"rpLightProjectionT",
+	"rpLightProjectionQ",
+	"rpLightFalloffS",
+
+	"rpBumpMatrixS",
+	"rpBumpMatrixT",
+
+	"rpDiffuseMatrixS",
+	"rpDiffuseMatrixT",
+
+	"rpSpecularMatrixS",
+	"rpSpecularMatrixT",
+
+	"rpVertexColorModulate",
+	"rpVertexColorAdd",
+
+	"rpColor",
+	"rpViewOrigin",
+	"rpGlobalEyePos",
+
+	"rpMVPmatrixX",
+	"rpMVPmatrixY",
+	"rpMVPmatrixZ",
+	"rpMVPmatrixW",
+
+	"rpModelMatrixX",
+	"rpModelMatrixY",
+	"rpModelMatrixZ",
+	"rpModelMatrixW",
+
+	"rpProjectionMatrixX",
+	"rpProjectionMatrixY",
+	"rpProjectionMatrixZ",
+	"rpProjectionMatrixW",
+
+	"rpModelViewMatrixX",
+	"rpModelViewMatrixY",
+	"rpModelViewMatrixZ",
+	"rpModelViewMatrixW",
+
+	"rpTextureMatrixS",
+	"rpTextureMatrixT",
+
+	"rpTexGen0S",
+	"rpTexGen0T",
+	"rpTexGen0Q",
+	"rpTexGen0Enabled",
+
+	"rpTexGen1S",
+	"rpTexGen1T",
+	"rpTexGen1Q",
+	"rpTexGen1Enabled",
+
+	"rpWobbleSkyX",
+	"rpWobbleSkyY",
+	"rpWobbleSkyZ",
+
+	"rpOverbright",
+	"rpEnableSkinning",
+	"rpAlphaTest"
+};
+
+/*
+========================
+StripDeadCode
+========================
+*/
+idStr StripDeadCode( const idStr & in, const char * name ) {
+	if ( r_skipStripDeadCode.GetBool() ) {
+		return in;
+	}
+
+	idParser src( LEXFL_NOFATALERRORS );
+	src.LoadMemory( in.c_str(), in.Length(), name );
+	src.AddDefine("PC");
+
+	idList< idCGBlock > blocks;
+
+	blocks.SetNum( 100 );
+
+	idToken token;
+	while ( !src.EndOfFile() ) {
+		idCGBlock & block = blocks.Alloc();
+		// read prefix
+		while ( src.ReadToken( &token ) ) {
+			bool found = false;
+			for ( int i = 0; i < numPrefixes; i++ ) {
+				if ( token == prefixes[i] ) {
+					found = true;
+					break;
+				}
+			}
+			if ( !found ) {
+				for ( int i = 0; i < numTypes; i++ ) {
+					if ( token == types[i] ) {
+						found = true;
+						break;
+					}
+					int typeLen = idStr::Length( types[i] );
+					if ( token.Cmpn( types[i], typeLen ) == 0 ) {
+						for ( int j = 0; j < numTypePosts; j++ ) {
+							if ( idStr::Cmp( token.c_str() + typeLen, typePosts[j] ) == 0 ) {
+								found = true;
+								break;
+							}
+						}
+						if ( found ) {
+							break;
+						}
+					}
+				}
+			}
+			if ( found ) {
+				if ( block.prefix.Length() > 0 && token.WhiteSpaceBeforeToken() ) {
+					block.prefix += ' ';
+				}
+				block.prefix += token;
+			} else {
+				src.UnreadToken( &token );
+				break;
+			}
+		}
+		if ( !src.ReadToken( &token ) ) {
+			blocks.SetNum( blocks.Num() - 1 );
+			break;
+		}
+		block.name = token;
+
+		if ( src.PeekTokenString( "=" ) || src.PeekTokenString( ":" ) || src.PeekTokenString( "[" ) ) {
+			src.ReadToken( &token );
+			block.postfix = token;
+			while ( src.ReadToken( &token ) ) {
+				if ( token == ";" ) {
+					block.postfix += ';';
+					break;
+				} else {
+					if ( token.WhiteSpaceBeforeToken() ){
+						block.postfix += ' ';
+					}
+					block.postfix += token;
+				}
+			}
+		} else if ( src.PeekTokenString( "(" ) ) {
+			idStr parms, body;
+			src.ParseBracedSection( parms, -1, true, '(', ')' );
+			if ( src.CheckTokenString( ";" ) ) {
+				block.postfix = parms + ";";
+			} else {
+				src.ParseBracedSection( body, -1, true, '{', '}' );
+				block.postfix = parms + " " + body;
+			}
+		} else if ( src.PeekTokenString( "{" ) ) {
+			src.ParseBracedSection( block.postfix, -1, true, '{', '}' );
+			if ( src.CheckTokenString( ";" ) ) {
+				block.postfix += ';';
+			}
+		} else if ( src.CheckTokenString( ";" ) ) {
+			block.postfix = idStr( ';' );
+		} else {
+			src.Warning( "Could not strip dead code -- unknown token %s\n", token.c_str() );
+			return in;
+		}
+	}
+
+	idList<int> stack;
+	for ( int i = 0; i < blocks.Num(); i++ ) {
+		blocks[i].used = ( ( blocks[i].name == "main" )
+			|| blocks[i].name.Right( 4 ) == "_ubo"
+			);
+
+		if ( blocks[i].name == "include" ) {
+			blocks[i].used = true;
+			blocks[i].name = ""; // clear out the include tag
+		}
+
+		if ( blocks[i].used ) {
+			stack.Append( i );
+		}
+	}
+
+	while ( stack.Num() > 0 ) {
+		int i = stack[stack.Num() - 1];
+		stack.SetNum( stack.Num() - 1 );
+
+		idLexer src( LEXFL_NOFATALERRORS );
+		src.LoadMemory( blocks[i].postfix.c_str(), blocks[i].postfix.Length(), name );
+		while ( src.ReadToken( &token ) ) {
+			for ( int j = 0; j < blocks.Num(); j++ ) {
+				if ( !blocks[j].used ) {
+					if ( token == blocks[j].name ) {
+						blocks[j].used = true;
+						stack.Append( j );
+					}
+				}
+			}
+		}
+	}
+
+	idStr out;
+
+	for ( int i = 0; i < blocks.Num(); i++ ) {
+		if ( blocks[i].used ) {
+			out += blocks[i].prefix;
+			out += ' ';
+			out += blocks[i].name;
+			out += ' ';
+			out += blocks[i].postfix;
+			out += '\n';
+		}
+	}
+
+	return out;
+}
+
+struct typeConversion_t {
+	const char * typeCG;
+	const char * typeGLSL;
+} typeConversion[] = {
+	{ "void",				"void" },
+
+	{ "fixed",				"float" },
+
+	{ "float",				"float" },
+	{ "float2",				"vec2" },
+	{ "float3",				"vec3" },
+	{ "float4",				"vec4" },
+
+	{ "half",				"float" },
+	{ "half2",				"vec2" },
+	{ "half3",				"vec3" },
+	{ "half4",				"vec4" },
+
+	{ "int",				"int" },
+	{ "int2",				"ivec2" },
+	{ "int3",				"ivec3" },
+	{ "int4",				"ivec4" },
+
+	{ "bool",				"bool" },
+	{ "bool2",				"bvec2" },
+	{ "bool3",				"bvec3" },
+	{ "bool4",				"bvec4" },
+
+	{ "float2x2",			"mat2x2" },
+	{ "float2x3",			"mat2x3" },
+	{ "float2x4",			"mat2x4" },
+
+	{ "float3x2",			"mat3x2" },
+	{ "float3x3",			"mat3x3" },
+	{ "float3x4",			"mat3x4" },
+
+	{ "float4x2",			"mat4x2" },
+	{ "float4x3",			"mat4x3" },
+	{ "float4x4",			"mat4x4" },
+
+	{ "sampler1D",			"sampler1D" },
+	{ "sampler2D",			"sampler2D" },
+	{ "sampler3D",			"sampler3D" },
+	{ "samplerCUBE",		"samplerCube" },
+
+	{ "sampler1DShadow",	"sampler1DShadow" },
+	{ "sampler2DShadow",	"sampler2DShadow" },
+	{ "sampler3DShadow",	"sampler3DShadow" },
+	{ "samplerCubeShadow",	"samplerCubeShadow" },
+
+	{ "sampler2DMS",		"sampler2DMS" },
+
+	{ NULL, NULL }
+};
+
+const char * vertexInsert = {
+	"#version 150\n"
+	"#define PC\n"
+	"\n"
+	"float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec4 tex2Dlod( sampler2D sampler, vec4 texcoord ) { return textureLod( sampler, texcoord.xy, texcoord.w ); }\n"
+	"\n"
+};
+
+const char * fragmentInsert = {
+	"#version 150\n"
+	"#define PC\n"
+	"\n"
+	"void clip( float v ) { if ( v < 0.0 ) { discard; } }\n"
+	"void clip( vec2 v ) { if ( any( lessThan( v, vec2( 0.0 ) ) ) ) { discard; } }\n"
+	"void clip( vec3 v ) { if ( any( lessThan( v, vec3( 0.0 ) ) ) ) { discard; } }\n"
+	"void clip( vec4 v ) { if ( any( lessThan( v, vec4( 0.0 ) ) ) ) { discard; } }\n"
+	"\n"
+	"float saturate( float v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec2 saturate( vec2 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec3 saturate( vec3 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"vec4 saturate( vec4 v ) { return clamp( v, 0.0, 1.0 ); }\n"
+	"\n"
+	"vec4 tex2D( sampler2D sampler, vec2 texcoord ) { return texture( sampler, texcoord.xy ); }\n"
+	"vec4 tex2D( sampler2DShadow sampler, vec3 texcoord ) { return vec4( texture( sampler, texcoord.xyz ) ); }\n"
+	"\n"
+	"vec4 tex2D( sampler2D sampler, vec2 texcoord, vec2 dx, vec2 dy ) { return textureGrad( sampler, texcoord.xy, dx, dy ); }\n"
+	"vec4 tex2D( sampler2DShadow sampler, vec3 texcoord, vec2 dx, vec2 dy ) { return vec4( textureGrad( sampler, texcoord.xyz, dx, dy ) ); }\n"
+	"\n"
+	"vec4 texCUBE( samplerCube sampler, vec3 texcoord ) { return texture( sampler, texcoord.xyz ); }\n"
+	"vec4 texCUBE( samplerCubeShadow sampler, vec4 texcoord ) { return vec4( texture( sampler, texcoord.xyzw ) ); }\n"
+	"\n"
+	"vec4 tex1Dproj( sampler1D sampler, vec2 texcoord ) { return textureProj( sampler, texcoord ); }\n"
+	"vec4 tex2Dproj( sampler2D sampler, vec3 texcoord ) { return textureProj( sampler, texcoord ); }\n"
+	"vec4 tex3Dproj( sampler3D sampler, vec4 texcoord ) { return textureProj( sampler, texcoord ); }\n"
+	"\n"
+	"vec4 tex1Dbias( sampler1D sampler, vec4 texcoord ) { return texture( sampler, texcoord.x, texcoord.w ); }\n"
+	"vec4 tex2Dbias( sampler2D sampler, vec4 texcoord ) { return texture( sampler, texcoord.xy, texcoord.w ); }\n"
+	"vec4 tex3Dbias( sampler3D sampler, vec4 texcoord ) { return texture( sampler, texcoord.xyz, texcoord.w ); }\n"
+	"vec4 texCUBEbias( samplerCube sampler, vec4 texcoord ) { return texture( sampler, texcoord.xyz, texcoord.w ); }\n"
+	"\n"
+	"vec4 tex1Dlod( sampler1D sampler, vec4 texcoord ) { return textureLod( sampler, texcoord.x, texcoord.w ); }\n"
+	"vec4 tex2Dlod( sampler2D sampler, vec4 texcoord ) { return textureLod( sampler, texcoord.xy, texcoord.w ); }\n"
+	"vec4 tex3Dlod( sampler3D sampler, vec4 texcoord ) { return textureLod( sampler, texcoord.xyz, texcoord.w ); }\n"
+	"vec4 texCUBElod( samplerCube sampler, vec4 texcoord ) { return textureLod( sampler, texcoord.xyz, texcoord.w ); }\n"
+	"\n"
+};
+
+struct builtinConversion_t {
+	const char * nameCG;
+	const char * nameGLSL;
+} builtinConversion[] = {
+	{ "frac",		"fract" },
+	{ "lerp",		"mix" },
+	{ "rsqrt",		"inversesqrt" },
+	{ "ddx",		"dFdx" },
+	{ "ddy",		"dFdy" },
+
+	{ NULL, NULL }
+};
+
+struct inOutVariable_t {
+	idStr	type;
+	idStr	nameCg;
+	idStr	nameGLSL;
+	bool	declareInOut;
+};
+
+/*
+========================
+ParseInOutStruct
+========================
+*/
+void ParseInOutStruct( idLexer & src, int attribType, idList< inOutVariable_t > & inOutVars ) {
+	src.ExpectTokenString( "{" );
+
+	while( !src.CheckTokenString( "}" ) ) {
+		inOutVariable_t var;
+
+		idToken token;
+		src.ReadToken( &token );
+		var.type = token;
+		src.ReadToken( &token );
+		var.nameCg = token;
+
+		if ( !src.CheckTokenString( ":" ) ) {
+			src.SkipUntilString( ";" );
+			continue;
+		}
+
+		src.ReadToken( &token );
+		var.nameGLSL = token;
+		src.ExpectTokenString( ";" );
+
+		// convert the type
+		for ( int i = 0; typeConversion[i].typeCG != NULL; i++ ) {
+			if ( var.type.Cmp( typeConversion[i].typeCG ) == 0 ) {
+				var.type = typeConversion[i].typeGLSL;
+				break;
+			}
+		}
+
+		// convert the semantic to a GLSL name
+		for ( int i = 0; attribsPC[i].semantic != NULL; i++ ) {
+			if ( ( attribsPC[i].flags & attribType ) != 0 ) {
+				if ( var.nameGLSL.Cmp( attribsPC[i].semantic ) == 0 ) {
+					var.nameGLSL = attribsPC[i].glsl;
+					break;
+				}
+			}
+		}
+
+		// check if it was defined previously
+		var.declareInOut = true;
+		for ( int i = 0; i < inOutVars.Num(); i++ ) {
+			if ( var.nameGLSL == inOutVars[i].nameGLSL ) {
+				var.declareInOut = false;
+				break;
+			}
+		}
+
+		inOutVars.Append( var );
+	}
+
+	src.ExpectTokenString( ";" );
+}
+
+/*
+========================
+ConvertCG2GLSL
+========================
+*/
+idStr ConvertCG2GLSL( const idStr & in, const char * name, bool isVertexProgram, idStr & uniforms ) {
+	idStr program;
+	program.ReAllocate( in.Length() * 2, false );
+
+	idList< inOutVariable_t > varsIn;
+	idList< inOutVariable_t > varsOut;
+	idList< idStr > uniformList;
+
+	idLexer src( LEXFL_NOFATALERRORS );
+	src.LoadMemory( in.c_str(), in.Length(), name );
+
+	bool inMain = false;
+	const char * uniformArrayName = isVertexProgram ? VERTEX_UNIFORM_ARRAY_NAME : FRAGMENT_UNIFORM_ARRAY_NAME;
+	char newline[128] = { "\n" };
+
+	idToken token;
+	while ( src.ReadToken( &token ) ) {
+
+		// check for uniforms
+		while ( token == "uniform" && src.CheckTokenString( "float4" ) ) {
+			src.ReadToken( &token );
+			uniformList.Append( token );
+
+			// strip ': register()' from uniforms
+			if ( src.CheckTokenString( ":" ) ) {
+				if ( src.CheckTokenString( "register" ) ) {
+					src.SkipUntilString( ";" );
+				}
+			}
+
+			src.ReadToken( & token );
+		}
+
+		// convert the in/out structs
+		if ( token == "struct" ) {
+			if ( src.CheckTokenString( "VS_IN" ) ) {
+				ParseInOutStruct( src, AT_VS_IN, varsIn );
+				program += "\n\n";
+				for ( int i = 0; i < varsIn.Num(); i++ ) {
+					if ( varsIn[i].declareInOut ) {
+						program += "in " + varsIn[i].type + " " + varsIn[i].nameGLSL + ";\n";
+					}
+				}
+				continue;
+			} else if ( src.CheckTokenString( "VS_OUT" ) ) {
+				ParseInOutStruct( src, AT_VS_OUT, varsOut );
+				program += "\n";
+				for ( int i = 0; i < varsOut.Num(); i++ ) {
+					if ( varsOut[i].declareInOut ) {
+						program += "out " + varsOut[i].type + " " + varsOut[i].nameGLSL + ";\n";
+					}
+				}
+				continue;
+			} else if ( src.CheckTokenString( "PS_IN" ) ) {
+				ParseInOutStruct( src, AT_PS_IN, varsIn );
+				program += "\n\n";
+				for ( int i = 0; i < varsIn.Num(); i++ ) {
+					if ( varsIn[i].declareInOut ) {
+						program += "in " + varsIn[i].type + " " + varsIn[i].nameGLSL + ";\n";
+					}
+				}
+				inOutVariable_t var;
+				var.type = "vec4";
+				var.nameCg = "position";
+				var.nameGLSL = "gl_FragCoord";
+				varsIn.Append( var );
+				continue;
+			} else if ( src.CheckTokenString( "PS_OUT" ) ) {
+				ParseInOutStruct( src, AT_PS_OUT, varsOut );
+				program += "\n";
+				for ( int i = 0; i < varsOut.Num(); i++ ) {
+					if ( varsOut[i].declareInOut ) {
+						program += "out " + varsOut[i].type + " " + varsOut[i].nameGLSL + ";\n";
+					}
+				}
+				continue;
+			}
+		}
+
+		// strip 'static'
+		if ( token == "static" ) {
+			program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+			src.SkipWhiteSpace( true ); // remove white space between 'static' and the next token
+			continue;
+		}
+
+		// strip ': register()' from uniforms
+		if ( token == ":" ) {
+			if ( src.CheckTokenString( "register" ) ) {
+				src.SkipUntilString( ";" );
+				program += ";";
+				continue;
+			}
+		}
+
+		// strip in/program parameters from main
+		if ( token == "void" && src.CheckTokenString( "main" ) ) {
+			src.ExpectTokenString( "(" );
+			while( src.ReadToken( &token ) ) {
+				if ( token == ")" ) {
+					break;
+				}
+			}
+
+			program += "\nvoid main()";
+			inMain = true;
+			continue;
+		}
+
+		// strip 'const' from local variables in main()
+		if ( token == "const" && inMain ) {
+			program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+			src.SkipWhiteSpace( true ); // remove white space between 'const' and the next token
+			continue;
+		}
+
+		// maintain indentation
+		if ( token == "{" ) {
+			program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+			program += "{";
+
+			int len = Min( idStr::Length( newline ) + 1, (int)sizeof( newline ) - 1 );
+			newline[len - 1] = '\t';
+			newline[len - 0] = '\0';
+			continue;
+		}
+		if ( token == "}" ) {
+			int len = Max( idStr::Length( newline ) - 1, 0 );
+			newline[len] = '\0';
+
+			program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+			program += "}";
+			continue;
+		}
+
+		// check for a type conversion
+		bool foundType = false;
+		for ( int i = 0; typeConversion[i].typeCG != NULL; i++ ) {
+			if ( token.Cmp( typeConversion[i].typeCG ) == 0 ) {
+				program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+				program += typeConversion[i].typeGLSL;
+				foundType = true;
+				break;
+			}
+		}
+		if ( foundType ) {
+			continue;
+		}
+
+		if ( r_useUniformArrays.GetBool() ) {
+			// check for uniforms that need to be converted to the array
+			bool isUniform = false;
+			for ( int i = 0; i < uniformList.Num(); i++ ) {
+				if ( token == uniformList[i] ) {
+					program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+					program += va( "%s[%d /* %s */]", uniformArrayName, i, uniformList[i].c_str() );
+					isUniform = true;
+					break;
+				}
+			}
+			if ( isUniform ) {
+				continue;
+			}
+		}
+
+		// check for input/output parameters
+		if ( src.CheckTokenString( "." ) ) {
+
+			if ( token == "vertex" || token == "fragment" ) {
+				idToken member;
+				src.ReadToken( &member );
+
+				bool foundInOut = false;
+				for ( int i = 0; i < varsIn.Num(); i++ ) {
+					if ( member.Cmp( varsIn[i].nameCg ) == 0 ) {
+						program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+						program += varsIn[i].nameGLSL;
+						foundInOut = true;
+						break;
+					}
+				}
+				if ( !foundInOut ) {
+					src.Error( "invalid input parameter %s.%s", token.c_str(), member.c_str() );
+					program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+					program += token;
+					program += ".";
+					program += member;
+				}
+				continue;
+			}
+
+			if ( token == "result" ) {
+				idToken member;
+				src.ReadToken( &member );
+
+				bool foundInOut = false;
+				for ( int i = 0; i < varsOut.Num(); i++ ) {
+					if ( member.Cmp( varsOut[i].nameCg ) == 0 ) {
+						program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+						program += varsOut[i].nameGLSL;
+						foundInOut = true;
+						break;
+					}
+				}
+				if ( !foundInOut ) {
+					src.Error( "invalid output parameter %s.%s", token.c_str(), member.c_str() );
+					program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+					program += token;
+					program += ".";
+					program += member;
+				}
+				continue;
+			}
+
+			program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+			program += token;
+			program += ".";
+			continue;
+		}
+
+		// check for a function conversion
+		bool foundFunction = false;
+		for ( int i = 0; builtinConversion[i].nameCG != NULL; i++ ) {
+			if ( token.Cmp( builtinConversion[i].nameCG ) == 0 ) {
+				program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+				program += builtinConversion[i].nameGLSL;
+				foundFunction = true;
+				break;
+			}
+		}
+		if ( foundFunction ) {
+			continue;
+		}
+
+		program += ( token.linesCrossed > 0 ) ? newline : ( token.WhiteSpaceBeforeToken() > 0 ? " " : "" );
+		program += token;
+	}
+
+	idStr out;
+
+	if ( isVertexProgram ) {
+		out.ReAllocate( idStr::Length( vertexInsert ) + in.Length() * 2, false );
+		out += vertexInsert;
+	} else {
+		out.ReAllocate( idStr::Length( fragmentInsert ) + in.Length() * 2, false );
+		out += fragmentInsert;
+	}
+
+	if ( uniformList.Num() > 0 ) {
+		if ( r_useUniformArrays.GetBool() ) {
+			out += va( "\nuniform vec4 %s[%d];\n", uniformArrayName, uniformList.Num() );
+		} else {
+			out += "\n";
+			for ( int i = 0; i < uniformList.Num(); i++ ) {
+				out += "uniform vec4 ";
+				out += uniformList[i];
+				out += ";\n";
+			}
+		}
+	}
+
+	out += program;
+
+	for ( int i = 0; i < uniformList.Num(); i++ ) {
+		uniforms += uniformList[i];
+		uniforms += "\n";
+	}
+	uniforms += "\n";
+
+	return out;
+}
+
+/*
+================================================================================================
+idRenderProgManager::LoadGLSLShader
+================================================================================================
+*/
+GLuint idRenderProgManager::LoadGLSLShader( GLenum target, const char * name, idList<int> & uniforms ) {
+
+	idStr inFile;
+	idStr outFileHLSL;
+	idStr outFileGLSL;
+	idStr outFileUniforms;
+	inFile.Format( "renderprogs/%s", name );
+	inFile.StripFileExtension();
+	outFileHLSL.Format( "renderprogs/hlsl/%s", name );
+	outFileHLSL.StripFileExtension();
+	outFileGLSL.Format( "renderprogs/glsl/%s", name );
+	outFileGLSL.StripFileExtension();
+	outFileUniforms.Format( "renderprogs/glsl/%s", name );
+	outFileUniforms.StripFileExtension();
+	if ( target == GL_FRAGMENT_SHADER ) {
+		inFile += ".pixel";
+		outFileHLSL += "_fragment.hlsl";
+		outFileGLSL += "_fragment.glsl";
+		outFileUniforms += "_fragment.uniforms";
+	} else {
+		inFile += ".vertex";
+		outFileHLSL += "_vertex.hlsl";
+		outFileGLSL += "_vertex.glsl";
+		outFileUniforms += "_vertex.uniforms";
+	}
+
+	// first check whether we already have a valid GLSL file and compare it to the hlsl timestamp;
+	ID_TIME_T hlslTimeStamp;
+	int hlslFileLength = fileSystem->ReadFile( inFile.c_str(), NULL, &hlslTimeStamp );
+
+	ID_TIME_T glslTimeStamp;
+	int glslFileLength = fileSystem->ReadFile( outFileGLSL.c_str(), NULL, &glslTimeStamp );
+
+	// if the glsl file doesn't exist or we have a newer HLSL file we need to recreate the glsl file.
+	idStr programGLSL;
+	idStr programUniforms;
+	if ( ( glslFileLength <= 0 ) || ( hlslTimeStamp > glslTimeStamp ) ) {
+		if ( hlslFileLength <= 0 ) {
+			// hlsl file doesn't even exist bail out
+			return false;
+		}
+
+		void * hlslFileBuffer = NULL;
+		int len = fileSystem->ReadFile( inFile.c_str(), &hlslFileBuffer );
+		if ( len <= 0 ) {
+			return false;
+		}
+		idStr hlslCode( ( const char* ) hlslFileBuffer );
+		Mem_Free( hlslFileBuffer );
+		idStr programHLSL = StripDeadCode( hlslCode, inFile );
+		programGLSL = ConvertCG2GLSL( programHLSL, inFile, target == GL_VERTEX_SHADER, programUniforms );
+
+		fileSystem->WriteFile( outFileHLSL, programHLSL.c_str(), programHLSL.Length(), "fs_basepath" );
+		fileSystem->WriteFile( outFileGLSL, programGLSL.c_str(), programGLSL.Length(), "fs_basepath" );
+		if ( r_useUniformArrays.GetBool() ) {
+			fileSystem->WriteFile( outFileUniforms, programUniforms.c_str(), programUniforms.Length(), "fs_basepath" );
+		}
+	} else {
+		// read in the glsl file
+		void * fileBufferGLSL = NULL;
+		int lengthGLSL = fileSystem->ReadFile( outFileGLSL.c_str(), &fileBufferGLSL );
+		if ( lengthGLSL <= 0 ) {
+			idLib::Error( "GLSL file %s could not be loaded and may be corrupt", outFileGLSL.c_str() );
+		}
+		programGLSL = ( const char * ) fileBufferGLSL;
+		Mem_Free( fileBufferGLSL );
+
+		if ( r_useUniformArrays.GetBool() ) {
+			// read in the uniform file
+			void * fileBufferUniforms = NULL;
+			int lengthUniforms = fileSystem->ReadFile( outFileUniforms.c_str(), &fileBufferUniforms );
+			if ( lengthUniforms <= 0 ) {
+				idLib::Error( "uniform file %s could not be loaded and may be corrupt", outFileUniforms.c_str() );
+			}
+			programUniforms = ( const char* ) fileBufferUniforms;
+			Mem_Free( fileBufferUniforms );
+		}
+	}
+
+	// find the uniforms locations in either the vertex or fragment uniform array
+	if ( r_useUniformArrays.GetBool() ) {
+		uniforms.Clear();
+
+		idLexer src( programUniforms, programUniforms.Length(), "uniforms" );
+		idToken token;
+		while ( src.ReadToken( &token ) ) {
+			int index = -1;
+			for ( int i = 0; i < RENDERPARM_TOTAL && index == -1; i++ ) {
+				const char * parmName = GetGLSLParmName( i );
+				if ( token == parmName ) {
+					index = i;
+				}
+			}
+			for ( int i = 0; i < MAX_GLSL_USER_PARMS && index == -1; i++ ) {
+				const char * parmName = GetGLSLParmName( RENDERPARM_USER + i );
+				if ( token == parmName ) {
+					index = RENDERPARM_USER + i;
+				}
+			}
+			if ( index == -1 ) {
+				idLib::Error( "couldn't find uniform %s for %s", token.c_str(), outFileGLSL.c_str() );
+			}
+			uniforms.Append( index );
+		}
+	}
+
+	// create and compile the shader
+	const GLuint shader = qglCreateShader( target );
+	if ( shader ) {
+		const char * source[1] = { programGLSL.c_str() };
+
+		qglShaderSource( shader, 1, source, NULL );
+		qglCompileShader( shader );
+
+		int infologLength = 0;
+		qglGetShaderiv( shader, GL_INFO_LOG_LENGTH, &infologLength );
+		if ( infologLength > 1 ) {
+			idTempArray<char> infoLog( infologLength );
+			int charsWritten = 0;
+			qglGetShaderInfoLog( shader, infologLength, &charsWritten, infoLog.Ptr() );
+
+			// catch the strings the ATI and Intel drivers output on success
+			if ( strstr( infoLog.Ptr(), "successfully compiled to run on hardware" ) != NULL || strstr( infoLog.Ptr(), "No errors." ) != NULL ) {
+				//common->Printf( "%s program %s from %s compiled to run on hardware\n", typeName, GetName(), GetFileName() );
+			} else {
+				common->Printf("While compiling %s program %s\n", (target == GL_FRAGMENT_SHADER) ? "fragment" : "vertex", inFile.c_str());
+
+				const char separator = '\n';
+				idList<idStr> lines;
+				lines.Clear();
+				idStr source( programGLSL );
+				lines.Append( source );
+				for ( int index = 0, ofs = lines[index].Find( separator ); ofs != -1; index++, ofs = lines[index].Find( separator ) ) {
+					lines.Append( lines[index].c_str() + ofs + 1 );
+					lines[index].CapLength( ofs );
+				}
+
+				common->Printf("-----------------\n");
+				for ( int i = 0; i < lines.Num(); i++ ) {
+					common->Printf("%3d: %s\n", i + 1, lines[i].c_str());
+				}
+				common->Printf("-----------------\n");
+
+				common->Printf("%s\n", infoLog.Ptr());
+			}
+		}
+
+		GLint compiled = GL_FALSE;
+		qglGetShaderiv( shader, GL_COMPILE_STATUS, &compiled );
+		if ( compiled == GL_FALSE ) {
+			qglDeleteShader( shader );
+			return INVALID_PROGID;
+		}
+	}
+
+	return shader;
+}
+/*
+================================================================================================
+idRenderProgManager::FindGLSLProgram
+================================================================================================
+*/
+int	 idRenderProgManager::FindGLSLProgram( const char * name, int vIndex, int fIndex ) {
+
+	for ( int i = 0; i < glslPrograms.Num(); ++i ) {
+		if ( ( glslPrograms[i].vertexShaderIndex == vIndex ) && ( glslPrograms[i].fragmentShaderIndex == fIndex ) ) {
+			LoadGLSLProgram( i, vIndex, fIndex );
+			return i;
+		}
+	}
+
+	glslProgram_t program;
+	program.name = name;
+	int index = glslPrograms.Append( program );
+	LoadGLSLProgram( index, vIndex, fIndex );
+	return index;
+}
+
+/*
+================================================================================================
+idRenderProgManager::GetGLSLParmName
+================================================================================================
+*/
+const char* idRenderProgManager::GetGLSLParmName( int rp ) const {
+	if ( rp >= RENDERPARM_USER ) {
+		int userParmIndex = rp - RENDERPARM_USER;
+		return va("rpUser%d", userParmIndex );
+	}
+	assert( rp < RENDERPARM_TOTAL );
+	return GLSLParmNames[ rp ];
+}
+
+/*
+================================================================================================
+idRenderProgManager::SetUniformValue
+================================================================================================
+*/
+void idRenderProgManager::SetUniformValue( const renderParm_t rp, const float * value ) {
+	for ( int i = 0; i < 4; i++ ) {
+		glslUniforms[rp][i] = value[i];
+	}
+}
+
+/*
+================================================================================================
+idRenderProgManager::CommitUnforms
+================================================================================================
+*/
+void idRenderProgManager::CommitUniforms() {
+	const int progID = GetGLSLCurrentProgram();
+	const glslProgram_t & prog = glslPrograms[progID];
+
+	if ( r_useUniformArrays.GetBool() ) {
+		idVec4 localVectors[RENDERPARM_USER + MAX_GLSL_USER_PARMS];
+
+		if ( prog.vertexShaderIndex >= 0 ) {
+			const idList<int> & vertexUniforms = vertexShaders[prog.vertexShaderIndex].uniforms;
+			if ( prog.vertexUniformArray != -1 && vertexUniforms.Num() > 0 ) {
+				for ( int i = 0; i < vertexUniforms.Num(); i++ ) {
+					localVectors[i] = glslUniforms[vertexUniforms[i]];
+				}
+				qglUniform4fv( prog.vertexUniformArray, vertexUniforms.Num(), localVectors->ToFloatPtr() );
+			}
+		}
+
+		if ( prog.fragmentShaderIndex >= 0 ) {
+			const idList<int> & fragmentUniforms = fragmentShaders[prog.fragmentShaderIndex].uniforms;
+			if ( prog.fragmentUniformArray != -1 && fragmentUniforms.Num() > 0 ) {
+				for ( int i = 0; i < fragmentUniforms.Num(); i++ ) {
+					localVectors[i] = glslUniforms[fragmentUniforms[i]];
+				}
+				qglUniform4fv( prog.fragmentUniformArray, fragmentUniforms.Num(), localVectors->ToFloatPtr() );
+			}
+		}
+	} else {
+		for ( int i = 0; i < prog.uniformLocations.Num(); i++ ) {
+			const glslUniformLocation_t & uniformLocation = prog.uniformLocations[i];
+			qglUniform4fv( uniformLocation.uniformIndex, 1, glslUniforms[uniformLocation.parmIndex].ToFloatPtr() );
+		}
+	}
+}
+
+class idSort_QuickUniforms : public idSort_Quick< glslUniformLocation_t, idSort_QuickUniforms > {
+public:
+	int Compare( const glslUniformLocation_t & a, const glslUniformLocation_t & b ) const { return a.uniformIndex - b.uniformIndex; }
+};
+
+/*
+================================================================================================
+idRenderProgManager::LoadGLSLProgram
+================================================================================================
+*/
+void idRenderProgManager::LoadGLSLProgram( const int programIndex, const int vertexShaderIndex, const int fragmentShaderIndex ) {
+	glslProgram_t & prog = glslPrograms[programIndex];
+
+	if ( prog.progId != INVALID_PROGID ) {
+		return; // Already loaded
+	}
+
+	GLuint vertexProgID = ( vertexShaderIndex != -1 ) ? vertexShaders[ vertexShaderIndex ].progId : INVALID_PROGID;
+	GLuint fragmentProgID = ( fragmentShaderIndex != -1 ) ? fragmentShaders[ fragmentShaderIndex ].progId : INVALID_PROGID;
+
+	const GLuint program = qglCreateProgram();
+	if ( program ) {
+
+		if ( vertexProgID != INVALID_PROGID ) {
+			qglAttachShader( program, vertexProgID );
+		}
+
+		if ( fragmentProgID != INVALID_PROGID ) {
+			qglAttachShader( program, fragmentProgID );
+		}
+
+		// bind vertex attribute locations
+		for ( int i = 0; attribsPC[i].glsl != NULL; i++ ) {
+			if ( ( attribsPC[i].flags & AT_VS_IN ) != 0 ) {
+				qglBindAttribLocation( program, attribsPC[i].bind, attribsPC[i].glsl );
+			}
+		}
+
+		qglLinkProgram( program );
+
+		int infologLength = 0;
+		qglGetProgramiv( program, GL_INFO_LOG_LENGTH, &infologLength );
+		if ( infologLength > 1 ) {
+			char * infoLog = (char *)malloc( infologLength );
+			int charsWritten = 0;
+			qglGetProgramInfoLog( program, infologLength, &charsWritten, infoLog );
+
+			// catch the strings the ATI and Intel drivers output on success
+			if ( strstr( infoLog, "Vertex shader(s) linked, fragment shader(s) linked." ) != NULL || strstr( infoLog, "No errors." ) != NULL ) {
+				//common->Printf( "render prog %s from %s linked\n", GetName(), GetFileName() );
+			} else {
+				common->Printf("While linking GLSL program %d with vertexShader %s and fragmentShader %s\n",
+					programIndex, 
+					( vertexShaderIndex >= 0 ) ? vertexShaders[vertexShaderIndex].name.c_str() : "<Invalid>", 
+					( fragmentShaderIndex >= 0 ) ? fragmentShaders[ fragmentShaderIndex ].name.c_str() : "<Invalid>" );
+				common->Printf("%s\n", infoLog);
+			}
+
+			free( infoLog );
+		}
+	}
+
+	int linked = GL_FALSE;
+	qglGetProgramiv( program, GL_LINK_STATUS, &linked );
+	if ( linked == GL_FALSE ) {
+		qglDeleteProgram( program );
+		common->Error("While linking GLSL program %d with vertexShader %s and fragmentShader %s\n",
+			programIndex, 
+			( vertexShaderIndex >= 0 ) ? vertexShaders[vertexShaderIndex].name.c_str() : "<Invalid>", 
+			( fragmentShaderIndex >= 0 ) ? fragmentShaders[ fragmentShaderIndex ].name.c_str() : "<Invalid>" );
+		return;
+	}
+
+	if ( r_useUniformArrays.GetBool() ) {
+		prog.vertexUniformArray = qglGetUniformLocation( program, VERTEX_UNIFORM_ARRAY_NAME );
+		prog.fragmentUniformArray = qglGetUniformLocation( program, FRAGMENT_UNIFORM_ARRAY_NAME );
+
+		assert( prog.vertexUniformArray != -1 || vertexShaderIndex < 0 || vertexShaders[vertexShaderIndex].uniforms.Num() == 0 );
+		assert( prog.fragmentUniformArray != -1 || fragmentShaderIndex < 0 || fragmentShaders[fragmentShaderIndex].uniforms.Num() == 0 );
+	} else {
+		// store the uniform locations after we have linked the GLSL program
+		prog.uniformLocations.Clear();
+		for ( int i = 0; i < RENDERPARM_TOTAL; i++ ) {
+			const char * parmName = GetGLSLParmName( i );
+			GLint loc = qglGetUniformLocation( program, parmName );
+			if ( loc != -1 ) {
+				glslUniformLocation_t uniformLocation;
+				uniformLocation.parmIndex = i;
+				uniformLocation.uniformIndex = loc;
+				prog.uniformLocations.Append( uniformLocation );
+			}
+		}
+
+		// store the USER uniform locations
+		for ( int i = 0; i < MAX_GLSL_USER_PARMS; i++ ) {
+			const char * parmName = GetGLSLParmName( RENDERPARM_USER + i );
+			GLint loc = qglGetUniformLocation( program, parmName );
+			if ( loc != -1 ) {
+				glslUniformLocation_t uniformLocation;
+				uniformLocation.parmIndex = RENDERPARM_USER + i;
+				uniformLocation.uniformIndex = loc;
+				prog.uniformLocations.Append( uniformLocation );
+			}
+		}
+
+		// sort the uniforms based on index
+		prog.uniformLocations.SortWithTemplate( idSort_QuickUniforms() );
+	}
+
+	// get the uniform buffer binding for skinning joint matrices
+	GLint blockIndex = qglGetUniformBlockIndex( program, "matrices_ubo" );
+	if ( blockIndex != -1 ) {
+		qglUniformBlockBinding( program, blockIndex, 0 );
+	}
+
+	// set the texture unit locations once for the render program. We only need to do this once since we only link the program once
+	qglUseProgram( program );
+	for ( int i = 0; i < MAX_PROG_TEXTURE_PARMS; ++i ) {
+		GLint loc = qglGetUniformLocation( program, va( "samp%d", i ) );
+		if ( loc != -1 ) {
+			qglUniform1i( loc, i );
+		}
+	}
+
+	idStr programName = vertexShaders[ vertexShaderIndex ].name;
+	programName.StripFileExtension();
+	prog.name = programName;
+	prog.progId = program;
+	prog.fragmentShaderIndex = fragmentShaderIndex;
+	prog.vertexShaderIndex = vertexShaderIndex;
+}
+
+/*
+================================================================================================
+idRenderProgManager::ZeroUniforms
+================================================================================================
+*/
+void idRenderProgManager::ZeroUniforms() {
+	memset( glslUniforms.Ptr(), 0, glslUniforms.Allocated() );
+}
+
diff --git a/neo/renderer/RenderSystem.cpp b/neo/renderer/RenderSystem.cpp
index aa71820..d085517 100644
--- a/neo/renderer/RenderSystem.cpp
+++ b/neo/renderer/RenderSystem.cpp
@@ -117,9 +117,6 @@ static void R_PerformanceCounters( void ) {
 		int	m1 = frameData ? frameData->memoryHighwater : 0;
 		common->Printf( "frameData: %i (%i)\n", R_CountFrameData(), m1 );
 	}
-	if ( r_showLightScale.GetBool() ) {
-		common->Printf( "lightScale: %f\n", backEnd.pc.maxLightValue );
-	}
 
 	memset( &tr.pc, 0, sizeof( tr.pc ) );
 	memset( &backEnd.pc, 0, sizeof( backEnd.pc ) );
@@ -287,6 +284,7 @@ static void R_CheckCvars( void ) {
 		r_gamma.ClearModified();
 		r_brightness.ClearModified();
 		R_SetColorMappings();
+		GLimp_SetGamma( tr.gammaTable, tr.gammaTable, tr.gammaTable );
 	}
 }
 
@@ -532,62 +530,6 @@ void idRenderSystemLocal::DrawBigStringExt( int x, int y, const char *string, co
 //======================================================================================
 
 /*
-==================
-SetBackEndRenderer
-
-Check for changes in the back end renderSystem, possibly invalidating cached data
-==================
-*/
-void idRenderSystemLocal::SetBackEndRenderer() {
-	if ( !r_renderer.IsModified() ) {
-		return;
-	}
-
-	bool oldVPstate = backEndRendererHasVertexPrograms;
-
-	backEndRenderer = BE_BAD;
-
-	if ( idStr::Icmp( r_renderer.GetString(), "arb2" ) == 0 ) {
-		if ( glConfig.allowARB2Path ) {
-			backEndRenderer = BE_ARB2;
-		}
-	}
-
-	// fallback
-	if ( backEndRenderer == BE_BAD ) {
-		// choose the best
-		if ( glConfig.allowARB2Path ) {
-			backEndRenderer = BE_ARB2;
-		}
-	}
-
-	backEndRendererHasVertexPrograms = false;
-	backEndRendererMaxLight = 1.0;
-
-	switch( backEndRenderer ) {
-	case BE_ARB2:
-		common->Printf( "using ARB2 renderSystem\n" );
-		backEndRendererHasVertexPrograms = true;
-		backEndRendererMaxLight = 999;
-		break;
-	default:
-		common->FatalError( "SetbackEndRenderer: bad back end" );
-	}
-
-	// clear the vertex cache if we are changing between
-	// using vertex programs and not, because specular and
-	// shadows will be different data
-	if ( oldVPstate != backEndRendererHasVertexPrograms ) {
-		vertexCache.PurgeAll();
-		if ( primaryWorld ) {
-			primaryWorld->FreeInteractions();
-		}
-	}
-
-	r_renderer.ClearModified();
-}
-
-/*
 ====================
 BeginFrame
 ====================
@@ -595,13 +537,10 @@ BeginFrame
 void idRenderSystemLocal::BeginFrame( int windowWidth, int windowHeight ) {
 	setBufferCommand_t	*cmd;
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
-	// determine which back end we will use
-	SetBackEndRenderer();
-
 	guiModel->Clear();
 
 	// for the larger-than-window tiled rendering screenshots
@@ -676,7 +615,7 @@ Returns the number of msec spent in the back end
 void idRenderSystemLocal::EndFrame( int *frontEndMsec, int *backEndMsec ) {
 	emptyCommand_t *cmd;
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -768,7 +707,7 @@ down, but still valid.
 ================
 */
 void	idRenderSystemLocal::CropRenderSize( int width, int height, bool makePowerOfTwo, bool forceDimensions ) {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -848,7 +787,7 @@ UnCrop
 ================
 */
 void idRenderSystemLocal::UnCrop() {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -878,7 +817,7 @@ CaptureRenderToImage
 ================
 */
 void idRenderSystemLocal::CaptureRenderToImage( const char *imageName ) {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 	guiModel->EmitFullScreen();
@@ -918,7 +857,7 @@ CaptureRenderToFile
 ==============
 */
 void idRenderSystemLocal::CaptureRenderToFile( const char *fileName, bool fixAlpha ) {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
diff --git a/neo/renderer/RenderSystem.h b/neo/renderer/RenderSystem.h
index 253b9eb..e6c8085 100644
--- a/neo/renderer/RenderSystem.h
+++ b/neo/renderer/RenderSystem.h
@@ -42,6 +42,12 @@ If you have questions concerning this license or the applicable additional terms
 */
 
 
+enum graphicsVendor_t {
+	VENDOR_NVIDIA,
+	VENDOR_AMD,
+	VENDOR_INTEL
+};
+
 // Contains variables specific to the OpenGL configuration being run right now.
 // These are constant once the OpenGL subsystem is initialized.
 typedef struct glconfig_s {
@@ -49,35 +55,37 @@ typedef struct glconfig_s {
 	const char			*vendor_string;
 	const char			*version_string;
 	const char			*extensions_string;
+	const char 			*shading_language_string;
 
 	float				glVersion;				// atof( version_string )
-
+	graphicsVendor_t	vendor;
 
 	int					maxTextureSize;			// queried from GL
 	int					maxTextureUnits;
 	int					maxTextureCoords;
 	int					maxTextureImageUnits;
+	int					uniformBufferOffsetAlignment;
 	float				maxTextureAnisotropy;
 
 	int					colorBits, depthBits, stencilBits;
 
 	bool				multitextureAvailable;
+	bool				directStateAccess;
 	bool				textureCompressionAvailable;
 	bool				anisotropicAvailable;
 	bool				textureLODBiasAvailable;
-	bool				textureEnvAddAvailable;
-	bool				textureEnvCombineAvailable;
-	bool				registerCombinersAvailable;
-	bool				cubeMapAvailable;
-	bool				envDot3Available;
-	bool				texture3DAvailable;
-	bool				sharedTexturePaletteAvailable;
 	bool				ARBVertexBufferObjectAvailable;
 	bool				ARBVertexProgramAvailable;
+	bool				mapBufferRangeAvailable;
 	bool				ARBFragmentProgramAvailable;
 	bool				twoSidedStencilAvailable;
-	bool				textureNonPowerOfTwoAvailable;
 	bool				depthBoundsTestAvailable;
+	bool				glslAvailable;
+	bool				uniformBufferAvailable;
+	bool				syncAvailable;
+	bool				timerQueryAvailable;
+	bool				occlusionQueryAvailable;
+	bool				debugOutputAvailable;
 
 	int					vidWidth, vidHeight;	// passed to R_BeginFrame
 
@@ -86,8 +94,6 @@ typedef struct glconfig_s {
 	bool				isFullscreen;
 
 	bool				allowARB2Path;
-
-	bool				isInitialized;
 } glconfig_t;
 
 
diff --git a/neo/renderer/RenderSystem_init.cpp b/neo/renderer/RenderSystem_init.cpp
index 5b443fb..5c35d9f 100644
--- a/neo/renderer/RenderSystem_init.cpp
+++ b/neo/renderer/RenderSystem_init.cpp
@@ -46,36 +46,43 @@ If you have questions concerning this license or the applicable additional terms
 #endif
 
 // functions that are not called every frame
-
 glconfig_t	glConfig;
 
-const char *r_rendererArgs[] = { "best", "arb2", NULL };
+static void GfxInfo_f( void );
 
-idCVar r_inhibitFragmentProgram( "r_inhibitFragmentProgram", "0", CVAR_RENDERER | CVAR_BOOL, "ignore the fragment program extension" );
-idCVar r_useLightPortalFlow( "r_useLightPortalFlow", "1", CVAR_RENDERER | CVAR_BOOL, "use a more precise area reference determination" );
+idCVar r_requestStereoPixelFormat( "r_requestStereoPixelFormat", "1", CVAR_RENDERER, "Ask for a stereo GL pixel format on startup" );
+idCVar r_debugContext( "r_debugContext", "0", CVAR_RENDERER, "Enable various levels of context debug." );
+idCVar r_glDriver( "r_glDriver", "", CVAR_RENDERER, "\"opengl32\", etc." );
 idCVar r_multiSamples( "r_multiSamples", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "number of antialiasing samples" );
-idCVar r_mode( "r_mode", "3", CVAR_ARCHIVE | CVAR_RENDERER | CVAR_INTEGER, "video mode number" );
-idCVar r_displayRefresh( "r_displayRefresh", "0", CVAR_RENDERER | CVAR_INTEGER | CVAR_NOCHEAT, "optional display refresh rate option for vid mode", 0.0f, 200.0f );
-idCVar r_fullscreen( "r_fullscreen", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_BOOL, "0 = windowed, 1 = full screen" );
-idCVar r_customWidth( "r_customWidth", "720", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "custom screen width. set r_mode to -1 to activate" );
-idCVar r_customHeight( "r_customHeight", "486", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "custom screen height. set r_mode to -1 to activate" );
-idCVar r_singleTriangle( "r_singleTriangle", "0", CVAR_RENDERER | CVAR_BOOL, "only draw a single triangle per primitive" );
+idCVar r_vidMode( "r_vidMode", "0", CVAR_ARCHIVE | CVAR_RENDERER | CVAR_INTEGER, "fullscreen video mode number" );
+idCVar r_displayRefresh( "r_displayRefresh", "0", CVAR_RENDERER | CVAR_INTEGER | CVAR_NOCHEAT, "optional display refresh rate option for vid mode", 0.0f, 240.0f );
+#ifdef WIN32
+idCVar r_fullscreen( "r_fullscreen", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "0 = windowed, 1 = full screen on monitor 1, 2 = full screen on monitor 2, etc" );
+#else
+// DG: add mode -2 for SDL, also defaulting to windowed mode, as that causes less trouble on linux
+idCVar r_fullscreen( "r_fullscreen", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "-2 = use current monitor, -1 = (reserved), 0 = windowed, 1 = full screen on monitor 1, 2 = full screen on monitor 2, etc" );
+// DG end
+#endif
+idCVar r_customWidth( "r_customWidth", "1280", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "custom screen width. set r_vidMode to -1 to activate" );
+idCVar r_customHeight( "r_customHeight", "720", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "custom screen height. set r_vidMode to -1 to activate" );
+idCVar r_windowX( "r_windowX", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "Non-fullscreen parameter" );
+idCVar r_windowY( "r_windowY", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "Non-fullscreen parameter" );
+idCVar r_windowWidth( "r_windowWidth", "1280", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "Non-fullscreen parameter" );
+idCVar r_windowHeight( "r_windowHeight", "720", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "Non-fullscreen parameter" );
+
 idCVar r_checkBounds( "r_checkBounds", "0", CVAR_RENDERER | CVAR_BOOL, "compare all surface bounds with precalculated ones" );
 
 idCVar r_useConstantMaterials( "r_useConstantMaterials", "1", CVAR_RENDERER | CVAR_BOOL, "use pre-calculated material registers if possible" );
 idCVar r_useSilRemap( "r_useSilRemap", "1", CVAR_RENDERER | CVAR_BOOL, "consider verts with the same XYZ, but different ST the same for shadows" );
 idCVar r_useNodeCommonChildren( "r_useNodeCommonChildren", "1", CVAR_RENDERER | CVAR_BOOL, "stop pushing reference bounds early when possible" );
 idCVar r_useShadowProjectedCull( "r_useShadowProjectedCull", "1", CVAR_RENDERER | CVAR_BOOL, "discard triangles outside light volume before shadowing" );
-idCVar r_useShadowVertexProgram( "r_useShadowVertexProgram", "1", CVAR_RENDERER | CVAR_BOOL, "do the shadow projection in the vertex program on capable cards" );
 idCVar r_useShadowSurfaceScissor( "r_useShadowSurfaceScissor", "1", CVAR_RENDERER | CVAR_BOOL, "scissor shadows by the scissor rect of the interaction surfaces" );
 idCVar r_useInteractionTable( "r_useInteractionTable", "1", CVAR_RENDERER | CVAR_BOOL, "create a full entityDefs * lightDefs table to make finding interactions faster" );
 idCVar r_useTurboShadow( "r_useTurboShadow", "1", CVAR_RENDERER | CVAR_BOOL, "use the infinite projection with W technique for dynamic shadows" );
 idCVar r_useTwoSidedStencil( "r_useTwoSidedStencil", "1", CVAR_RENDERER | CVAR_BOOL, "do stencil shadows in one pass with different ops on each side" );
 idCVar r_useDeferredTangents( "r_useDeferredTangents", "1", CVAR_RENDERER | CVAR_BOOL, "defer tangents calculations after deform" );
 idCVar r_useCachedDynamicModels( "r_useCachedDynamicModels", "1", CVAR_RENDERER | CVAR_BOOL, "cache snapshots of dynamic models" );
-
-idCVar r_useVertexBuffers( "r_useVertexBuffers", "1", CVAR_RENDERER | CVAR_INTEGER, "use ARB_vertex_buffer_object for vertexes", 0, 1, idCmdSystem::ArgCompletion_Integer<0,1>  );
-idCVar r_useIndexBuffers( "r_useIndexBuffers", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "use ARB_vertex_buffer_object for indexes", 0, 1, idCmdSystem::ArgCompletion_Integer<0,1>  );
+idCVar r_useLightPortalFlow( "r_useLightPortalFlow", "1", CVAR_RENDERER | CVAR_BOOL, "use a more precise area reference determination" );
 
 idCVar r_useStateCaching( "r_useStateCaching", "1", CVAR_RENDERER | CVAR_BOOL, "avoid redundant state changes in GL_*() calls" );
 idCVar r_useInfiniteFarZ( "r_useInfiniteFarZ", "1", CVAR_RENDERER | CVAR_BOOL, "use the no-far-clip-plane trick" );
@@ -84,24 +91,20 @@ idCVar r_znear( "r_znear", "3", CVAR_RENDERER | CVAR_FLOAT, "near Z clip plane d
 
 idCVar r_ignoreGLErrors( "r_ignoreGLErrors", "1", CVAR_RENDERER | CVAR_BOOL, "ignore GL errors" );
 idCVar r_finish( "r_finish", "0", CVAR_RENDERER | CVAR_BOOL, "force a call to glFinish() every frame" );
-idCVar r_swapInterval( "r_swapInterval", "0", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "changes the GL swap interval" );
+idCVar r_swapInterval( "r_swapInterval", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_INTEGER, "changes wglSwapIntarval" );
 
 idCVar r_gamma( "r_gamma", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_FLOAT, "changes gamma tables", 0.5f, 3.0f );
 idCVar r_brightness( "r_brightness", "1", CVAR_RENDERER | CVAR_ARCHIVE | CVAR_FLOAT, "changes gamma tables", 0.5f, 2.0f );
 
-idCVar r_renderer( "r_renderer", "best", CVAR_RENDERER | CVAR_ARCHIVE, "hardware specific renderer path to use", r_rendererArgs, idCmdSystem::ArgCompletion_String<r_rendererArgs> );
-
 idCVar r_jitter( "r_jitter", "0", CVAR_RENDERER | CVAR_BOOL, "randomly subpixel jitter the projection matrix" );
 
 idCVar r_skipSuppress( "r_skipSuppress", "0", CVAR_RENDERER | CVAR_BOOL, "ignore the per-view suppressions" );
 idCVar r_skipPostProcess( "r_skipPostProcess", "0", CVAR_RENDERER | CVAR_BOOL, "skip all post-process renderings" );
-idCVar r_skipLightScale( "r_skipLightScale", "0", CVAR_RENDERER | CVAR_BOOL, "don't do any post-interaction light scaling, makes things dim on low-dynamic range cards" );
 idCVar r_skipInteractions( "r_skipInteractions", "0", CVAR_RENDERER | CVAR_BOOL, "skip all light/surface interaction drawing" );
 idCVar r_skipDynamicTextures( "r_skipDynamicTextures", "0", CVAR_RENDERER | CVAR_BOOL, "don't dynamically create textures" );
 idCVar r_skipCopyTexture( "r_skipCopyTexture", "0", CVAR_RENDERER | CVAR_BOOL, "do all rendering, but don't actually copyTexSubImage2D" );
 idCVar r_skipBackEnd( "r_skipBackEnd", "0", CVAR_RENDERER | CVAR_BOOL, "don't draw anything" );
 idCVar r_skipRender( "r_skipRender", "0", CVAR_RENDERER | CVAR_BOOL, "skip 3D rendering, but pass 2D" );
-idCVar r_skipRenderContext( "r_skipRenderContext", "0", CVAR_RENDERER | CVAR_BOOL, "NULL the rendering context during backend 3D rendering" );
 idCVar r_skipTranslucent( "r_skipTranslucent", "0", CVAR_RENDERER | CVAR_BOOL, "skip the translucent interaction rendering" );
 idCVar r_skipAmbient( "r_skipAmbient", "0", CVAR_RENDERER | CVAR_BOOL, "bypasses all non-interaction drawing" );
 idCVar r_skipNewAmbient( "r_skipNewAmbient", "0", CVAR_RENDERER | CVAR_BOOL | CVAR_ARCHIVE, "bypasses all vertex/fragment program ambient drawing" );
@@ -129,6 +132,7 @@ idCVar r_useInteractionCulling( "r_useInteractionCulling", "1", CVAR_RENDERER |
 idCVar r_useInteractionScissors( "r_useInteractionScissors", "2", CVAR_RENDERER | CVAR_INTEGER, "1 = use a custom scissor rectangle for each shadow interaction, 2 = also crop using portal scissors", -2, 2, idCmdSystem::ArgCompletion_Integer<-2,2> );
 idCVar r_useShadowCulling( "r_useShadowCulling", "1", CVAR_RENDERER | CVAR_BOOL, "try to cull shadows from partially visible lights" );
 idCVar r_useFrustumFarDistance( "r_useFrustumFarDistance", "0", CVAR_RENDERER | CVAR_FLOAT, "if != 0 force the view frustum far distance to this distance" );
+idCVar r_logFile( "r_logFile", "0", CVAR_RENDERER | CVAR_INTEGER, "number of frames to emit GL logs" );
 idCVar r_clear( "r_clear", "2", CVAR_RENDERER, "force screen clear every frame, 1 = purple, 2 = black, 'r g b' = custom" );
 idCVar r_offsetFactor( "r_offsetfactor", "0", CVAR_RENDERER | CVAR_FLOAT, "polygon offset parameter" );
 idCVar r_offsetUnits( "r_offsetunits", "-600", CVAR_RENDERER | CVAR_FLOAT, "polygon offset parameter" );
@@ -140,18 +144,16 @@ idCVar r_skipGuiShaders( "r_skipGuiShaders", "0", CVAR_RENDERER | CVAR_INTEGER,
 idCVar r_skipParticles( "r_skipParticles", "0", CVAR_RENDERER | CVAR_INTEGER, "1 = skip all particle systems", 0, 1, idCmdSystem::ArgCompletion_Integer<0,1> );
 idCVar r_subviewOnly( "r_subviewOnly", "0", CVAR_RENDERER | CVAR_BOOL, "1 = don't render main view, allowing subviews to be debugged" );
 idCVar r_shadows( "r_shadows", "1", CVAR_RENDERER | CVAR_BOOL  | CVAR_ARCHIVE, "enable shadows" );
-idCVar r_testARBProgram( "r_testARBProgram", "0", CVAR_RENDERER | CVAR_BOOL, "experiment with vertex/fragment programs" );
 idCVar r_testGamma( "r_testGamma", "0", CVAR_RENDERER | CVAR_FLOAT, "if > 0 draw a grid pattern to test gamma levels", 0, 195 );
 idCVar r_testGammaBias( "r_testGammaBias", "0", CVAR_RENDERER | CVAR_FLOAT, "if > 0 draw a grid pattern to test gamma levels" );
 idCVar r_testStepGamma( "r_testStepGamma", "0", CVAR_RENDERER | CVAR_FLOAT, "if > 0 draw a grid pattern to test gamma levels" );
 idCVar r_lightScale( "r_lightScale", "2", CVAR_RENDERER | CVAR_FLOAT, "all light intensities are multiplied by this" );
 idCVar r_lightSourceRadius( "r_lightSourceRadius", "0", CVAR_RENDERER | CVAR_FLOAT, "for soft-shadow sampling" );
-idCVar r_flareSize( "r_flareSize", "1", CVAR_RENDERER | CVAR_FLOAT, "scale the flare deforms from the material def" );
+idCVar r_flareSize( "r_flareSize", "1", CVAR_RENDERER | CVAR_FLOAT, "scale the flare deforms from the material def" ); 
 
 idCVar r_useExternalShadows( "r_useExternalShadows", "1", CVAR_RENDERER | CVAR_INTEGER, "1 = skip drawing caps when outside the light volume, 2 = force to no caps for testing", 0, 2, idCmdSystem::ArgCompletion_Integer<0,2> );
 idCVar r_useOptimizedShadows( "r_useOptimizedShadows", "1", CVAR_RENDERER | CVAR_BOOL, "use the dmap generated static shadow volumes" );
 idCVar r_useScissor( "r_useScissor", "1", CVAR_RENDERER | CVAR_BOOL, "scissor clip as portals and lights are processed" );
-idCVar r_useCombinerDisplayLists( "r_useCombinerDisplayLists", "1", CVAR_RENDERER | CVAR_BOOL | CVAR_NOCHEAT, "put all nvidia register combiner programming in display lists" );
 idCVar r_useDepthBoundsTest( "r_useDepthBoundsTest", "1", CVAR_RENDERER | CVAR_BOOL, "use depth bounds test to reduce shadow fill" );
 
 idCVar r_screenFraction( "r_screenFraction", "100", CVAR_RENDERER | CVAR_INTEGER, "for testing fill rate, the resolution of the entire screen can be changed" );
@@ -173,7 +175,6 @@ idCVar r_showVertexColor( "r_showVertexColor", "0", CVAR_RENDERER | CVAR_BOOL, "
 idCVar r_showUpdates( "r_showUpdates", "0", CVAR_RENDERER | CVAR_BOOL, "report entity and light updates and ref counts" );
 idCVar r_showDemo( "r_showDemo", "0", CVAR_RENDERER | CVAR_BOOL, "report reads and writes to the demo file" );
 idCVar r_showDynamic( "r_showDynamic", "0", CVAR_RENDERER | CVAR_BOOL, "report stats on dynamic surface generation" );
-idCVar r_showLightScale( "r_showLightScale", "0", CVAR_RENDERER | CVAR_BOOL, "report the scale factor applied to drawing for overbrights" );
 idCVar r_showDefs( "r_showDefs", "0", CVAR_RENDERER | CVAR_BOOL, "report the number of modeDefs and lightDefs in view" );
 idCVar r_showTrace( "r_showTrace", "0", CVAR_RENDERER | CVAR_INTEGER, "show the intersection of an eye trace with the world", idCmdSystem::ArgCompletion_Integer<0,2> );
 idCVar r_showIntensity( "r_showIntensity", "0", CVAR_RENDERER | CVAR_BOOL, "draw the screen colors based on intensity, red = 0, green = 128, blue = 255" );
@@ -221,21 +222,20 @@ idCVar r_materialOverride( "r_materialOverride", "", CVAR_RENDERER, "overrides a
 
 idCVar r_debugRenderToTexture( "r_debugRenderToTexture", "0", CVAR_RENDERER | CVAR_INTEGER, "" );
 
+idCVar stereoRender_enable( "stereoRender_enable", "0", CVAR_INTEGER | CVAR_ARCHIVE, "1 = side-by-side compressed, 2 = top and bottom compressed, 3 = side-by-side, 4 = 720 frame packed, 5 = interlaced, 6 = OpenGL quad buffer" );
+idCVar stereoRender_swapEyes( "stereoRender_swapEyes", "0", CVAR_BOOL | CVAR_ARCHIVE, "reverse eye adjustments" );
+idCVar stereoRender_deGhost( "stereoRender_deGhost", "0.05", CVAR_FLOAT | CVAR_ARCHIVE, "subtract from opposite eye to reduce ghosting" );
+
 // define qgl functions
 #define QGLPROC(name, rettype, args) rettype (APIENTRYP q##name) args;
-#include "renderer/qgl_proc.h"
+#include "../renderer/qgl_proc.h"
 
-void ( APIENTRY * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
-void ( APIENTRY * qglMultiTexCoord2fvARB )( GLenum texture, GLfloat *st );
+// GL_ARB_multitexture
 void ( APIENTRY * qglActiveTextureARB )( GLenum texture );
 void ( APIENTRY * qglClientActiveTextureARB )( GLenum texture );
 
-void (APIENTRY *qglTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
-
-void (APIENTRY * qglColorTableEXT)( int, int, int, int, int, const void * );
-
-// EXT_stencil_two_side
-PFNGLACTIVESTENCILFACEEXTPROC			qglActiveStencilFaceEXT;
+// GL_EXT_direct_state_access
+PFNGLBINDMULTITEXTUREEXTPROC			qglBindMultiTextureEXT;
 
 // ARB_texture_compression
 PFNGLCOMPRESSEDTEXIMAGE2DARBPROC		qglCompressedTexImage2DARB;
@@ -243,6 +243,7 @@ PFNGLGETCOMPRESSEDTEXIMAGEARBPROC		qglGetCompressedTexImageARB;
 
 // ARB_vertex_buffer_object
 PFNGLBINDBUFFERARBPROC					qglBindBufferARB;
+PFNGLBINDBUFFERRANGEPROC				qglBindBufferRange;
 PFNGLDELETEBUFFERSARBPROC				qglDeleteBuffersARB;
 PFNGLGENBUFFERSARBPROC					qglGenBuffersARB;
 PFNGLISBUFFERARBPROC					qglIsBufferARB;
@@ -254,6 +255,9 @@ PFNGLUNMAPBUFFERARBPROC					qglUnmapBufferARB;
 PFNGLGETBUFFERPARAMETERIVARBPROC		qglGetBufferParameterivARB;
 PFNGLGETBUFFERPOINTERVARBPROC			qglGetBufferPointervARB;
 
+// GL_ARB_map_buffer_range
+PFNGLMAPBUFFERRANGEPROC					qglMapBufferRange;
+
 // ARB_vertex_program / ARB_fragment_program
 PFNGLVERTEXATTRIBPOINTERARBPROC			qglVertexAttribPointerARB;
 PFNGLENABLEVERTEXATTRIBARRAYARBPROC		qglEnableVertexAttribArrayARB;
@@ -267,6 +271,74 @@ PFNGLPROGRAMLOCALPARAMETER4FVARBPROC	qglProgramLocalParameter4fvARB;
 // GL_EXT_depth_bounds_test
 PFNGLDEPTHBOUNDSEXTPROC                 qglDepthBoundsEXT;
 
+// separate stencil
+PFNGLSTENCILOPSEPARATEPROC				qglStencilOpSeparate;
+
+// GLSL / OpenGL 2.0
+PFNGLCREATESHADERPROC					qglCreateShader;
+PFNGLDELETESHADERPROC					qglDeleteShader;
+PFNGLSHADERSOURCEPROC					qglShaderSource;
+PFNGLCOMPILESHADERPROC					qglCompileShader;
+PFNGLGETSHADERIVPROC					qglGetShaderiv;
+PFNGLGETSHADERINFOLOGPROC				qglGetShaderInfoLog;
+PFNGLCREATEPROGRAMPROC					qglCreateProgram;
+PFNGLDELETEPROGRAMPROC					qglDeleteProgram;
+PFNGLATTACHSHADERPROC					qglAttachShader;
+PFNGLDETACHSHADERPROC					qglDetachShader;
+PFNGLLINKPROGRAMPROC					qglLinkProgram;
+PFNGLUSEPROGRAMPROC						qglUseProgram;
+PFNGLGETPROGRAMIVPROC					qglGetProgramiv;
+PFNGLGETPROGRAMINFOLOGPROC				qglGetProgramInfoLog;
+PFNGLPROGRAMPARAMETERIPROC				qglProgramParameteri;
+PFNGLBINDATTRIBLOCATIONPROC				qglBindAttribLocation;
+PFNGLGETUNIFORMLOCATIONPROC				qglGetUniformLocation;
+PFNGLUNIFORM1IPROC						qglUniform1i;
+PFNGLUNIFORM4FVPROC						qglUniform4fv;
+
+// GL_ARB_uniform_buffer_object
+PFNGLGETUNIFORMBLOCKINDEXPROC			qglGetUniformBlockIndex;
+PFNGLUNIFORMBLOCKBINDINGPROC			qglUniformBlockBinding;
+
+// GL_ARB_sync
+PFNGLFENCESYNCPROC						qglFenceSync;
+PFNGLISSYNCPROC							qglIsSync;
+PFNGLCLIENTWAITSYNCPROC					qglClientWaitSync;
+PFNGLDELETESYNCPROC						qglDeleteSync;
+
+// GL_ARB_occlusion_query
+PFNGLGENQUERIESARBPROC					qglGenQueriesARB;
+PFNGLDELETEQUERIESARBPROC				qglDeleteQueriesARB;
+PFNGLISQUERYARBPROC						qglIsQueryARB;
+PFNGLBEGINQUERYARBPROC					qglBeginQueryARB;
+PFNGLENDQUERYARBPROC					qglEndQueryARB;
+PFNGLGETQUERYIVARBPROC					qglGetQueryivARB;
+PFNGLGETQUERYOBJECTIVARBPROC			qglGetQueryObjectivARB;
+PFNGLGETQUERYOBJECTUIVARBPROC			qglGetQueryObjectuivARB;
+
+// GL_ARB_timer_query / GL_EXT_timer_query
+PFNGLGETQUERYOBJECTUI64VEXTPROC			qglGetQueryObjectui64vEXT;
+
+// GL_ARB_debug_output
+PFNGLDEBUGMESSAGECONTROLARBPROC			qglDebugMessageControlARB;
+PFNGLDEBUGMESSAGEINSERTARBPROC			qglDebugMessageInsertARB;
+PFNGLDEBUGMESSAGECALLBACKARBPROC		qglDebugMessageCallbackARB;
+PFNGLGETDEBUGMESSAGELOGARBPROC			qglGetDebugMessageLogARB;
+
+PFNGLGETSTRINGIPROC						qglGetStringi;
+
+/*
+========================
+glBindMultiTextureEXT
+
+As of 2011/09/16 the Intel drivers for "Sandy Bridge" and "Ivy Bridge" integrated graphics do not support this extension.
+========================
+*/
+void APIENTRY glBindMultiTextureEXT( GLenum texunit, GLenum target, GLuint texture ) {
+	qglActiveTextureARB( texunit );
+	qglBindTexture( target, texture );
+}
+
+
 /*
 =================
 R_CheckExtension
@@ -282,6 +354,26 @@ bool R_CheckExtension( const char *name ) {
 	return true;
 }
 
+
+/*
+========================
+DebugCallback
+
+For ARB_debug_output
+========================
+*/
+//static void CALLBACK DebugCallback( unsigned int source, unsigned int type,
+static void DebugCallback( unsigned int source, unsigned int type,
+	unsigned int id, unsigned int severity, int length, const char * message, void * userParam ) {
+	// it probably isn't safe to do an idLib::Printf at this point
+
+#if defined(_WIN32)
+	OutputDebugString( message );
+	OutputDebugString( "\n" );
+#else
+	printf( "%s\n", message );
+#endif
+}
 /*
 ==================
 R_CheckPortableExtensions
@@ -290,14 +382,25 @@ R_CheckPortableExtensions
 */
 static void R_CheckPortableExtensions( void ) {
 	glConfig.glVersion = atof( glConfig.version_string );
+	const char * badVideoCard = common->GetLanguageDict()->GetString( "#str_06780" );
+	if ( glConfig.glVersion < 2.0f ) {
+		common->FatalError( badVideoCard );
+	}
+
+	if ( idStr::Icmpn( glConfig.renderer_string, "ATI ", 4 ) == 0 || idStr::Icmpn( glConfig.renderer_string, "AMD ", 4 ) == 0 ) {
+		glConfig.vendor = VENDOR_AMD;
+	} else if ( idStr::Icmpn( glConfig.renderer_string, "NVIDIA", 6 ) == 0 ) {
+		glConfig.vendor = VENDOR_NVIDIA;
+	} else if ( idStr::Icmpn( glConfig.renderer_string, "Intel", 5 ) == 0 ) {
+		glConfig.vendor = VENDOR_INTEL;
+	}
 
 	// GL_ARB_multitexture
 	glConfig.multitextureAvailable = R_CheckExtension( "GL_ARB_multitexture" );
 	if ( glConfig.multitextureAvailable ) {
-		qglMultiTexCoord2fARB = (void(APIENTRY *)(GLenum, GLfloat, GLfloat))GLimp_ExtensionPointer( "glMultiTexCoord2fARB" );
-		qglMultiTexCoord2fvARB = (void(APIENTRY *)(GLenum, GLfloat *))GLimp_ExtensionPointer( "glMultiTexCoord2fvARB" );
 		qglActiveTextureARB = (void(APIENTRY *)(GLenum))GLimp_ExtensionPointer( "glActiveTextureARB" );
 		qglClientActiveTextureARB = (void(APIENTRY *)(GLenum))GLimp_ExtensionPointer( "glClientActiveTextureARB" );
+
 		qglGetIntegerv( GL_MAX_TEXTURE_UNITS_ARB, (GLint *)&glConfig.maxTextureUnits );
 		if ( glConfig.maxTextureUnits > MAX_MULTITEXTURE_UNITS ) {
 			glConfig.maxTextureUnits = MAX_MULTITEXTURE_UNITS;
@@ -309,20 +412,13 @@ static void R_CheckPortableExtensions( void ) {
 		qglGetIntegerv( GL_MAX_TEXTURE_IMAGE_UNITS_ARB, (GLint *)&glConfig.maxTextureImageUnits );
 	}
 
-	// GL_ARB_texture_env_combine
-	glConfig.textureEnvCombineAvailable = R_CheckExtension( "GL_ARB_texture_env_combine" );
-
-	// GL_ARB_texture_cube_map
-	glConfig.cubeMapAvailable = R_CheckExtension( "GL_ARB_texture_cube_map" );
-
-	// GL_ARB_texture_env_dot3
-	glConfig.envDot3Available = R_CheckExtension( "GL_ARB_texture_env_dot3" );
-
-	// GL_ARB_texture_env_add
-	glConfig.textureEnvAddAvailable = R_CheckExtension( "GL_ARB_texture_env_add" );
-
-	// GL_ARB_texture_non_power_of_two
-	glConfig.textureNonPowerOfTwoAvailable = R_CheckExtension( "GL_ARB_texture_non_power_of_two" );
+	// GL_EXT_direct_state_access
+	glConfig.directStateAccess = R_CheckExtension( "GL_EXT_direct_state_access" );
+	if ( glConfig.directStateAccess ) {
+		qglBindMultiTextureEXT = (PFNGLBINDMULTITEXTUREEXTPROC)GLimp_ExtensionPointer( "glBindMultiTextureEXT" );
+	} else {
+		qglBindMultiTextureEXT = glBindMultiTextureEXT;
+	}
 
 	// GL_ARB_texture_compression + GL_S3_s3tc
 	// DRI drivers may have GL_ARB_texture_compression but no GL_EXT_texture_compression_s3tc
@@ -346,28 +442,13 @@ static void R_CheckPortableExtensions( void ) {
 	// GL_EXT_texture_lod_bias
 	// The actual extension is broken as specificed, storing the state in the texture unit instead
 	// of the texture object.  The behavior in GL 1.4 is the behavior we use.
-	if ( glConfig.glVersion >= 1.4 || R_CheckExtension( "GL_EXT_texture_lod" ) ) {
-		common->Printf( "...using %s\n", "GL_1.4_texture_lod_bias" );
-		glConfig.textureLODBiasAvailable = true;
+	glConfig.textureLODBiasAvailable = ( glConfig.glVersion >= 1.4 || R_CheckExtension( "GL_EXT_texture_lod_bias" ) );
+	if ( glConfig.textureLODBiasAvailable ) {
+		common->Printf( "...using %s\n", "GL_EXT_texture_lod_bias" );
 	} else {
-		common->Printf( "X..%s not found\n", "GL_1.4_texture_lod_bias" );
-		glConfig.textureLODBiasAvailable = false;
-	}
-
-	// GL_EXT_shared_texture_palette
-	glConfig.sharedTexturePaletteAvailable = R_CheckExtension( "GL_EXT_shared_texture_palette" );
-	if ( glConfig.sharedTexturePaletteAvailable ) {
-		qglColorTableEXT = ( void ( APIENTRY * ) ( int, int, int, int, int, const void * ) ) GLimp_ExtensionPointer( "glColorTableEXT" );
-	}
-
-	// GL_EXT_texture3D (not currently used for anything)
-	glConfig.texture3DAvailable = R_CheckExtension( "GL_EXT_texture3D" );
-	if ( glConfig.texture3DAvailable ) {
-		qglTexImage3D =
-			(void (APIENTRY *)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *) )
-			GLimp_ExtensionPointer( "glTexImage3D" );
+		common->Printf( "X..%s not found\n", "GL_EXT_texture_lod_bias" );
 	}
-
+	
 	// EXT_stencil_wrap
 	// This isn't very important, but some pathological case might cause a clamp error and give a shadow bug.
 	// Nvidia also believes that future hardware may be able to run faster with this enabled to avoid the
@@ -380,15 +461,19 @@ static void R_CheckPortableExtensions( void ) {
 		tr.stencilDecr = GL_DECR;
 	}
 
-	// GL_EXT_stencil_two_side
-	glConfig.twoSidedStencilAvailable = R_CheckExtension( "GL_EXT_stencil_two_side" );
-	if ( glConfig.twoSidedStencilAvailable )
-		qglActiveStencilFaceEXT = (PFNGLACTIVESTENCILFACEEXTPROC)GLimp_ExtensionPointer( "glActiveStencilFaceEXT" );
+	// separate stencil (part of OpenGL 2.0 spec)
+	qglStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)GLimp_ExtensionPointer( "glStencilOpSeparate" );
+	if( qglStencilOpSeparate ) {
+		glConfig.twoSidedStencilAvailable = true;
+	} else {
+		glConfig.twoSidedStencilAvailable = false;
+	}
 
 	// ARB_vertex_buffer_object
 	glConfig.ARBVertexBufferObjectAvailable = R_CheckExtension( "GL_ARB_vertex_buffer_object" );
 	if(glConfig.ARBVertexBufferObjectAvailable) {
 		qglBindBufferARB = (PFNGLBINDBUFFERARBPROC)GLimp_ExtensionPointer( "glBindBufferARB");
+		qglBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)GLimp_ExtensionPointer( "glBindBufferRange" );
 		qglDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)GLimp_ExtensionPointer( "glDeleteBuffersARB");
 		qglGenBuffersARB = (PFNGLGENBUFFERSARBPROC)GLimp_ExtensionPointer( "glGenBuffersARB");
 		qglIsBufferARB = (PFNGLISBUFFERARBPROC)GLimp_ExtensionPointer( "glIsBufferARB");
@@ -401,6 +486,12 @@ static void R_CheckPortableExtensions( void ) {
 		qglGetBufferPointervARB = (PFNGLGETBUFFERPOINTERVARBPROC)GLimp_ExtensionPointer( "glGetBufferPointervARB");
 	}
 
+	// GL_ARB_map_buffer_range, map a section of a buffer object's data store
+	glConfig.mapBufferRangeAvailable = R_CheckExtension( "GL_ARB_map_buffer_range" );
+	if ( glConfig.mapBufferRangeAvailable ) {
+		qglMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)GLimp_ExtensionPointer( "glMapBufferRange" );
+	}
+
 	// ARB_vertex_program
 	glConfig.ARBVertexProgramAvailable = R_CheckExtension( "GL_ARB_vertex_program" );
 	if (glConfig.ARBVertexProgramAvailable) {
@@ -415,23 +506,13 @@ static void R_CheckPortableExtensions( void ) {
 	}
 
 	// ARB_fragment_program
-	if ( r_inhibitFragmentProgram.GetBool() ) {
-		glConfig.ARBFragmentProgramAvailable = false;
-	} else {
-		glConfig.ARBFragmentProgramAvailable = R_CheckExtension( "GL_ARB_fragment_program" );
-		if (glConfig.ARBFragmentProgramAvailable) {
-			// these are the same as ARB_vertex_program
-			qglProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC)GLimp_ExtensionPointer( "glProgramStringARB" );
-			qglBindProgramARB = (PFNGLBINDPROGRAMARBPROC)GLimp_ExtensionPointer( "glBindProgramARB" );
-			qglProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC)GLimp_ExtensionPointer( "glProgramEnvParameter4fvARB" );
-			qglProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)GLimp_ExtensionPointer( "glProgramLocalParameter4fvARB" );
-		}
-	}
-
-	// check for minimum set
-	if ( !glConfig.multitextureAvailable || !glConfig.textureEnvCombineAvailable || !glConfig.cubeMapAvailable
-		|| !glConfig.envDot3Available ) {
-			common->Error( common->GetLanguageDict()->GetString( "#str_06780" ) );
+	glConfig.ARBFragmentProgramAvailable = R_CheckExtension( "GL_ARB_fragment_program" );
+	if (glConfig.ARBFragmentProgramAvailable) {
+		// these are the same as ARB_vertex_program
+		qglProgramStringARB = (PFNGLPROGRAMSTRINGARBPROC)GLimp_ExtensionPointer( "glProgramStringARB" );
+		qglBindProgramARB = (PFNGLBINDPROGRAMARBPROC)GLimp_ExtensionPointer( "glBindProgramARB" );
+		qglProgramEnvParameter4fvARB = (PFNGLPROGRAMENVPARAMETER4FVARBPROC)GLimp_ExtensionPointer( "glProgramEnvParameter4fvARB" );
+		qglProgramLocalParameter4fvARB = (PFNGLPROGRAMLOCALPARAMETER4FVARBPROC)GLimp_ExtensionPointer( "glProgramLocalParameter4fvARB" );
 	}
 
 	// GL_EXT_depth_bounds_test
@@ -440,65 +521,230 @@ static void R_CheckPortableExtensions( void ) {
 		qglDepthBoundsEXT = (PFNGLDEPTHBOUNDSEXTPROC)GLimp_ExtensionPointer( "glDepthBoundsEXT" );
 	}
 
-}
+	// GLSL, core in OpenGL > 2.0
+	glConfig.glslAvailable = ( glConfig.glVersion >= 2.0f );
+	if ( glConfig.glslAvailable ) {
+		qglCreateShader = (PFNGLCREATESHADERPROC)GLimp_ExtensionPointer( "glCreateShader" );
+		qglDeleteShader = (PFNGLDELETESHADERPROC)GLimp_ExtensionPointer( "glDeleteShader" );
+		qglShaderSource = (PFNGLSHADERSOURCEPROC)GLimp_ExtensionPointer( "glShaderSource" );
+		qglCompileShader = (PFNGLCOMPILESHADERPROC)GLimp_ExtensionPointer( "glCompileShader" );
+		qglGetShaderiv = (PFNGLGETSHADERIVPROC)GLimp_ExtensionPointer( "glGetShaderiv" );
+		qglGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)GLimp_ExtensionPointer( "glGetShaderInfoLog" );
+		qglCreateProgram = (PFNGLCREATEPROGRAMPROC)GLimp_ExtensionPointer( "glCreateProgram" );
+		qglDeleteProgram = (PFNGLDELETEPROGRAMPROC)GLimp_ExtensionPointer( "glDeleteProgram" );
+		qglAttachShader = (PFNGLATTACHSHADERPROC)GLimp_ExtensionPointer( "glAttachShader" );
+		qglDetachShader = (PFNGLDETACHSHADERPROC)GLimp_ExtensionPointer( "glDetachShader" );
+		qglLinkProgram = (PFNGLLINKPROGRAMPROC)GLimp_ExtensionPointer( "glLinkProgram" );
+		qglUseProgram = (PFNGLUSEPROGRAMPROC)GLimp_ExtensionPointer( "glUseProgram" );
+		qglGetProgramiv = (PFNGLGETPROGRAMIVPROC)GLimp_ExtensionPointer( "glGetProgramiv" );
+		qglGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)GLimp_ExtensionPointer( "glGetProgramInfoLog" );
+		qglBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)GLimp_ExtensionPointer( "glBindAttribLocation" );
+		qglGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)GLimp_ExtensionPointer( "glGetUniformLocation" );
+		qglUniform1i = (PFNGLUNIFORM1IPROC)GLimp_ExtensionPointer( "glUniform1i" );
+		qglUniform4fv = (PFNGLUNIFORM4FVPROC)GLimp_ExtensionPointer( "glUniform4fv" );
+	}
+
+	// GL_ARB_uniform_buffer_object
+	glConfig.uniformBufferAvailable = R_CheckExtension( "GL_ARB_uniform_buffer_object" );
+	if ( glConfig.uniformBufferAvailable ) {
+		qglGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)GLimp_ExtensionPointer( "glGetUniformBlockIndex" );
+		qglUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)GLimp_ExtensionPointer( "glUniformBlockBinding" );
+
+		qglGetIntegerv( GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT, (GLint *)&glConfig.uniformBufferOffsetAlignment );
+		if ( glConfig.uniformBufferOffsetAlignment < 256 ) {
+			glConfig.uniformBufferOffsetAlignment = 256;
+		}
+	}
 
+	// GL_ARB_sync
+	glConfig.syncAvailable = R_CheckExtension( "GL_ARB_sync" );
+	if ( glConfig.syncAvailable ) {
+		qglFenceSync = (PFNGLFENCESYNCPROC)GLimp_ExtensionPointer( "glFenceSync" );
+		qglIsSync = (PFNGLISSYNCPROC)GLimp_ExtensionPointer( "glIsSync" );
+		qglClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)GLimp_ExtensionPointer( "glClientWaitSync" );
+		qglDeleteSync = (PFNGLDELETESYNCPROC)GLimp_ExtensionPointer( "glDeleteSync" );
+	}
+
+	// GL_ARB_occlusion_query
+	glConfig.occlusionQueryAvailable = R_CheckExtension( "GL_ARB_occlusion_query" );
+	if ( glConfig.occlusionQueryAvailable ) {
+		// defined in GL_ARB_occlusion_query, which is required for GL_EXT_timer_query
+		qglGenQueriesARB = (PFNGLGENQUERIESARBPROC)GLimp_ExtensionPointer( "glGenQueriesARB" );
+		qglDeleteQueriesARB = (PFNGLDELETEQUERIESARBPROC)GLimp_ExtensionPointer( "glDeleteQueriesARB" );
+		qglIsQueryARB = (PFNGLISQUERYARBPROC)GLimp_ExtensionPointer( "glIsQueryARB" );
+		qglBeginQueryARB = (PFNGLBEGINQUERYARBPROC)GLimp_ExtensionPointer( "glBeginQueryARB" );
+		qglEndQueryARB = (PFNGLENDQUERYARBPROC)GLimp_ExtensionPointer( "glEndQueryARB" );
+		qglGetQueryivARB = (PFNGLGETQUERYIVARBPROC)GLimp_ExtensionPointer( "glGetQueryivARB" );
+		qglGetQueryObjectivARB = (PFNGLGETQUERYOBJECTIVARBPROC)GLimp_ExtensionPointer( "glGetQueryObjectivARB" );
+		qglGetQueryObjectuivARB = (PFNGLGETQUERYOBJECTUIVARBPROC)GLimp_ExtensionPointer( "glGetQueryObjectuivARB" );
+	}
+
+	// GL_ARB_timer_query
+	glConfig.timerQueryAvailable = R_CheckExtension( "GL_ARB_timer_query" ) || R_CheckExtension( "GL_EXT_timer_query" );
+	if ( glConfig.timerQueryAvailable ) {
+		qglGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC)GLimp_ExtensionPointer( "glGetQueryObjectui64vARB" );
+		if ( qglGetQueryObjectui64vEXT == NULL ) {
+			qglGetQueryObjectui64vEXT = (PFNGLGETQUERYOBJECTUI64VEXTPROC)GLimp_ExtensionPointer( "glGetQueryObjectui64vEXT" );
+		}
+	}
 
-/*
-====================
-R_GetModeInfo
+	// GL_ARB_debug_output
+	glConfig.debugOutputAvailable = R_CheckExtension( "GL_ARB_debug_output" );
+	if ( glConfig.debugOutputAvailable ) {
+		qglDebugMessageControlARB = (PFNGLDEBUGMESSAGECONTROLARBPROC)GLimp_ExtensionPointer( "glDebugMessageControlARB" );
+		qglDebugMessageInsertARB = (PFNGLDEBUGMESSAGEINSERTARBPROC)GLimp_ExtensionPointer( "glDebugMessageInsertARB" );
+		qglDebugMessageCallbackARB = (PFNGLDEBUGMESSAGECALLBACKARBPROC)GLimp_ExtensionPointer( "glDebugMessageCallbackARB" );
+		qglGetDebugMessageLogARB = (PFNGLGETDEBUGMESSAGELOGARBPROC)GLimp_ExtensionPointer( "glGetDebugMessageLogARB" );
 
-r_mode is normally a small non-negative integer that
-looks resolutions up in a table, but if it is set to -1,
-the values from r_customWidth, amd r_customHeight
-will be used instead.
-====================
-*/
-typedef struct vidmode_s {
-	const char *description;
-	int         width, height;
-} vidmode_t;
-
-vidmode_t r_vidModes[] = {
-	{ "Mode  0: 320x240",		320,	240 },
-	{ "Mode  1: 400x300",		400,	300 },
-	{ "Mode  2: 512x384",		512,	384 },
-	{ "Mode  3: 640x480",		640,	480 },
-	{ "Mode  4: 800x600",		800,	600 },
-	{ "Mode  5: 1024x768",		1024,	768 },
-	{ "Mode  6: 1152x864",		1152,	864 },
-	{ "Mode  7: 1280x1024",		1280,	1024 },
-	{ "Mode  8: 1600x1200",		1600,	1200 },
-};
-static int	s_numVidModes = ( sizeof( r_vidModes ) / sizeof( r_vidModes[0] ) );
-
-static bool R_GetModeInfo( int *width, int *height, int mode ) {
-	vidmode_t	*vm;
-
-	if ( mode < -1 ) {
-		return false;
-	}
-	if ( mode >= s_numVidModes ) {
-		return false;
+		if ( r_debugContext.GetInteger() >= 1 ) {
+			qglDebugMessageCallbackARB(DebugCallback, NULL);
+		}
+		if ( r_debugContext.GetInteger() >= 2 ) {
+			// force everything to happen in the main thread instead of in a separate driver thread
+			qglEnable( GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB );
+		}
+		if ( r_debugContext.GetInteger() >= 3 ) {
+			// enable all the low priority messages
+			qglDebugMessageControlARB( GL_DONT_CARE,
+				GL_DONT_CARE,
+				GL_DEBUG_SEVERITY_LOW_ARB,
+				0, NULL, true );
+		}
 	}
+}
 
-	if ( mode == -1 ) {
-		*width = r_customWidth.GetInteger();
-		*height = r_customHeight.GetInteger();
-		return true;
-	}
 
-	vm = &r_vidModes[mode];
 
-	if ( width ) {
-		*width  = vm->width;
-	}
-	if ( height ) {
-		*height = vm->height;
+static bool r_initialized = false;
+
+/*
+=============================
+R_IsInitialized
+=============================
+*/
+bool R_IsInitialized() {
+	return r_initialized;
+}
+
+/*
+=============================
+R_SetNewMode
+
+r_fullScreen -1		borderless window at exact desktop coordinates
+r_fullScreen 0		bordered window at exact desktop coordinates
+r_fullScreen 1		fullscreen on monitor 1 at r_vidMode
+r_fullScreen 2		fullscreen on monitor 2 at r_vidMode
+...
+
+r_vidMode -1		use r_customWidth / r_customHeight, even if they don't appear on the mode list
+r_vidMode 0			use first mode returned by EnumDisplaySettings()
+r_vidMode 1			use second mode returned by EnumDisplaySettings()
+...
+
+r_displayRefresh 0	don't specify refresh
+r_displayRefresh 70	specify 70 hz, etc
+=============================
+*/
+void R_SetNewMode( const bool fullInit )
+{
+	// try up to three different configurations
+	for( int i = 0 ; i < 3 ; i++ ) {
+//		if( i == 0 && stereoRender_enable.GetInteger() != STEREO3D_QUAD_BUFFER ) {
+//			continue;		// don't even try for a stereo mode
+//		}
+		
+		glimpParms_t	parms;
+		
+		if( r_fullscreen.GetInteger() <= 0 ) {
+			// use explicit position / size for window
+			parms.x = r_windowX.GetInteger();
+			parms.y = r_windowY.GetInteger();
+			parms.width = r_windowWidth.GetInteger();
+			parms.height = r_windowHeight.GetInteger();
+			// may still be -1 to force a borderless window
+			parms.fullScreen = r_fullscreen.GetInteger();
+			parms.displayHz = 0;		// ignored
+		}
+		else
+		{
+			// get the mode list for this monitor
+			idList<vidMode_t> modeList;
+			if( !R_GetModeListForDisplay( r_fullscreen.GetInteger() - 1, modeList ) ) {
+				common->Printf( "r_fullscreen reset from %i to 1 because mode list failed.", r_fullscreen.GetInteger() );
+				r_fullscreen.SetInteger( 1 );
+				R_GetModeListForDisplay( r_fullscreen.GetInteger() - 1, modeList );
+			}
+			if( modeList.Num() < 1 ) {
+				common->Printf( "Going to safe mode because mode list failed." );
+				goto safeMode;
+			}
+			
+			parms.x = 0;		// ignored
+			parms.y = 0;		// ignored
+			parms.fullScreen = r_fullscreen.GetInteger();
+			
+			// set the parameters we are trying
+			if( r_vidMode.GetInteger() < 0 ) {
+				// try forcing a specific mode, even if it isn't on the list
+				parms.width = r_customWidth.GetInteger();
+				parms.height = r_customHeight.GetInteger();
+				parms.displayHz = r_displayRefresh.GetInteger();
+			} else {
+				if( r_vidMode.GetInteger() >= modeList.Num() ) {
+					common->Printf( "r_vidMode reset from %i to 0.\n", r_vidMode.GetInteger() );
+					r_vidMode.SetInteger( 0 );
+				}
+				
+				parms.width = modeList[ r_vidMode.GetInteger() ].width;
+				parms.height = modeList[ r_vidMode.GetInteger() ].height;
+				parms.displayHz = modeList[ r_vidMode.GetInteger() ].displayHz;
+			}
+		}
+		
+		parms.multiSamples = r_multiSamples.GetInteger();
+//		if( i == 0 ) {
+//			parms.stereo = ( stereoRender_enable.GetInteger() == STEREO3D_QUAD_BUFFER );
+//		} else {
+			parms.stereo = false;
+//		}
+		
+		if( fullInit ) {
+			// create the context as well as setting up the window
+			if( GLimp_Init( parms ) ) {
+				// it worked
+				break;
+			}
+		}
+		else
+		{
+			// just rebuild the window
+			if( GLimp_SetScreenParms( parms ) ) {
+				// it worked
+				break;
+			}
+		}
+		
+		if( i == 2 ) {
+			common->FatalError( "Unable to initialize OpenGL" );
+		}
+		
+		if( i == 0 ) {
+			// same settings, no stereo
+			continue;
+		}
+		
+safeMode:
+		// if we failed, set everything back to "safe mode"
+		// and try again
+		r_vidMode.SetInteger( 0 );
+		r_fullscreen.SetInteger( 1 );
+		r_displayRefresh.SetInteger( 0 );
+		r_multiSamples.SetInteger( 0 );
 	}
 
-	return true;
 }
 
+idStr extensions_string;
 
 /*
 ==================
@@ -511,56 +757,25 @@ state, including images, vertex programs, and display lists.
 
 Changes to the vertex cache size or smp state require a vid_restart.
 
-If glConfig.isInitialized is false, no rendering can take place, but
+If R_IsInitialized() is false, no rendering can take place, but
 all renderSystem functions will still operate properly, notably the material
 and model information functions.
 ==================
 */
 void R_InitOpenGL( void ) {
-	GLint			temp;
-	glimpParms_t	parms;
-	int				i;
-
-	common->Printf( "----- Initializing OpenGL -----\n" );
+	common->Printf( "----- R_InitOpenGL -----\n" );
 
-	if ( glConfig.isInitialized ) {
+	if ( R_IsInitialized() ) {
 		common->FatalError( "R_InitOpenGL called while active" );
 	}
 
+	GLimp_PreInit();
+
 	// in case we had an error while doing a tiled rendering
 	tr.viewportOffset[0] = 0;
 	tr.viewportOffset[1] = 0;
 
-	//
-	// initialize OS specific portions of the renderSystem
-	//
-	for ( i = 0 ; i < 2 ; i++ ) {
-		// set the parameters we are trying
-		R_GetModeInfo( &glConfig.vidWidth, &glConfig.vidHeight, r_mode.GetInteger() );
-
-		parms.width = glConfig.vidWidth;
-		parms.height = glConfig.vidHeight;
-		parms.fullScreen = r_fullscreen.GetBool();
-		parms.displayHz = r_displayRefresh.GetInteger();
-		parms.multiSamples = r_multiSamples.GetInteger();
-		parms.stereo = false;
-
-		if ( GLimp_Init( parms ) ) {
-			// it worked
-			break;
-		}
-
-		if ( i == 1 ) {
-			common->FatalError( "Unable to initialize OpenGL" );
-		}
-
-		// if we failed, set everything back to "safe mode"
-		// and try again
-		r_mode.SetInteger( 3 );
-		r_fullscreen.SetInteger( 1 );
-		r_displayRefresh.SetInteger( 0 );
-		r_multiSamples.SetInteger( 0 );
-	}
+	R_SetNewMode( true );
 
 // load qgl function pointers
 #define QGLPROC(name, rettype, args) \
@@ -568,7 +783,7 @@ void R_InitOpenGL( void ) {
 	if (!q##name) \
 		common->FatalError("Unable to initialize OpenGL (%s)", #name);
 
-#include "renderer/qgl_proc.h"
+#include "../renderer/qgl_proc.h"
 
 	// input and sound systems need to be tied to the new window
 	Sys_InitInput();
@@ -578,9 +793,35 @@ void R_InitOpenGL( void ) {
 	glConfig.vendor_string = (const char *)qglGetString(GL_VENDOR);
 	glConfig.renderer_string = (const char *)qglGetString(GL_RENDERER);
 	glConfig.version_string = (const char *)qglGetString(GL_VERSION);
+	glConfig.shading_language_string = (const char *)qglGetString( GL_SHADING_LANGUAGE_VERSION );
 	glConfig.extensions_string = (const char *)qglGetString(GL_EXTENSIONS);
 
+	if ( glConfig.extensions_string == NULL ) {
+		// As of OpenGL 3.2, glGetStringi is required to obtain the available extensions
+		qglGetStringi = (PFNGLGETSTRINGIPROC)GLimp_ExtensionPointer( "glGetStringi" );
+
+		// Build the extensions string
+		GLint numExtensions;
+		qglGetIntegerv( GL_NUM_EXTENSIONS, &numExtensions );
+		extensions_string.Clear();
+		for ( int i = 0; i < numExtensions; i++ ) {
+			extensions_string.Append( (const char*)qglGetStringi( GL_EXTENSIONS, i ) );
+			// the now deprecated glGetString method used to create a single string with each extension separated by a space
+			if ( i < numExtensions - 1 ) {
+				extensions_string.Append( ' ' );
+			}
+		}
+		glConfig.extensions_string = extensions_string.c_str();
+	}
+
+	float glVersion = atof( glConfig.version_string );
+	float glslVersion = atof( glConfig.shading_language_string );
+	common->Printf( "OpenGL Version: %3.1f\n", glVersion );
+	common->Printf( "OpenGL Vendor : %s\n", glConfig.vendor_string );
+	common->Printf( "OpenGL GLSL   : %3.1f\n", glslVersion );
+
 	// OpenGL driver constants
+	GLint temp;
 	qglGetIntegerv( GL_MAX_TEXTURE_SIZE, &temp );
 	glConfig.maxTextureSize = temp;
 
@@ -589,17 +830,14 @@ void R_InitOpenGL( void ) {
 		glConfig.maxTextureSize = 256;
 	}
 
-	glConfig.isInitialized = true;
-
-	common->Printf("OpenGL vendor: %s\n", glConfig.vendor_string );
-	common->Printf("OpenGL renderer: %s\n", glConfig.renderer_string );
-	common->Printf("OpenGL version: %s\n", glConfig.version_string );
+	r_initialized = true;
 
 	// recheck all the extensions (FIXME: this might be dangerous)
 	R_CheckPortableExtensions();
 
-	// parse our vertex and fragment programs, possibly disably support for
-	// one of the paths if there was an error
+	renderProgManager.Init();
+
+	// parse our vertex and fragment programs
 	R_ARB2_Init();
 
 	cmdSystem->AddCommand( "reloadARBprograms", R_ReloadARBPrograms_f, CMD_FL_RENDERER, "reloads ARB programs" );
@@ -608,15 +846,12 @@ void R_InitOpenGL( void ) {
 	// allocate the vertex array range or vertex objects
 	vertexCache.Init();
 
-	// select which renderSystem we are going to use
-	r_renderer.SetModified();
-	tr.SetBackEndRenderer();
-
 	// allocate the frame data, which may be more if smp is enabled
 	R_InitFrameData();
 
 	// Reset our gamma
 	R_SetColorMappings();
+	GLimp_SetGamma( tr.gammaTable, tr.gammaTable, tr.gammaTable );
 
 #ifdef _WIN32
 	static bool glCheck = false;
@@ -697,7 +932,7 @@ Reload the material displayed by r_showSurfaceInfo
 static void R_ReloadSurface_f( const idCmdArgs &args ) {
 	modelTrace_t mt;
 	idVec3 start, end;
-
+	
 	// start far enough away that we don't hit the player model
 	start = tr.primaryView->renderView.vieworg + tr.primaryView->renderView.viewaxis[0] * 16;
 	end = start + tr.primaryView->renderView.viewaxis[0] * 1000.0f;
@@ -714,25 +949,23 @@ static void R_ReloadSurface_f( const idCmdArgs &args ) {
 	mt.material->ReloadImages( false );
 }
 
-
-
 /*
 ==============
 R_ListModes_f
 ==============
 */
 static void R_ListModes_f( const idCmdArgs &args ) {
-	int i;
-
-	common->Printf( "\n" );
-	for ( i = 0; i < s_numVidModes; i++ ) {
-		common->Printf( "%s\n", r_vidModes[i].description );
+	for( int displayNum = 0 ; ; displayNum++ ) {
+		idList<vidMode_t> modeList;
+		if( !R_GetModeListForDisplay( displayNum, modeList ) ) {
+			break;
+		}
+		for( int i = 0; i < modeList.Num() ; i++ ) {
+			common->Printf( "Monitor %i, mode %3i: %4i x %4i @ %ihz\n", displayNum + 1, i, modeList[i].width, modeList[i].height, modeList[i].displayHz );
+		}
 	}
-	common->Printf( "\n" );
 }
 
-
-
 /*
 =============
 R_TestImage_f
@@ -872,6 +1105,7 @@ void R_ReportSurfaceAreas_f( const idCmdArgs &args ) {
 	}
 }
 
+
 /*
 ===================
 R_ReportImageDuplication_f
@@ -964,84 +1198,6 @@ void R_ReportImageDuplication_f( const idCmdArgs &args ) {
 	common->Printf( "%i / %i collisions\n", count, globalImages->images.Num() );
 }
 
-/*
-==============================================================================
-
-						THROUGHPUT BENCHMARKING
-
-==============================================================================
-*/
-
-/*
-================
-R_RenderingFPS
-================
-*/
-static float R_RenderingFPS( const renderView_t *renderView ) {
-	qglFinish();
-
-	int		start = Sys_Milliseconds();
-	static const int SAMPLE_MSEC = 1000;
-	int		end;
-	int		count = 0;
-
-	while( 1 ) {
-		// render
-		renderSystem->BeginFrame( glConfig.vidWidth, glConfig.vidHeight );
-		tr.primaryWorld->RenderScene( renderView );
-		renderSystem->EndFrame( NULL, NULL );
-		qglFinish();
-		count++;
-		end = Sys_Milliseconds();
-		if ( end - start > SAMPLE_MSEC ) {
-			break;
-		}
-	}
-
-	float fps = count * 1000.0 / ( end - start );
-
-	return fps;
-}
-
-/*
-================
-R_Benchmark_f
-================
-*/
-void R_Benchmark_f( const idCmdArgs &args ) {
-	float	fps, msec;
-	renderView_t	view;
-
-	if ( !tr.primaryView ) {
-		common->Printf( "No primaryView for benchmarking\n" );
-		return;
-	}
-	view = tr.primaryRenderView;
-
-	for ( int size = 100 ; size >= 10 ; size -= 10 ) {
-		r_screenFraction.SetInteger( size );
-		fps = R_RenderingFPS( &view );
-		int	kpix = glConfig.vidWidth * glConfig.vidHeight * ( size * 0.01 ) * ( size * 0.01 ) * 0.001;
-		msec = 1000.0 / fps;
-		common->Printf( "kpix: %4i  msec:%5.1f fps:%5.1f\n", kpix, msec, fps );
-	}
-
-	// enable r_singleTriangle 1 while r_screenFraction is still at 10
-	r_singleTriangle.SetBool( 1 );
-	fps = R_RenderingFPS( &view );
-	msec = 1000.0 / fps;
-	common->Printf( "single tri  msec:%5.1f fps:%5.1f\n", msec, fps );
-	r_singleTriangle.SetBool( 0 );
-	r_screenFraction.SetInteger( 100 );
-
-	// enable r_skipRenderContext 1
-	r_skipRenderContext.SetBool( true );
-	fps = R_RenderingFPS( &view );
-	msec = 1000.0 / fps;
-	common->Printf( "no context  msec:%5.1f fps:%5.1f\n", msec, fps );
-	r_skipRenderContext.SetBool( false );
-}
-
 
 /*
 ==============================================================================
@@ -1186,17 +1342,11 @@ void idRenderSystemLocal::TakeScreenshot( int width, int height, const char *fil
 		buffer[i+2] = temp;
 	}
 
-	// _D3XP adds viewnote screenie save to cdpath
-	if ( strstr( fileName, "viewnote" ) ) {
-		fileSystem->WriteFile( fileName, buffer, c, "fs_cdpath" );
-	} else {
-		fileSystem->WriteFile( fileName, buffer, c );
-	}
+	fileSystem->WriteFile( fileName, buffer, c );
 
 	R_StaticFree( buffer );
 
 	takingScreenshot = false;
-
 }
 
 
@@ -1643,7 +1793,6 @@ void R_SetColorMappings( void ) {
 	int		i, j;
 	float	g, b;
 	int		inf;
-	unsigned short gammaTable[256];
 
 	b = r_brightness.GetFloat();
 	g = r_gamma.GetFloat();
@@ -1666,10 +1815,8 @@ void R_SetColorMappings( void ) {
 			inf = 0xffff;
 		}
 
-		gammaTable[i] = inf;
+		tr.gammaTable[i] = inf;
 	}
-
-	GLimp_SetGamma( gammaTable, gammaTable, gammaTable );
 }
 
 
@@ -1678,7 +1825,7 @@ void R_SetColorMappings( void ) {
 GfxInfo_f
 ================
 */
-static void GfxInfo_f( const idCmdArgs &args ) {
+void GfxInfo_f( const idCmdArgs &args ) {
 	const char *fsstrings[] =
 	{
 		"windowed",
@@ -1693,44 +1840,31 @@ static void GfxInfo_f( const idCmdArgs &args ) {
 	common->Printf( "GL_MAX_TEXTURE_UNITS_ARB: %d\n", glConfig.maxTextureUnits );
 	common->Printf( "GL_MAX_TEXTURE_COORDS_ARB: %d\n", glConfig.maxTextureCoords );
 	common->Printf( "GL_MAX_TEXTURE_IMAGE_UNITS_ARB: %d\n", glConfig.maxTextureImageUnits );
-	common->Printf( "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
-	common->Printf( "MODE: %d, %d x %d %s hz:", r_mode.GetInteger(), glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen.GetBool()] );
 
+	common->Printf( "\nPIXELFORMAT: color(%d-bits) Z(%d-bit) stencil(%d-bits)\n", glConfig.colorBits, glConfig.depthBits, glConfig.stencilBits );
+	common->Printf( "MODE: %d, %d x %d %s hz:", r_vidMode.GetInteger(), glConfig.vidWidth, glConfig.vidHeight, fsstrings[r_fullscreen.GetBool()] );
 	if ( glConfig.displayFrequency ) {
 		common->Printf( "%d\n", glConfig.displayFrequency );
 	} else {
 		common->Printf( "N/A\n" );
 	}
 
-	const char *active[2] = { "", " (ACTIVE)" };
-
-	if ( glConfig.allowARB2Path ) {
-		common->Printf( "ARB2 path ENABLED%s\n", active[tr.backEndRenderer == BE_ARB2] );
-	} else {
-		common->Printf( "ARB2 path disabled\n" );
-	}
+	common->Printf( "-------\n" );
 
 	if ( r_finish.GetBool() ) {
 		common->Printf( "Forcing glFinish\n" );
 	} else {
 		common->Printf( "glFinish not forced\n" );
 	}
-
-	bool tss = glConfig.twoSidedStencilAvailable;
-
-	if ( !r_useTwoSidedStencil.GetBool() && tss ) {
+	
+	if ( !r_useTwoSidedStencil.GetBool() && glConfig.twoSidedStencilAvailable ) {
 		common->Printf( "Two sided stencil available but disabled\n" );
-	} else if ( !tss ) {
+	} else if ( !glConfig.twoSidedStencilAvailable ) {
 		common->Printf( "Two sided stencil not available\n" );
-	} else if ( tss ) {
+	} else if ( glConfig.twoSidedStencilAvailable ) {
 		common->Printf( "Using two sided stencil\n" );
 	}
 
-	if ( vertexCache.IsFast() ) {
-		common->Printf( "Vertex cache is fast\n" );
-	} else {
-		common->Printf( "Vertex cache is SLOW\n" );
-	}
 }
 
 /*
@@ -1742,7 +1876,7 @@ void R_VidRestart_f( const idCmdArgs &args ) {
 	int	err;
 
 	// if OpenGL isn't started, do nothing
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -1784,7 +1918,6 @@ void R_VidRestart_f( const idCmdArgs &args ) {
 		globalImages->PurgeAllImages();
 		// free the context and close the window
 		GLimp_Shutdown();
-		glConfig.isInitialized = false;
 
 		// create the new context and vertex cache
 		bool latch = cvarSystem->GetCVarBool( "r_fullscreen" );
@@ -1798,6 +1931,8 @@ void R_VidRestart_f( const idCmdArgs &args ) {
 		globalImages->ReloadAllImages();
 	} else {
 		glimpParms_t	parms;
+		parms.x = r_windowX.GetInteger();
+		parms.y = r_windowY.GetInteger();
 		parms.width = glConfig.vidWidth;
 		parms.height = glConfig.vidHeight;
 		parms.fullScreen = ( forceWindow ) ? false : r_fullscreen.GetBool();
@@ -1921,7 +2056,6 @@ void R_InitCommands( void ) {
 	cmdSystem->AddCommand( "screenshot", R_ScreenShot_f, CMD_FL_RENDERER, "takes a screenshot" );
 	cmdSystem->AddCommand( "envshot", R_EnvShot_f, CMD_FL_RENDERER, "takes an environment shot" );
 	cmdSystem->AddCommand( "makeAmbientMap", R_MakeAmbientMap_f, CMD_FL_RENDERER|CMD_FL_CHEAT, "makes an ambient map" );
-	cmdSystem->AddCommand( "benchmark", R_Benchmark_f, CMD_FL_RENDERER, "benchmark" );
 	cmdSystem->AddCommand( "gfxInfo", GfxInfo_f, CMD_FL_RENDERER, "show graphics info" );
 	cmdSystem->AddCommand( "modulateLights", R_ModulateLights_f, CMD_FL_RENDERER | CMD_FL_CHEAT, "modifies shader parms on all lights" );
 	cmdSystem->AddCommand( "testImage", R_TestImage_f, CMD_FL_RENDERER | CMD_FL_CHEAT, "displays the given image centered on screen", idCmdSystem::ArgCompletion_ImageName );
@@ -1953,9 +2087,6 @@ void idRenderSystemLocal::Clear( void ) {
 	viewportOffset[1] = 0;
 	tiledViewport[0] = 0;
 	tiledViewport[1] = 0;
-	backEndRenderer = BE_BAD;
-	backEndRendererHasVertexPrograms = false;
-	backEndRendererMaxLight = 1.0f;
 	ambientLightVector.Zero();
 	sortOffset = 0;
 	worlds.Clear();
@@ -1976,6 +2107,7 @@ void idRenderSystemLocal::Clear( void ) {
 	guiRecursionLevel = 0;
 	guiModel = NULL;
 	demoGuiModel = NULL;
+	memset( gammaTable, 0, sizeof( gammaTable ) );
 	takingScreenshot = false;
 }
 
@@ -1984,7 +2116,9 @@ void idRenderSystemLocal::Clear( void ) {
 idRenderSystemLocal::Init
 ===============
 */
-void idRenderSystemLocal::Init( void ) {
+void idRenderSystemLocal::Init( void ) {	
+	common->Printf( "------- Initializing renderSystem --------\n" );
+	
 	// clear all our internal state
 	viewCount = 1;		// so cleared structures never match viewCount
 	// we used to memset tr, but now that it is a class, we can't, so
@@ -2013,6 +2147,9 @@ void idRenderSystemLocal::Init( void ) {
 
 	idCinematic::InitCinematic( );
 
+	// build brightness translation tables
+	R_SetColorMappings();
+
 	R_InitMaterials();
 
 	renderModelManager->Init();
@@ -2021,6 +2158,9 @@ void idRenderSystemLocal::Init( void ) {
 	identitySpace.modelMatrix[0*4+0] = 1.0f;
 	identitySpace.modelMatrix[1*4+1] = 1.0f;
 	identitySpace.modelMatrix[2*4+2] = 1.0f;
+
+	common->Printf( "renderSystem initialized.\n" );
+	common->Printf( "--------------------------------------\n" );
 }
 
 /*
@@ -2028,15 +2168,17 @@ void idRenderSystemLocal::Init( void ) {
 idRenderSystemLocal::Shutdown
 ===============
 */
-void idRenderSystemLocal::Shutdown( void ) {
+void idRenderSystemLocal::Shutdown( void ) {	
 	common->Printf( "idRenderSystem::Shutdown()\n" );
 
 	R_DoneFreeType( );
 
-	if ( glConfig.isInitialized ) {
+	if ( R_IsInitialized() ) {
 		globalImages->PurgeAllImages();
 	}
 
+	renderProgManager.Shutdown();
+
 	renderModelManager->Shutdown();
 
 	idCinematic::ShutdownCinematic( );
@@ -2058,6 +2200,8 @@ void idRenderSystemLocal::Shutdown( void ) {
 
 	Clear();
 
+	renderLog.Close();
+
 	ShutdownOpenGL();
 }
 
@@ -2091,7 +2235,7 @@ idRenderSystemLocal::InitOpenGL
 */
 void idRenderSystemLocal::InitOpenGL( void ) {
 	// if OpenGL isn't started, start it now
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		int	err;
 
 		R_InitOpenGL();
@@ -2114,7 +2258,6 @@ void idRenderSystemLocal::ShutdownOpenGL( void ) {
 	// free the context and close the window
 	R_ShutdownFrameData();
 	GLimp_Shutdown();
-	glConfig.isInitialized = false;
 }
 
 /*
@@ -2123,7 +2266,7 @@ idRenderSystemLocal::IsOpenGLRunning
 ========================
 */
 bool idRenderSystemLocal::IsOpenGLRunning( void ) const {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return false;
 	}
 	return true;
diff --git a/neo/renderer/RenderWorld.cpp b/neo/renderer/RenderWorld.cpp
index 227c96d..8b10dfa 100644
--- a/neo/renderer/RenderWorld.cpp
+++ b/neo/renderer/RenderWorld.cpp
@@ -432,6 +432,12 @@ void idRenderWorldLocal::UpdateLightDef( qhandle_t lightHandle, const renderLigh
 		light->archived = false;
 	}
 
+	// new for BFG edition: force noShadows on spectrum lights so teleport spawns
+	// don't cause such a slowdown.  Hell writing shouldn't be shadowed anyway...
+	if ( light->parms.shader && light->parms.shader->Spectrum() ) {
+		light->parms.noShadows = true;
+	}
+
 	if ( light->lightHasMoved ) {
 		light->parms.prelightModel = NULL;
 	}
@@ -679,7 +685,7 @@ void idRenderWorldLocal::RenderScene( const renderView_t *renderView ) {
 #ifndef	ID_DEDICATED
 	renderView_t	copy;
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -1442,7 +1448,7 @@ use it as an oportunity to size the interactionTable
 ===================
 */
 void idRenderWorldLocal::GenerateAllInteractions() {
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
diff --git a/neo/renderer/VertexCache.cpp b/neo/renderer/VertexCache.cpp
index ec0184e..61f939c 100644
--- a/neo/renderer/VertexCache.cpp
+++ b/neo/renderer/VertexCache.cpp
@@ -32,14 +32,20 @@ If you have questions concerning this license or the applicable additional terms
 
 #include "renderer/VertexCache.h"
 
-static const int	FRAME_MEMORY_BYTES = 0x200000;
-static const int	EXPAND_HEADERS = 1024;
 
-idCVar idVertexCache::r_showVertexCache( "r_showVertexCache", "0", CVAR_INTEGER|CVAR_RENDERER, "" );
-idCVar idVertexCache::r_vertexBufferMegs( "r_vertexBufferMegs", "32", CVAR_INTEGER|CVAR_RENDERER, "" );
+static const int	FRAME_MEMORY_BYTES = 0x4000000;
+static const int	EXPAND_HEADERS = 32;
+
+idCVar idVertexCache::r_showVertexCache( "r_showVertexCache", "0", CVAR_INTEGER|CVAR_RENDERER, "show vertex cache" );
+idCVar idVertexCache::r_vertexBufferMegs( "r_vertexBufferMegs", "32", CVAR_INTEGER|CVAR_RENDERER, "vertex buffer cache size" );
+idCVar idVertexCache::r_useArbBufferRange( "r_useArbBufferRange", "0", CVAR_BOOL|CVAR_RENDERER, "use ARB_MapBufferRange for optimization" );
+idCVar idVertexCache::r_reuseVertexCacheSooner( "r_reuseVertexCacheSooner", "1", CVAR_BOOL | CVAR_RENDERER, "reuse vertex buffers as soon as possible after freeing" );
 
 idVertexCache		vertexCache;
 
+static GLuint		gl_current_array_buffer = 0;
+static GLuint		gl_current_index_buffer = 0;
+
 /*
 ==============
 R_ListVertexCache_f
@@ -51,6 +57,32 @@ static void R_ListVertexCache_f( const idCmdArgs &args ) {
 
 /*
 ==============
+GL_BindBuffer
+==============
+*/
+static void GL_BindBuffer( GLenum target, GLuint buffer ) {
+	if ( target == GL_ARRAY_BUFFER ) {
+		if ( gl_current_array_buffer != buffer ) {
+			gl_current_array_buffer = buffer;
+		} else {
+			return;
+		}
+	} else if ( target == GL_ELEMENT_ARRAY_BUFFER ) {
+		if ( gl_current_index_buffer != buffer ) {
+			gl_current_index_buffer = buffer;
+		} else {
+			return;
+		}
+	} else {
+		common->Error( "GL_BindBuffer : invalid buffer target : %i\n", (int)target );
+		return;
+	}
+
+	qglBindBufferARB( target, buffer );
+}
+
+/*
+==============
 idVertexCache::ActuallyFree
 ==============
 */
@@ -67,15 +99,12 @@ void idVertexCache::ActuallyFree( vertCache_t *block ) {
 
 	// temp blocks are in a shared space that won't be freed
 	if ( block->tag != TAG_TEMP ) {
-		staticAllocTotal -= block->size;
-		staticCountTotal--;
+		this->staticAllocTotal -= block->size;
+		this->staticCountTotal--;
 
 		if ( block->vbo ) {
-#if 0		// this isn't really necessary, it will be reused soon enough
-			// filling with zero length data is the equivalent of freeing
-			qglBindBufferARB(GL_ARRAY_BUFFER_ARB, block->vbo);
-			qglBufferDataARB(GL_ARRAY_BUFFER_ARB, 0, 0, GL_DYNAMIC_DRAW_ARB);
-#endif
+			GL_BindBuffer( GL_ARRAY_BUFFER_ARB, block->vbo );
+			qglBufferDataARB( GL_ARRAY_BUFFER_ARB, block->size, NULL, GL_DYNAMIC_DRAW_ARB );
 		} else if ( block->virtMem ) {
 			Mem_Free( block->virtMem );
 			block->virtMem = NULL;
@@ -87,15 +116,15 @@ void idVertexCache::ActuallyFree( vertCache_t *block ) {
 	block->next->prev = block->prev;
 	block->prev->next = block->next;
 
-#if 1
-	// stick it on the front of the free list so it will be reused immediately
-	block->next = freeStaticHeaders.next;
-	block->prev = &freeStaticHeaders;
-#else
-	// stick it on the back of the free list so it won't be reused soon (just for debugging)
-	block->next = &freeStaticHeaders;
-	block->prev = freeStaticHeaders.prev;
-#endif
+	if ( r_reuseVertexCacheSooner.GetBool() ) {
+		// stick it on the front of the free list so it will be reused immediately
+		block->next = this->freeStaticHeaders.next;
+		block->prev = &this->freeStaticHeaders;
+	} else {
+		// stick it on the back of the free list so it won't be reused soon (just for debugging)
+		block->next = &this->freeStaticHeaders;
+		block->prev = this->freeStaticHeaders.prev;
+	}
 
 	block->next->prev = block;
 	block->prev->next = block;
@@ -121,16 +150,14 @@ void *idVertexCache::Position( vertCache_t *buffer ) {
 	if ( buffer->vbo ) {
 		if ( r_showVertexCache.GetInteger() == 2 ) {
 			if ( buffer->tag == TAG_TEMP ) {
-				common->Printf( "GL_ARRAY_BUFFER_ARB = %i + %zd (%i bytes)\n", buffer->vbo, buffer->offset, buffer->size );
+				common->Printf( "GL_ARRAY_BUFFER_ARB = %i + %i (%i bytes)\n", buffer->vbo, buffer->offset, buffer->size ); 
 			} else {
-				common->Printf( "GL_ARRAY_BUFFER_ARB = %i (%i bytes)\n", buffer->vbo, buffer->size );
+				common->Printf( "GL_ARRAY_BUFFER_ARB = %i (%i bytes)\n", buffer->vbo, buffer->size ); 
 			}
 		}
-		if ( buffer->indexBuffer ) {
-			qglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, buffer->vbo );
-		} else {
-			qglBindBufferARB( GL_ARRAY_BUFFER_ARB, buffer->vbo );
-		}
+
+		GL_BindBuffer( ( buffer->indexBuffer ? GL_ELEMENT_ARRAY_BUFFER : GL_ARRAY_BUFFER ), buffer->vbo );
+
 		return (void *)buffer->offset;
 	}
 
@@ -139,7 +166,7 @@ void *idVertexCache::Position( vertCache_t *buffer ) {
 }
 
 void idVertexCache::UnbindIndex() {
-	qglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );
+	GL_BindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );
 }
 
 
@@ -157,19 +184,8 @@ void idVertexCache::Init() {
 		r_vertexBufferMegs.SetInteger( 8 );
 	}
 
-	virtualMemory = false;
-
-	// use ARB_vertex_buffer_object unless explicitly disabled
-	if( r_useVertexBuffers.GetInteger() && glConfig.ARBVertexBufferObjectAvailable ) {
-		common->Printf( "using ARB_vertex_buffer_object memory\n" );
-	} else {
-		virtualMemory = true;
-		r_useIndexBuffers.SetBool( false );
-		common->Printf( "WARNING: vertex array range in virtual memory (SLOW)\n" );
-	}
-
 	// initialize the cache memory blocks
-	freeStaticHeaders.next = freeStaticHeaders.prev = &freeStaticHeaders;
+	this->freeStaticHeaders.next = this->freeStaticHeaders.prev = &this->freeStaticHeaders;
 	staticHeaders.next = staticHeaders.prev = &staticHeaders;
 	freeDynamicHeaders.next = freeDynamicHeaders.prev = &freeDynamicHeaders;
 	dynamicHeaders.next = dynamicHeaders.prev = &dynamicHeaders;
@@ -177,17 +193,18 @@ void idVertexCache::Init() {
 
 	// set up the dynamic frame memory
 	frameBytes = FRAME_MEMORY_BYTES;
-	staticAllocTotal = 0;
+	this->staticAllocTotal = 0;
 
 	byte	*junk = (byte *)Mem_Alloc( frameBytes );
 	for ( int i = 0 ; i < NUM_VERTEX_FRAMES ; i++ ) {
-		allocatingTempBuffer = true;	// force the alloc to use GL_STREAM_DRAW_ARB
-		Alloc( junk, frameBytes, &tempBuffers[i] );
-		allocatingTempBuffer = false;
-		tempBuffers[i]->tag = TAG_FIXED;
+		this->allocatingTempBuffer = true;   // force the alloc to use GL_STREAM_DRAW_ARB
+		this->Alloc( junk, this->frameBytes, &this->tempBuffers[i] );
+		this->allocatingTempBuffer = false;
+		this->tempBuffers[i]->tag = TAG_FIXED;
+
 		// unlink these from the static list, so they won't ever get purged
-		tempBuffers[i]->next->prev = tempBuffers[i]->prev;
-		tempBuffers[i]->prev->next = tempBuffers[i]->next;
+		this->tempBuffers[i]->next->prev = this->tempBuffers[i]->prev;
+		this->tempBuffers[i]->prev->next = this->tempBuffers[i]->next;
 	}
 	Mem_Free( junk );
 
@@ -214,8 +231,6 @@ idVertexCache::Shutdown
 ===========
 */
 void idVertexCache::Shutdown() {
-//	PurgeAll();	// !@#: also purge the temp buffers
-
 	headerAllocator.Shutdown();
 }
 
@@ -225,7 +240,7 @@ idVertexCache::Alloc
 ===========
 */
 void idVertexCache::Alloc( void *data, int size, vertCache_t **buffer, bool indexBuffer ) {
-	vertCache_t	*block;
+	vertCache_t	*block = NULL;
 
 	if ( size <= 0 ) {
 		common->Error( "idVertexCache::Alloc: size = %i\n", size );
@@ -235,23 +250,55 @@ void idVertexCache::Alloc( void *data, int size, vertCache_t **buffer, bool inde
 	*buffer = NULL;
 
 	// if we don't have any remaining unused headers, allocate some more
-	if ( freeStaticHeaders.next == &freeStaticHeaders ) {
-
+	if ( this->freeStaticHeaders.next == &this->freeStaticHeaders ) {
 		for ( int i = 0; i < EXPAND_HEADERS; i++ ) {
 			block = headerAllocator.Alloc();
-			block->next = freeStaticHeaders.next;
-			block->prev = &freeStaticHeaders;
+			qglGenBuffersARB( 1, & block->vbo );
+			block->size = 0;
+			block->next = this->freeStaticHeaders.next;
+			block->prev = &this->freeStaticHeaders;
 			block->next->prev = block;
-			block->prev->next = block;
+			block->prev->next = block;	
+		}
+	}
 
-			if( !virtualMemory ) {
-				qglGenBuffersARB( 1, & block->vbo );
-			}
+	GLenum target = (indexBuffer ? GL_ELEMENT_ARRAY_BUFFER : GL_ARRAY_BUFFER);
+	GLenum usage = (allocatingTempBuffer ? GL_STREAM_DRAW : GL_STATIC_DRAW);
+
+	// try to find a matching block to replace so that we're not continually respecifying vbo data each frame
+	for( vertCache_t *findblock = this->freeStaticHeaders.next; ; findblock = findblock->next ) {
+		if( findblock == &this->freeStaticHeaders ) {
+			block = this->freeStaticHeaders.next;
+			break;
+		}
+
+		if( findblock->target != target ) {
+			continue;
 		}
+		if( findblock->usage != usage ) {
+			continue;
+		}
+		if( findblock->size != size ) {
+			continue;
+		}
+
+		block = findblock;
+		break;
 	}
 
 	// move it from the freeStaticHeaders list to the staticHeaders list
-	block = freeStaticHeaders.next;
+	block->target = target;
+	block->usage = usage;
+	if ( block->vbo ) {
+		// orphan the buffer in case it needs respecifying (it usually will)
+		GL_BindBuffer( target, block->vbo );
+		qglBufferDataARB( target, (GLsizeiptr) size, NULL, usage );
+		qglBufferDataARB( target, (GLsizeiptr) size, data, usage );
+	} else {
+		block->virtMem = Mem_Alloc( size );
+		SIMDProcessor->Memcpy( block->virtMem, data, size );
+	}
+
 	block->next->prev = block->prev;
 	block->prev->next = block->next;
 	block->next = staticHeaders.next;
@@ -264,10 +311,10 @@ void idVertexCache::Alloc( void *data, int size, vertCache_t **buffer, bool inde
 	block->tag = TAG_USED;
 
 	// save data for debugging
-	staticAllocThisFrame += block->size;
-	staticCountThisFrame++;
-	staticCountTotal++;
-	staticAllocTotal += block->size;
+	this->staticAllocThisFrame += block->size;
+	this->staticCountThisFrame++;
+	this->staticCountTotal++;
+	this->staticAllocTotal += block->size;
 
 	// this will be set to zero when it is purged
 	block->user = buffer;
@@ -277,26 +324,7 @@ void idVertexCache::Alloc( void *data, int size, vertCache_t **buffer, bool inde
 	// load time lots of things may be created, but they aren't
 	// referenced by the GPU yet, and can be purged if needed.
 	block->frameUsed = currentFrame - NUM_VERTEX_FRAMES;
-
 	block->indexBuffer = indexBuffer;
-
-	// copy the data
-	if ( block->vbo ) {
-		if ( indexBuffer ) {
-			qglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, block->vbo );
-			qglBufferDataARB( GL_ELEMENT_ARRAY_BUFFER_ARB, (GLsizeiptrARB)size, data, GL_STATIC_DRAW_ARB );
-		} else {
-			qglBindBufferARB( GL_ARRAY_BUFFER_ARB, block->vbo );
-			if ( allocatingTempBuffer ) {
-				qglBufferDataARB( GL_ARRAY_BUFFER_ARB, (GLsizeiptrARB)size, data, GL_STREAM_DRAW_ARB );
-			} else {
-				qglBufferDataARB( GL_ARRAY_BUFFER_ARB, (GLsizeiptrARB)size, data, GL_STATIC_DRAW_ARB );
-			}
-		}
-	} else {
-		block->virtMem = Mem_Alloc( size );
-		SIMDProcessor->Memcpy( block->virtMem, data, size );
-	}
 }
 
 /*
@@ -324,6 +352,7 @@ void idVertexCache::Touch( vertCache_t *block ) {
 
 	block->next = staticHeaders.next;
 	block->prev = &staticHeaders;
+
 	staticHeaders.next->prev = block;
 	staticHeaders.next = block;
 }
@@ -354,6 +383,7 @@ void idVertexCache::Free( vertCache_t *block ) {
 
 	block->next = deferredFreeList.next;
 	block->prev = &deferredFreeList;
+
 	deferredFreeList.next->prev = block;
 	deferredFreeList.next = block;
 }
@@ -377,9 +407,9 @@ vertCache_t	*idVertexCache::AllocFrameTemp( void *data, int size ) {
 	if ( dynamicAllocThisFrame + size > frameBytes ) {
 		// if we don't have enough room in the temp block, allocate a static block,
 		// but immediately free it so it will get freed at the next frame
-		tempOverflow = true;
-		Alloc( data, size, &block );
-		Free( block);
+		this->tempOverflow = true;
+		this->Alloc( data, size, &block );
+		this->Free( block);
 		return block;
 	}
 
@@ -387,7 +417,6 @@ vertCache_t	*idVertexCache::AllocFrameTemp( void *data, int size ) {
 
 	// if we don't have any remaining unused headers, allocate some more
 	if ( freeDynamicHeaders.next == &freeDynamicHeaders ) {
-
 		for ( int i = 0; i < EXPAND_HEADERS; i++ ) {
 			block = headerAllocator.Alloc();
 			block->next = freeDynamicHeaders.next;
@@ -419,11 +448,32 @@ vertCache_t	*idVertexCache::AllocFrameTemp( void *data, int size ) {
 	block->virtMem = tempBuffers[listNum]->virtMem;
 	block->vbo = tempBuffers[listNum]->vbo;
 
-	if ( block->vbo ) {
-		qglBindBufferARB( GL_ARRAY_BUFFER_ARB, block->vbo );
-		qglBufferSubDataARB( GL_ARRAY_BUFFER_ARB, block->offset, (GLsizeiptrARB)size, data );
+	if( ( block->vbo = tempBuffers[listNum]->vbo ) != 0 ) {
+		GL_BindBuffer ( GL_ARRAY_BUFFER, block->vbo );
+
+		// try to get an unsynchronized map if at all possible
+		if( glConfig.mapBufferRangeAvailable && r_useArbBufferRange.GetBool() ) {
+			void *dst = NULL;
+			GLbitfield access = GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT | GL_MAP_INVALIDATE_RANGE_BIT;
+
+			// if the buffer has wrapped then we orphan it
+			if( block->offset == 0 ) {
+				access = GL_MAP_WRITE_BIT | GL_MAP_INVALIDATE_BUFFER_BIT;
+			} else {
+				access = GL_MAP_WRITE_BIT | GL_MAP_UNSYNCHRONIZED_BIT | GL_MAP_INVALIDATE_RANGE_BIT;
+			}
+
+			if( ( dst = qglMapBufferRange( GL_ARRAY_BUFFER, block->offset, (GLsizeiptr) size, access ) ) != NULL ) {
+				memcpy( (byte *) dst, data, size );
+				qglUnmapBufferARB( GL_ARRAY_BUFFER );
+			} else {
+				qglBufferSubDataARB( GL_ARRAY_BUFFER, block->offset, (GLsizeiptr) size, data );
+			}
+		} else {
+			qglBufferSubDataARB( GL_ARRAY_BUFFER, block->offset, (GLsizeiptr) size, data );
+		}      
 	} else {
-		SIMDProcessor->Memcpy( (byte *)block->virtMem + block->offset, data, size );
+		memcpy( (byte *) block->virtMem + block->offset, data, size );
 	}
 
 	return block;
@@ -451,31 +501,19 @@ void idVertexCache::EndFrame() {
 
 		common->Printf( "vertex dynamic:%i=%ik%s, static alloc:%i=%ik used:%i=%ik total:%i=%ik\n",
 			dynamicCountThisFrame, dynamicAllocThisFrame/1024, frameOverflow,
-			staticCountThisFrame, staticAllocThisFrame/1024,
+			this->staticCountThisFrame, staticAllocThisFrame/1024,
 			staticUseCount, staticUseSize/1024,
-			staticCountTotal, staticAllocTotal/1024 );
-	}
-
-#if 0
-	// if our total static count is above our working memory limit, start purging things
-	while ( staticAllocTotal > r_vertexBufferMegs.GetInteger() * 1024 * 1024 ) {
-		// free the least recently used
-
-	}
-#endif
-
-	if( !virtualMemory ) {
-		// unbind vertex buffers so normal virtual memory will be used in case
-		// r_useVertexBuffers / r_useIndexBuffers
-		qglBindBufferARB( GL_ARRAY_BUFFER_ARB, 0 );
-		qglBindBufferARB( GL_ELEMENT_ARRAY_BUFFER_ARB, 0 );
+			this->staticCountTotal, staticAllocTotal/1024 );
 	}
 
+	// unbind vertex buffers
+	GL_BindBuffer( GL_ARRAY_BUFFER, 0 );
+	GL_BindBuffer( GL_ELEMENT_ARRAY_BUFFER, 0 );
 
 	currentFrame = tr.frameCount;
 	listNum = currentFrame % NUM_VERTEX_FRAMES;
-	staticAllocThisFrame = 0;
-	staticCountThisFrame = 0;
+	this->staticAllocThisFrame = 0;
+	this->staticCountThisFrame = 0;
 	dynamicAllocThisFrame = 0;
 	dynamicCountThisFrame = 0;
 	tempOverflow = false;
@@ -504,8 +542,10 @@ idVertexCache::List
 */
 void idVertexCache::List( void ) {
 	int	numActive = 0;
+	int	numDeferred = 0;
 	int frameStatic = 0;
 	int	totalStatic = 0;
+	int	deferredSpace = 0;
 
 	vertCache_t *block;
 	for ( block = staticHeaders.next ; block != &staticHeaders ; block = block->next) {
@@ -532,30 +572,4 @@ void idVertexCache::List( void ) {
 	common->Printf( "%5i active static headers\n", numActive );
 	common->Printf( "%5i free static headers\n", numFreeStaticHeaders );
 	common->Printf( "%5i free dynamic headers\n", numFreeDynamicHeaders );
-
-	if ( !virtualMemory  ) {
-		common->Printf( "Vertex cache is in ARB_vertex_buffer_object memory (FAST).\n");
-	} else {
-		common->Printf( "Vertex cache is in virtual memory (SLOW)\n" );
-	}
-
-	if ( r_useIndexBuffers.GetBool() ) {
-		common->Printf( "Index buffers are accelerated.\n" );
-	} else {
-		common->Printf( "Index buffers are not used.\n" );
-	}
-}
-
-/*
-=============
-idVertexCache::IsFast
-
-just for gfxinfo printing
-=============
-*/
-bool idVertexCache::IsFast() {
-	if ( virtualMemory ) {
-		return false;
-	}
-	return true;
 }
diff --git a/neo/renderer/VertexCache.h b/neo/renderer/VertexCache.h
index a1d0a0d..959b215 100644
--- a/neo/renderer/VertexCache.h
+++ b/neo/renderer/VertexCache.h
@@ -42,6 +42,8 @@ typedef enum {
 
 typedef struct vertCache_s {
 	GLuint			vbo;
+   	GLenum    		target;
+   	GLenum       	usage;
 	void			*virtMem;			// only one of vbo / virtMem will be set
 	bool			indexBuffer;		// holds indexes instead of vertexes
 
@@ -59,10 +61,7 @@ class idVertexCache {
 public:
 	void			Init();
 	void			Shutdown();
-
-	// just for gfxinfo printing
-	bool			IsFast();
-
+	
 	// called when vertex programs are enabled or disabled, because
 	// the cached data is no longer valid
 	void			PurgeAll();
@@ -78,8 +77,8 @@ public:
 	// but it will be an int offset cast to a pointer of ARB_vertex_buffer_object
 	void *			Position( vertCache_t *buffer );
 
-	// if r_useIndexBuffers is enabled, but you need to draw something without
-	// an indexCache, this must be called to reset GL_ELEMENT_ARRAY_BUFFER_ARB
+	// if you need to draw something without an indexCache, this
+	// must be called to reset GL_ELEMENT_ARRAY_BUFFER_ARB
 	void			UnbindIndex();
 
 	// automatically freed at the end of the next frame
@@ -96,7 +95,7 @@ public:
 	// this block won't have to zero a buffer pointer when it is purged,
 	// but it must still wait for the frames to pass, in case the GPU
 	// is still referencing it
-	void			Free( vertCache_t *buffer );
+	void			Free( vertCache_t *buffer );	
 
 	// updates the counter for determining which temp space to use
 	// and which blocks can be purged
@@ -112,6 +111,8 @@ private:
 
 	static idCVar	r_showVertexCache;
 	static idCVar	r_vertexBufferMegs;
+	static idCVar   r_useArbBufferRange;
+	static idCVar   r_reuseVertexCacheSooner;
 
 	int				staticCountTotal;
 	int				staticAllocTotal;		// for end of frame purging
@@ -124,8 +125,6 @@ private:
 	int				currentFrame;			// for purgable block tracking
 	int				listNum;				// currentFrame % NUM_VERTEX_FRAMES, determines which tempBuffers to use
 
-	bool			virtualMemory;			// not fast stuff
-
 	bool			allocatingTempBuffer;	// force GL_STREAM_DRAW_ARB
 
 	vertCache_t		*tempBuffers[NUM_VERTEX_FRAMES];		// allocated at startup
diff --git a/neo/renderer/draw_arb2.cpp b/neo/renderer/draw_arb2.cpp
index 8aaa97d..9cbc025 100644
--- a/neo/renderer/draw_arb2.cpp
+++ b/neo/renderer/draw_arb2.cpp
@@ -31,286 +31,6 @@ If you have questions concerning this license or the applicable additional terms
 
 #include "renderer/tr_local.h"
 
-/*
-=========================================================================================
-
-GENERAL INTERACTION RENDERING
-
-=========================================================================================
-*/
-
-/*
-====================
-GL_SelectTextureNoClient
-====================
-*/
-static void GL_SelectTextureNoClient( int unit ) {
-	backEnd.glState.currenttmu = unit;
-	qglActiveTextureARB( GL_TEXTURE0_ARB + unit );
-}
-
-/*
-==================
-RB_ARB2_DrawInteraction
-==================
-*/
-void	RB_ARB2_DrawInteraction( const drawInteraction_t *din ) {
-	// load all the vertex program parameters
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_ORIGIN, din->localLightOrigin.ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_VIEW_ORIGIN, din->localViewOrigin.ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_PROJECT_S, din->lightProjection[0].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_PROJECT_T, din->lightProjection[1].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_PROJECT_Q, din->lightProjection[2].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_FALLOFF_S, din->lightProjection[3].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_BUMP_MATRIX_S, din->bumpMatrix[0].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_BUMP_MATRIX_T, din->bumpMatrix[1].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_DIFFUSE_MATRIX_S, din->diffuseMatrix[0].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_DIFFUSE_MATRIX_T, din->diffuseMatrix[1].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_SPECULAR_MATRIX_S, din->specularMatrix[0].ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_SPECULAR_MATRIX_T, din->specularMatrix[1].ToFloatPtr() );
-
-	// testing fragment based normal mapping
-	if ( r_testARBProgram.GetBool() ) {
-		qglProgramEnvParameter4fvARB( GL_FRAGMENT_PROGRAM_ARB, 2, din->localLightOrigin.ToFloatPtr() );
-		qglProgramEnvParameter4fvARB( GL_FRAGMENT_PROGRAM_ARB, 3, din->localViewOrigin.ToFloatPtr() );
-	}
-
-	static const float zero[4] = { 0, 0, 0, 0 };
-	static const float one[4] = { 1, 1, 1, 1 };
-	static const float negOne[4] = { -1, -1, -1, -1 };
-
-	switch ( din->vertexColor ) {
-	case SVC_IGNORE:
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_MODULATE, zero );
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_ADD, one );
-		break;
-	case SVC_MODULATE:
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_MODULATE, one );
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_ADD, zero );
-		break;
-	case SVC_INVERSE_MODULATE:
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_MODULATE, negOne );
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_COLOR_ADD, one );
-		break;
-	}
-
-	// set the constant colors
-	qglProgramEnvParameter4fvARB( GL_FRAGMENT_PROGRAM_ARB, 0, din->diffuseColor.ToFloatPtr() );
-	qglProgramEnvParameter4fvARB( GL_FRAGMENT_PROGRAM_ARB, 1, din->specularColor.ToFloatPtr() );
-
-	// set the textures
-
-	// texture 1 will be the per-surface bump map
-	GL_SelectTextureNoClient( 1 );
-	din->bumpImage->Bind();
-
-	// texture 2 will be the light falloff texture
-	GL_SelectTextureNoClient( 2 );
-	din->lightFalloffImage->Bind();
-
-	// texture 3 will be the light projection texture
-	GL_SelectTextureNoClient( 3 );
-	din->lightImage->Bind();
-
-	// texture 4 is the per-surface diffuse map
-	GL_SelectTextureNoClient( 4 );
-	din->diffuseImage->Bind();
-
-	// texture 5 is the per-surface specular map
-	GL_SelectTextureNoClient( 5 );
-	din->specularImage->Bind();
-
-	// draw it
-	RB_DrawElementsWithCounters( din->surf->geo );
-}
-
-
-/*
-=============
-RB_ARB2_CreateDrawInteractions
-
-=============
-*/
-void RB_ARB2_CreateDrawInteractions( const drawSurf_t *surf ) {
-	if ( !surf ) {
-		return;
-	}
-
-	// perform setup here that will be constant for all interactions
-	GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHMASK | backEnd.depthFunc );
-
-	// bind the vertex program
-	if ( r_testARBProgram.GetBool() ) {
-		qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_TEST );
-		qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_TEST );
-	} else {
-		qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_INTERACTION );
-		qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_INTERACTION );
-	}
-
-	qglEnable(GL_VERTEX_PROGRAM_ARB);
-	qglEnable(GL_FRAGMENT_PROGRAM_ARB);
-
-	// enable the vertex arrays
-	qglEnableVertexAttribArrayARB( 8 );
-	qglEnableVertexAttribArrayARB( 9 );
-	qglEnableVertexAttribArrayARB( 10 );
-	qglEnableVertexAttribArrayARB( 11 );
-	qglEnableClientState( GL_COLOR_ARRAY );
-
-	// texture 0 is the normalization cube map for the vector towards the light
-	GL_SelectTextureNoClient( 0 );
-	if ( backEnd.vLight->lightShader->IsAmbientLight() ) {
-		globalImages->ambientNormalMap->Bind();
-	} else {
-		globalImages->normalCubeMapImage->Bind();
-	}
-
-	// texture 6 is the specular lookup table
-	GL_SelectTextureNoClient( 6 );
-	if ( r_testARBProgram.GetBool() ) {
-		globalImages->specular2DTableImage->Bind();	// variable specularity in alpha channel
-	} else {
-		globalImages->specularTableImage->Bind();
-	}
-
-
-	for ( ; surf ; surf=surf->nextOnLight ) {
-		// perform setup here that will not change over multiple interaction passes
-
-		// set the vertex pointers
-		idDrawVert	*ac = (idDrawVert *)vertexCache.Position( surf->geo->ambientCache );
-		qglColorPointer( 4, GL_UNSIGNED_BYTE, sizeof( idDrawVert ), ac->color );
-		qglVertexAttribPointerARB( 11, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->normal.ToFloatPtr() );
-		qglVertexAttribPointerARB( 10, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[1].ToFloatPtr() );
-		qglVertexAttribPointerARB( 9, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[0].ToFloatPtr() );
-		qglVertexAttribPointerARB( 8, 2, GL_FLOAT, false, sizeof( idDrawVert ), ac->st.ToFloatPtr() );
-		qglVertexPointer( 3, GL_FLOAT, sizeof( idDrawVert ), ac->xyz.ToFloatPtr() );
-
-		// this may cause RB_ARB2_DrawInteraction to be exacuted multiple
-		// times with different colors and images if the surface or light have multiple layers
-		RB_CreateSingleDrawInteractions( surf, RB_ARB2_DrawInteraction );
-	}
-
-	qglDisableVertexAttribArrayARB( 8 );
-	qglDisableVertexAttribArrayARB( 9 );
-	qglDisableVertexAttribArrayARB( 10 );
-	qglDisableVertexAttribArrayARB( 11 );
-	qglDisableClientState( GL_COLOR_ARRAY );
-
-	// disable features
-	GL_SelectTextureNoClient( 6 );
-	globalImages->BindNull();
-
-	GL_SelectTextureNoClient( 5 );
-	globalImages->BindNull();
-
-	GL_SelectTextureNoClient( 4 );
-	globalImages->BindNull();
-
-	GL_SelectTextureNoClient( 3 );
-	globalImages->BindNull();
-
-	GL_SelectTextureNoClient( 2 );
-	globalImages->BindNull();
-
-	GL_SelectTextureNoClient( 1 );
-	globalImages->BindNull();
-
-	backEnd.glState.currenttmu = -1;
-	GL_SelectTexture( 0 );
-
-	qglDisable(GL_VERTEX_PROGRAM_ARB);
-	qglDisable(GL_FRAGMENT_PROGRAM_ARB);
-}
-
-
-/*
-==================
-RB_ARB2_DrawInteractions
-==================
-*/
-void RB_ARB2_DrawInteractions( void ) {
-	viewLight_t		*vLight;
-
-	GL_SelectTexture( 0 );
-	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-
-	//
-	// for each light, perform adding and shadowing
-	//
-	for ( vLight = backEnd.viewDef->viewLights ; vLight ; vLight = vLight->next ) {
-		backEnd.vLight = vLight;
-
-		// do fogging later
-		if ( vLight->lightShader->IsFogLight() ) {
-			continue;
-		}
-		if ( vLight->lightShader->IsBlendLight() ) {
-			continue;
-		}
-
-		if ( !vLight->localInteractions && !vLight->globalInteractions
-			&& !vLight->translucentInteractions ) {
-			continue;
-		}
-
-		// clear the stencil buffer if needed
-		if ( vLight->globalShadows || vLight->localShadows ) {
-			backEnd.currentScissor = vLight->scissorRect;
-			if ( r_useScissor.GetBool() ) {
-				qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
-					backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
-					backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
-					backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
-			}
-			qglClear( GL_STENCIL_BUFFER_BIT );
-		} else {
-			// no shadows, so no need to read or write the stencil buffer
-			// we might in theory want to use GL_ALWAYS instead of disabling
-			// completely, to satisfy the invarience rules
-			qglStencilFunc( GL_ALWAYS, 128, 255 );
-		}
-
-		if ( r_useShadowVertexProgram.GetBool() ) {
-			qglEnable( GL_VERTEX_PROGRAM_ARB );
-			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_STENCIL_SHADOW );
-			RB_StencilShadowPass( vLight->globalShadows );
-			RB_ARB2_CreateDrawInteractions( vLight->localInteractions );
-			qglEnable( GL_VERTEX_PROGRAM_ARB );
-			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_STENCIL_SHADOW );
-			RB_StencilShadowPass( vLight->localShadows );
-			RB_ARB2_CreateDrawInteractions( vLight->globalInteractions );
-			qglDisable( GL_VERTEX_PROGRAM_ARB );	// if there weren't any globalInteractions, it would have stayed on
-		} else {
-			RB_StencilShadowPass( vLight->globalShadows );
-			RB_ARB2_CreateDrawInteractions( vLight->localInteractions );
-			RB_StencilShadowPass( vLight->localShadows );
-			RB_ARB2_CreateDrawInteractions( vLight->globalInteractions );
-		}
-
-		// translucent surfaces never get stencil shadowed
-		if ( r_skipTranslucent.GetBool() ) {
-			continue;
-		}
-
-		qglStencilFunc( GL_ALWAYS, 128, 255 );
-
-		backEnd.depthFunc = GLS_DEPTHFUNC_LESS;
-		RB_ARB2_CreateDrawInteractions( vLight->translucentInteractions );
-
-		backEnd.depthFunc = GLS_DEPTHFUNC_EQUAL;
-	}
-
-	// disable stencil shadow test
-	qglStencilFunc( GL_ALWAYS, 128, 255 );
-
-	GL_SelectTexture( 0 );
-	qglEnableClientState( GL_TEXTURE_COORD_ARRAY );
-}
-
-//===================================================================================
-
 
 typedef struct {
 	GLenum			target;
@@ -322,8 +42,6 @@ static	const int	MAX_GLPROGS = 200;
 
 // a single file can have both a vertex program and a fragment program
 static progDef_t	progs[MAX_GLPROGS] = {
-	{ GL_VERTEX_PROGRAM_ARB, VPROG_TEST, "test.vfp" },
-	{ GL_FRAGMENT_PROGRAM_ARB, FPROG_TEST, "test.vfp" },
 	{ GL_VERTEX_PROGRAM_ARB, VPROG_INTERACTION, "interaction.vfp" },
 	{ GL_FRAGMENT_PROGRAM_ARB, FPROG_INTERACTION, "interaction.vfp" },
 	{ GL_VERTEX_PROGRAM_ARB, VPROG_BUMPY_ENVIRONMENT, "bumpyEnvironment.vfp" },
@@ -368,7 +86,7 @@ void R_LoadARBProgram( int progIndex ) {
 	strcpy( buffer, fileBuffer );
 	fileSystem->FreeFile( fileBuffer );
 
-	if ( !glConfig.isInitialized ) {
+	if ( !R_IsInitialized() ) {
 		return;
 	}
 
@@ -388,14 +106,14 @@ void R_LoadARBProgram( int progIndex ) {
 			common->Printf( ": GL_VERTEX_PROGRAM_ARB not available\n" );
 			return;
 		}
-		start = strstr( buffer, "!!ARBvp" );
+		start = strstr( (char *)buffer, "!!ARBvp" );
 	}
 	if ( progs[progIndex].target == GL_FRAGMENT_PROGRAM_ARB ) {
 		if ( !glConfig.ARBFragmentProgramAvailable ) {
 			common->Printf( ": GL_FRAGMENT_PROGRAM_ARB not available\n" );
 			return;
 		}
-		start = strstr( buffer, "!!ARBfp" );
+		start = strstr( (char *)buffer, "!!ARBfp" );
 	}
 	if ( !start ) {
 		common->Printf( ": !!ARB not found\n" );
@@ -413,7 +131,7 @@ void R_LoadARBProgram( int progIndex ) {
 	qglGetError();
 
 	qglProgramStringARB( progs[progIndex].target, GL_PROGRAM_FORMAT_ASCII_ARB,
-		strlen( start ), start );
+		strlen( start ), (unsigned char *)start );
 
 	err = qglGetError();
 	qglGetIntegerv( GL_PROGRAM_ERROR_POSITION_ARB, (GLint *)&ofs );
@@ -422,7 +140,7 @@ void R_LoadARBProgram( int progIndex ) {
 		common->Printf( "\nGL_PROGRAM_ERROR_STRING_ARB: %s\n", str );
 		if ( ofs < 0 ) {
 			common->Printf( "GL_PROGRAM_ERROR_POSITION_ARB < 0 with error\n" );
-		} else if ( ofs >= (int)strlen( start ) ) {
+		} else if ( ofs >= (int)strlen( (char *)start ) ) {
 			common->Printf( "error at end of program\n" );
 		} else {
 			common->Printf( "error at %i:\n%s", ofs, start + ofs );
@@ -491,6 +209,7 @@ void R_ReloadARBPrograms_f( const idCmdArgs &args ) {
 	for ( i = 0 ; progs[i].name[0] ; i++ ) {
 		R_LoadARBProgram( i );
 	}
+	common->Printf( "-------------------------------\n" );
 }
 
 /*
@@ -502,7 +221,7 @@ R_ARB2_Init
 void R_ARB2_Init( void ) {
 	glConfig.allowARB2Path = false;
 
-	common->Printf( "ARB2 renderer: " );
+	common->Printf( "---------- R_ARB2_Init ----------\n" );
 
 	if ( !glConfig.ARBVertexProgramAvailable || !glConfig.ARBFragmentProgramAvailable ) {
 		common->Printf( "Not available.\n" );
@@ -511,5 +230,8 @@ void R_ARB2_Init( void ) {
 
 	common->Printf( "Available.\n" );
 
+	common->Printf( "---------------------------------\n" );
+
 	glConfig.allowARB2Path = true;
 }
+
diff --git a/neo/renderer/draw_common.cpp b/neo/renderer/draw_common.cpp
index 70bcc1d..e8916c7 100644
--- a/neo/renderer/draw_common.cpp
+++ b/neo/renderer/draw_common.cpp
@@ -2,9 +2,9 @@
 ===========================================================================
 
 Doom 3 GPL Source Code
-Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
+Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 
 
-This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").  
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -31,6 +31,32 @@ If you have questions concerning this license or the applicable additional terms
 
 #include "renderer/tr_local.h"
 
+static const float zero[4] = { 0, 0, 0, 0 };
+static const float one[4] = { 1, 1, 1, 1 };
+static const float negOne[4] = { -1, -1, -1, -1 };
+
+/*
+================
+RB_SetVertexColorParms
+================
+*/
+static void RB_SetVertexColorParms( stageVertexColor_t svc ) {
+	switch (svc) {
+	case SVC_IGNORE:
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_MODULATE, zero );
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_ADD, one );
+		break;
+	case SVC_MODULATE:
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_MODULATE, one );
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_ADD, zero );
+		break;
+	case SVC_INVERSE_MODULATE:
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_MODULATE, negOne );
+		renderProgManager.SetRenderParm( RENDERPARM_VERTEXCOLOR_ADD, one );
+		break;
+	}
+}
+
 /*
 =====================
 RB_BakeTextureMatrixIntoTexgen
@@ -152,96 +178,75 @@ void RB_PrepareStageTexturing( const shaderStage_t *pStage,  const drawSurf_t *s
 	}
 
 	if ( pStage->texture.texgen == TG_GLASSWARP ) {
-		if ( tr.backEndRenderer == BE_ARB2 /*|| tr.backEndRenderer == BE_NV30*/ ) {
-			qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_GLASSWARP );
-			qglEnable( GL_FRAGMENT_PROGRAM_ARB );
+		qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_GLASSWARP );
+		qglEnable( GL_FRAGMENT_PROGRAM_ARB );
 
-			GL_SelectTexture( 2 );
-			globalImages->scratchImage->Bind();
+		GL_SelectTexture( 2 );
+		globalImages->scratchImage->Bind();
 
-			GL_SelectTexture( 1 );
-			globalImages->scratchImage2->Bind();
+		GL_SelectTexture( 1 );
+		globalImages->scratchImage2->Bind();
 
-			qglEnable( GL_TEXTURE_GEN_S );
-			qglEnable( GL_TEXTURE_GEN_T );
-			qglEnable( GL_TEXTURE_GEN_Q );
+		qglEnable( GL_TEXTURE_GEN_S );
+		qglEnable( GL_TEXTURE_GEN_T );
+		qglEnable( GL_TEXTURE_GEN_Q );
 
-			float	mat[16], plane[4];
-			myGlMultMatrix( surf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat );
+		float	mat[16], plane[4];
+		myGlMultMatrix( surf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat );
 
-			plane[0] = mat[0];
-			plane[1] = mat[4];
-			plane[2] = mat[8];
-			plane[3] = mat[12];
-			qglTexGenfv( GL_S, GL_OBJECT_PLANE, plane );
+		plane[0] = mat[0];
+		plane[1] = mat[4];
+		plane[2] = mat[8];
+		plane[3] = mat[12];
+		qglTexGenfv( GL_S, GL_OBJECT_PLANE, plane );
 
-			plane[0] = mat[1];
-			plane[1] = mat[5];
-			plane[2] = mat[9];
-			plane[3] = mat[13];
-			qglTexGenfv( GL_T, GL_OBJECT_PLANE, plane );
+		plane[0] = mat[1];
+		plane[1] = mat[5];
+		plane[2] = mat[9];
+		plane[3] = mat[13];
+		qglTexGenfv( GL_T, GL_OBJECT_PLANE, plane );
 
-			plane[0] = mat[3];
-			plane[1] = mat[7];
-			plane[2] = mat[11];
-			plane[3] = mat[15];
-			qglTexGenfv( GL_Q, GL_OBJECT_PLANE, plane );
+		plane[0] = mat[3];
+		plane[1] = mat[7];
+		plane[2] = mat[11];
+		plane[3] = mat[15];
+		qglTexGenfv( GL_Q, GL_OBJECT_PLANE, plane );
 
-			GL_SelectTexture( 0 );
-		}
+		GL_SelectTexture( 0 );
 	}
 
 	if ( pStage->texture.texgen == TG_REFLECT_CUBE ) {
-		if ( tr.backEndRenderer == BE_ARB2 ) {
-			// see if there is also a bump map specified
-			const shaderStage_t *bumpStage = surf->material->GetBumpStage();
-			if ( bumpStage ) {
-				// per-pixel reflection mapping with bump mapping
-				GL_SelectTexture( 1 );
-				bumpStage->texture.image->Bind();
-				GL_SelectTexture( 0 );
+		// see if there is also a bump map specified
+		const shaderStage_t *bumpStage = surf->material->GetBumpStage();
+		if ( bumpStage ) {
+			// per-pixel reflection mapping with bump mapping
+			GL_SelectTexture( 1 );
+			bumpStage->texture.image->Bind();
+			GL_SelectTexture( 0 );
 
-				qglNormalPointer( GL_FLOAT, sizeof( idDrawVert ), ac->normal.ToFloatPtr() );
-				qglVertexAttribPointerARB( 10, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[1].ToFloatPtr() );
-				qglVertexAttribPointerARB( 9, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[0].ToFloatPtr() );
+			qglNormalPointer( GL_FLOAT, sizeof( idDrawVert ), ac->normal.ToFloatPtr() );
+			qglVertexAttribPointerARB( 10, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[1].ToFloatPtr() );
+			qglVertexAttribPointerARB( 9, 3, GL_FLOAT, false, sizeof( idDrawVert ), ac->tangents[0].ToFloatPtr() );
 
-				qglEnableVertexAttribArrayARB( 9 );
-				qglEnableVertexAttribArrayARB( 10 );
-				qglEnableClientState( GL_NORMAL_ARRAY );
+			qglEnableVertexAttribArrayARB( 9 );
+			qglEnableVertexAttribArrayARB( 10 );
+			qglEnableClientState( GL_NORMAL_ARRAY );
 
-				// Program env 5, 6, 7, 8 have been set in RB_SetProgramEnvironmentSpace
+			// Program env 5, 6, 7, 8 have been set in RB_SetProgramEnvironmentSpace
 
-				qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_BUMPY_ENVIRONMENT );
-				qglEnable( GL_FRAGMENT_PROGRAM_ARB );
-				qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_BUMPY_ENVIRONMENT );
-				qglEnable( GL_VERTEX_PROGRAM_ARB );
-			} else {
-				// per-pixel reflection mapping without a normal map
-				qglNormalPointer( GL_FLOAT, sizeof( idDrawVert ), ac->normal.ToFloatPtr() );
-				qglEnableClientState( GL_NORMAL_ARRAY );
-
-				qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_ENVIRONMENT );
-				qglEnable( GL_FRAGMENT_PROGRAM_ARB );
-				qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_ENVIRONMENT );
-				qglEnable( GL_VERTEX_PROGRAM_ARB );
-			}
+			qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_BUMPY_ENVIRONMENT );
+			qglEnable( GL_FRAGMENT_PROGRAM_ARB );
+			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_BUMPY_ENVIRONMENT );
+			qglEnable( GL_VERTEX_PROGRAM_ARB );
 		} else {
-			qglEnable( GL_TEXTURE_GEN_S );
-			qglEnable( GL_TEXTURE_GEN_T );
-			qglEnable( GL_TEXTURE_GEN_R );
-			qglTexGenf( GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-			qglTexGenf( GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-			qglTexGenf( GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-			qglEnableClientState( GL_NORMAL_ARRAY );
+			// per-pixel reflection mapping without a normal map
 			qglNormalPointer( GL_FLOAT, sizeof( idDrawVert ), ac->normal.ToFloatPtr() );
+			qglEnableClientState( GL_NORMAL_ARRAY );
 
-			qglMatrixMode( GL_TEXTURE );
-			float	mat[16];
-
-			R_TransposeGLMatrix( backEnd.viewDef->worldSpace.modelViewMatrix, mat );
-
-			qglLoadMatrixf( mat );
-			qglMatrixMode( GL_MODELVIEW );
+			qglBindProgramARB( GL_FRAGMENT_PROGRAM_ARB, FPROG_ENVIRONMENT );
+			qglEnable( GL_FRAGMENT_PROGRAM_ARB );
+			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, VPROG_ENVIRONMENT );
+			qglEnable( GL_VERTEX_PROGRAM_ARB );
 		}
 	}
 }
@@ -274,57 +279,39 @@ void RB_FinishStageTexturing( const shaderStage_t *pStage, const drawSurf_t *sur
 	}
 
 	if ( pStage->texture.texgen == TG_GLASSWARP ) {
-		if ( tr.backEndRenderer == BE_ARB2 /*|| tr.backEndRenderer == BE_NV30*/ ) {
-			GL_SelectTexture( 2 );
-			globalImages->BindNull();
+		GL_SelectTexture( 2 );
+		globalImages->BindNull();
 
-			GL_SelectTexture( 1 );
-			if ( pStage->texture.hasMatrix ) {
-				RB_LoadShaderTextureMatrix( surf->shaderRegisters, &pStage->texture );
-			}
-			qglDisable( GL_TEXTURE_GEN_S );
-			qglDisable( GL_TEXTURE_GEN_T );
-			qglDisable( GL_TEXTURE_GEN_Q );
-			qglDisable( GL_FRAGMENT_PROGRAM_ARB );
-			globalImages->BindNull();
-			GL_SelectTexture( 0 );
+		GL_SelectTexture( 1 );
+		if ( pStage->texture.hasMatrix ) {
+			RB_LoadShaderTextureMatrix( surf->shaderRegisters, &pStage->texture );
 		}
+		qglDisable( GL_TEXTURE_GEN_S );
+		qglDisable( GL_TEXTURE_GEN_T );
+		qglDisable( GL_TEXTURE_GEN_Q );
+		qglDisable( GL_FRAGMENT_PROGRAM_ARB );
+		globalImages->BindNull();
+		GL_SelectTexture( 0 );
 	}
 
 	if ( pStage->texture.texgen == TG_REFLECT_CUBE ) {
-		if ( tr.backEndRenderer == BE_ARB2 ) {
-			// see if there is also a bump map specified
-			const shaderStage_t *bumpStage = surf->material->GetBumpStage();
-			if ( bumpStage ) {
-				// per-pixel reflection mapping with bump mapping
-				GL_SelectTexture( 1 );
-				globalImages->BindNull();
-				GL_SelectTexture( 0 );
-
-				qglDisableVertexAttribArrayARB( 9 );
-				qglDisableVertexAttribArrayARB( 10 );
-			} else {
-				// per-pixel reflection mapping without bump mapping
-			}
+		// see if there is also a bump map specified
+		const shaderStage_t *bumpStage = surf->material->GetBumpStage();
+		if ( bumpStage ) {
+			// per-pixel reflection mapping with bump mapping
+			GL_SelectTexture( 1 );
+			globalImages->BindNull();
+			GL_SelectTexture( 0 );
 
-			qglDisableClientState( GL_NORMAL_ARRAY );
-			qglDisable( GL_FRAGMENT_PROGRAM_ARB );
-			qglDisable( GL_VERTEX_PROGRAM_ARB );
-			// Fixme: Hack to get around an apparent bug in ATI drivers.  Should remove as soon as it gets fixed.
-			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, 0 );
+			qglDisableVertexAttribArrayARB( 9 );
+			qglDisableVertexAttribArrayARB( 10 );
 		} else {
-			qglDisable( GL_TEXTURE_GEN_S );
-			qglDisable( GL_TEXTURE_GEN_T );
-			qglDisable( GL_TEXTURE_GEN_R );
-			qglTexGenf( GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-			qglTexGenf( GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-			qglTexGenf( GL_R, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-			qglDisableClientState( GL_NORMAL_ARRAY );
-
-			qglMatrixMode( GL_TEXTURE );
-			qglLoadIdentity();
-			qglMatrixMode( GL_MODELVIEW );
+			// per-pixel reflection mapping without bump mapping
 		}
+
+		qglDisableClientState( GL_NORMAL_ARRAY );
+		qglDisable( GL_FRAGMENT_PROGRAM_ARB );
+		qglDisable( GL_VERTEX_PROGRAM_ARB );
 	}
 
 	if ( pStage->texture.hasMatrix ) {
@@ -359,18 +346,6 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 	tri = surf->geo;
 	shader = surf->material;
 
-	// update the clip plane if needed
-	if ( backEnd.viewDef->numClipPlanes && surf->space != backEnd.currentSpace ) {
-		GL_SelectTexture( 1 );
-
-		idPlane	plane;
-
-		R_GlobalPlaneToLocal( surf->space->modelMatrix, backEnd.viewDef->clipPlanes[0], plane );
-		plane[3] += 0.5;	// the notch is in the middle
-		qglTexGenfv( GL_S, GL_OBJECT_PLANE, plane.ToFloatPtr() );
-		GL_SelectTexture( 0 );
-	}
-
 	if ( !shader->IsDrawn() ) {
 		return;
 	}
@@ -395,7 +370,7 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 	regs = surf->shaderRegisters;
 
 	// if all stages of a material have been conditioned off, don't do anything
-	for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {
+	for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {		
 		pStage = shader->GetStage(stage);
 		// check the stage enable condition
 		if ( regs[ pStage->conditionRegister ] != 0 ) {
@@ -415,16 +390,16 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 	// subviews will just down-modulate the color buffer by overbright
 	if ( shader->GetSort() == SS_SUBVIEW ) {
 		GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_ZERO | GLS_DEPTHFUNC_LESS );
-		color[0] =
-		color[1] =
-		color[2] = ( 1.0 / backEnd.overBright );
-		color[3] = 1;
+		color[0] = 1.0f;
+		color[1] = 1.0f;
+		color[2] = 1.0f;
+		color[3] = 1.0f;
 	} else {
 		// others just draw black
-		color[0] = 0;
-		color[1] = 0;
-		color[2] = 0;
-		color[3] = 1;
+		color[0] = 0.0f;
+		color[1] = 0.0f;
+		color[2] = 0.0f;
+		color[3] = 1.0f;
 	}
 
 	idDrawVert *ac = (idDrawVert *)vertexCache.Position( tri->ambientCache );
@@ -435,17 +410,14 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 
 	if ( shader->Coverage() == MC_OPAQUE ) {
 		drawSolid = true;
-	}
-
-	// we may have multiple alpha tested stages
-	if ( shader->Coverage() == MC_PERFORATED ) {
+	} else if ( shader->Coverage() == MC_PERFORATED ) {
+		// we may have multiple alpha tested stages
 		// if the only alpha tested stages are condition register omitted,
 		// draw a normal opaque surface
 		bool	didDraw = false;
 
-		qglEnable( GL_ALPHA_TEST );
 		// perforated surfaces may have multiple alpha tested stages
-		for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {
+		for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {		
 			pStage = shader->GetStage(stage);
 
 			if ( !pStage->hasAlphaTest ) {
@@ -468,9 +440,10 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 			if ( color[3] <= 0 ) {
 				continue;
 			}
-			qglColor4fv( color );
 
-			qglAlphaFunc( GL_GREATER, regs[ pStage->alphaTestRegister ] );
+			renderProgManager.SetRenderParm( RENDERPARM_COLOR, color );
+			renderProgManager.SetRenderParm( RENDERPARM_ALPHA_TEST, &regs[ pStage->alphaTestRegister ] );
+			RB_SetVertexColorParms( SVC_IGNORE );
 
 			// bind the texture
 			pStage->texture.image->Bind();
@@ -481,9 +454,10 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 			// draw it
 			RB_DrawElementsWithCounters( tri );
 
+			// clean up
 			RB_FinishStageTexturing( pStage, surf, ac );
 		}
-		qglDisable( GL_ALPHA_TEST );
+
 		if ( !didDraw ) {
 			drawSolid = true;
 		}
@@ -491,14 +465,15 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 
 	// draw the entire surface solid
 	if ( drawSolid ) {
-		qglColor4fv( color );
+		renderProgManager.SetRenderParm( RENDERPARM_COLOR, color );
+		renderProgManager.SetRenderParm( RENDERPARM_ALPHA_TEST, vec4_zero.ToFloatPtr() );
+
 		globalImages->whiteImage->Bind();
 
 		// draw it
 		RB_DrawElementsWithCounters( tri );
 	}
 
-
 	// reset polygon offset
 	if ( shader->TestMaterialFlag(MF_POLYGONOFFSET) ) {
 		qglDisable( GL_POLYGON_OFFSET_FILL );
@@ -508,7 +483,6 @@ void RB_T_FillDepthBuffer( const drawSurf_t *surf ) {
 	if ( shader->GetSort() == SS_SUBVIEW ) {
 		GL_State( GLS_DEPTHFUNC_LESS );
 	}
-
 }
 
 /*
@@ -525,14 +499,10 @@ void RB_STD_FillDepthBuffer( drawSurf_t **drawSurfs, int numDrawSurfs ) {
 		return;
 	}
 
-	// enable the second texture for mirror plane clipping if needed
-	if ( backEnd.viewDef->numClipPlanes ) {
-		GL_SelectTexture( 1 );
-		globalImages->alphaNotchImage->Bind();
-		qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
-		qglEnable( GL_TEXTURE_GEN_S );
-		qglTexCoord2f( 1, 0.5 );
-	}
+	renderLog.OpenMainBlock( MRB_FILL_DEPTH_BUFFER );
+	renderLog.OpenBlock( "RB_FillDepthBuffer" );
+
+	renderProgManager.BindShader_Depth();
 
 	// the first texture will be used for alpha tested surfaces
 	GL_SelectTexture( 0 );
@@ -551,13 +521,10 @@ void RB_STD_FillDepthBuffer( drawSurf_t **drawSurfs, int numDrawSurfs ) {
 
 	RB_RenderDrawSurfListWithFunction( drawSurfs, numDrawSurfs, RB_T_FillDepthBuffer );
 
-	if ( backEnd.viewDef->numClipPlanes ) {
-		GL_SelectTexture( 1 );
-		globalImages->BindNull();
-		qglDisable( GL_TEXTURE_GEN_S );
-		GL_SelectTexture( 0 );
-	}
+	renderProgManager.Unbind();
 
+	renderLog.CloseBlock();
+	renderLog.CloseMainBlock();
 }
 
 /*
@@ -717,7 +684,7 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 	// change the scissor if needed
 	if ( r_useScissor.GetBool() && !backEnd.currentScissor.Equals( surf->scissorRect ) ) {
 		backEnd.currentScissor = surf->scissorRect;
-		qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+		qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1, 
 			backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
 			backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
 			backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
@@ -744,20 +711,20 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 		qglEnable( GL_POLYGON_OFFSET_FILL );
 		qglPolygonOffset( r_offsetFactor.GetFloat(), r_offsetUnits.GetFloat() * shader->GetPolygonOffset() );
 	}
-
+	
 	if ( surf->space->weaponDepthHack ) {
-		RB_EnterWeaponDepthHack();
+		RB_EnterWeaponDepthHack( surf );
 	}
 
 	if ( surf->space->modelDepthHack != 0.0f ) {
-		RB_EnterModelDepthHack( surf->space->modelDepthHack );
+		RB_EnterModelDepthHack( surf );
 	}
 
 	idDrawVert *ac = (idDrawVert *)vertexCache.Position( tri->ambientCache );
 	qglVertexPointer( 3, GL_FLOAT, sizeof( idDrawVert ), ac->xyz.ToFloatPtr() );
 	qglTexCoordPointer( 2, GL_FLOAT, sizeof( idDrawVert ), reinterpret_cast<void *>(&ac->st) );
 
-	for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {
+	for ( stage = 0; stage < shader->GetNumStages() ; stage++ ) {		
 		pStage = shader->GetStage(stage);
 
 		// check the enable condition
@@ -783,11 +750,6 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 			// new style stages
 			//
 			//--------------------------
-
-			// completely skip the stage if we don't have the capability
-			if ( tr.backEndRenderer != BE_ARB2 ) {
-				continue;
-			}
 			if ( r_skipNewAmbient.GetBool() ) {
 				continue;
 			}
@@ -802,7 +764,7 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 			qglEnableClientState( GL_NORMAL_ARRAY );
 
 			GL_State( pStage->drawStateBits );
-
+			
 			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, newStage->vertexProgram );
 			qglEnable( GL_VERTEX_PROGRAM_ARB );
 
@@ -849,8 +811,6 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 
 			qglDisable( GL_VERTEX_PROGRAM_ARB );
 			qglDisable( GL_FRAGMENT_PROGRAM_ARB );
-			// Fixme: Hack to get around an apparent bug in ATI drivers.  Should remove as soon as it gets fixed.
-			qglBindProgramARB( GL_VERTEX_PROGRAM_ARB, 0 );
 
 			qglDisableClientState( GL_COLOR_ARRAY );
 			qglDisableVertexAttribArrayARB( 9 );
@@ -872,7 +832,7 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 		color[3] = regs[ pStage->color.registers[3] ];
 
 		// skip the entire stage if an add would be black
-		if ( ( pStage->drawStateBits & (GLS_SRCBLEND_BITS|GLS_DSTBLEND_BITS) ) == ( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE )
+		if ( ( pStage->drawStateBits & (GLS_SRCBLEND_BITS|GLS_DSTBLEND_BITS) ) == ( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE ) 
 			&& color[0] <= 0 && color[1] <= 0 && color[2] <= 0 ) {
 			continue;
 		}
@@ -933,14 +893,14 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 
 		// set the state
 		GL_State( pStage->drawStateBits );
-
+		
 		RB_PrepareStageTexturing( pStage, surf, ac );
 
 		// draw it
 		RB_DrawElementsWithCounters( tri );
 
 		RB_FinishStageTexturing( pStage, surf, ac );
-
+		
 		if ( pStage->vertexColor != SVC_IGNORE ) {
 			qglDisableClientState( GL_COLOR_ARRAY );
 
@@ -957,7 +917,7 @@ void RB_STD_T_RenderShaderPasses( const drawSurf_t *surf ) {
 		qglDisable( GL_POLYGON_OFFSET_FILL );
 	}
 	if ( surf->space->weaponDepthHack || surf->space->modelDepthHack != 0.0f ) {
-		RB_LeaveDepthHack();
+		RB_LeaveDepthHack( surf );
 	}
 }
 
@@ -976,6 +936,8 @@ int RB_STD_DrawShaderPasses( drawSurf_t **drawSurfs, int numDrawSurfs ) {
 		return numDrawSurfs;
 	}
 
+	RENDERLOG_PRINTF("---------- RB_STD_DrawShaderPasses ----------\n");
+
 	// if we are about to draw the first surface that needs
 	// the rendering in a texture, copy it over
 	if ( drawSurfs[0]->material->GetSort() >= SS_POST_PROCESS ) {
@@ -984,7 +946,7 @@ int RB_STD_DrawShaderPasses( drawSurf_t **drawSurfs, int numDrawSurfs ) {
 		}
 
 		// only dump if in a 3d view
-		if ( backEnd.viewDef->viewEntitys && tr.backEndRenderer == BE_ARB2 ) {
+		if ( backEnd.viewDef->viewEntitys ) {
 			globalImages->currentRenderImage->CopyFramebuffer( backEnd.viewDef->viewport.x1,
 				backEnd.viewDef->viewport.y1,  backEnd.viewDef->viewport.x2 -  backEnd.viewDef->viewport.x1 + 1,
 				backEnd.viewDef->viewport.y2 -  backEnd.viewDef->viewport.y1 + 1, true );
@@ -1050,14 +1012,18 @@ the shadow volumes face INSIDE
 static void RB_T_Shadow( const drawSurf_t *surf ) {
 	const srfTriangles_t	*tri;
 
-	// set the light position if we are using a vertex program to project the rear surfaces
-	if ( tr.backEndRendererHasVertexPrograms && r_useShadowVertexProgram.GetBool()
-		&& surf->space != backEnd.currentSpace ) {
+	// set the light position to project the rear surfaces
+	if ( surf->space != backEnd.currentSpace ) {
 		idVec4 localLight;
 
 		R_GlobalPointToLocal( surf->space->modelMatrix, backEnd.vLight->globalLightOrigin, localLight.ToVec3() );
 		localLight.w = 0.0f;
-		qglProgramEnvParameter4fvARB( GL_VERTEX_PROGRAM_ARB, PP_LIGHT_ORIGIN, localLight.ToFloatPtr() );
+
+		renderProgManager.SetRenderParm( RENDERPARM_LOCALLIGHTORIGIN, localLight.ToFloatPtr() );
+
+		float mat[16];
+		myGlMultMatrix( surf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat );
+		renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
 	}
 
 	tri = surf->geo;
@@ -1076,7 +1042,7 @@ static void RB_T_Shadow( const drawSurf_t *surf ) {
 		numIndexes = tri->numIndexes;
 	} else if ( r_useExternalShadows.GetInteger() == 2 ) { // force to no caps for testing
 		numIndexes = tri->numShadowIndexesNoCaps;
-	} else if ( !(surf->dsFlags & DSF_VIEW_INSIDE_SHADOW) ) {
+	} else if ( !(surf->dsFlags & DSF_VIEW_INSIDE_SHADOW) ) { 
 		// if we aren't inside the shadow projection, no caps are ever needed needed
 		numIndexes = tri->numShadowIndexesNoCaps;
 		external = true;
@@ -1104,62 +1070,89 @@ static void RB_T_Shadow( const drawSurf_t *surf ) {
 
 	// debug visualization
 	if ( r_showShadows.GetInteger() ) {
+		idVec4 debugColor = idVec4( 0.0f, 0.0f, 0.0f, 0.0f );
 		if ( r_showShadows.GetInteger() == 3 ) {
 			if ( external ) {
-				qglColor3f( 0.1/backEnd.overBright, 1/backEnd.overBright, 0.1/backEnd.overBright );
+				debugColor = idVec4( 0.1f, 1.0f, 0.1f, 1.0f );
 			} else {
 				// these are the surfaces that require the reverse
-				qglColor3f( 1/backEnd.overBright, 0.1/backEnd.overBright, 0.1/backEnd.overBright );
+				debugColor = idVec4( 1.0f, 0.1f, 0.1f, 1.0f );
 			}
 		} else {
 			// draw different color for turboshadows
 			if ( surf->geo->shadowCapPlaneBits & SHADOW_CAP_INFINITE ) {
 				if ( numIndexes == tri->numIndexes ) {
-					qglColor3f( 1/backEnd.overBright, 0.1/backEnd.overBright, 0.1/backEnd.overBright );
+					debugColor = idVec4( 1.0f, 0.1f, 0.1f, 1.0f );
 				} else {
-					qglColor3f( 1/backEnd.overBright, 0.4/backEnd.overBright, 0.1/backEnd.overBright );
+					debugColor = idVec4( 1.0f, 0.4f, 0.1f, 1.0f );
 				}
 			} else {
 				if ( numIndexes == tri->numIndexes ) {
-					qglColor3f( 0.1/backEnd.overBright, 1/backEnd.overBright, 0.1/backEnd.overBright );
+					debugColor = idVec4( 0.1f, 1.0f, 0.1f, 1.0f );
 				} else if ( numIndexes == tri->numShadowIndexesNoFrontCaps ) {
-					qglColor3f( 0.1/backEnd.overBright, 1/backEnd.overBright, 0.6/backEnd.overBright );
+					debugColor = idVec4( 0.1f, 1.0f, 0.6f, 1.0f );
 				} else {
-					qglColor3f( 0.6/backEnd.overBright, 1/backEnd.overBright, 0.1/backEnd.overBright );
+					debugColor = idVec4( 0.6f, 1.0f, 0.1f, 1.0f );
 				}
 			}
 		}
 
+		renderProgManager.SetRenderParm( RENDERPARM_COLOR, debugColor.ToFloatPtr() );
+
+		renderProgManager.CommitUniforms();
+
 		qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
 		qglDisable( GL_STENCIL_TEST );
+
 		GL_Cull( CT_TWO_SIDED );
+
 		RB_DrawShadowElementsWithCounters( tri, numIndexes );
+
 		GL_Cull( CT_FRONT_SIDED );
+
 		qglEnable( GL_STENCIL_TEST );
 
 		return;
 	}
 
+	renderProgManager.CommitUniforms();
+
 	// patent-free work around
 	if ( !external ) {
-		// "preload" the stencil buffer with the number of volumes
-		// that get clipped by the near or far clip plane
-		qglStencilOp( GL_KEEP, tr.stencilDecr, tr.stencilDecr );
-		GL_Cull( CT_FRONT_SIDED );
-		RB_DrawShadowElementsWithCounters( tri, numIndexes );
-		qglStencilOp( GL_KEEP, tr.stencilIncr, tr.stencilIncr );
-		GL_Cull( CT_BACK_SIDED );
-		RB_DrawShadowElementsWithCounters( tri, numIndexes );
+		// depth-fail stencil shadows
+		if( r_useTwoSidedStencil.GetBool() && glConfig.twoSidedStencilAvailable ) {
+			qglStencilOpSeparate( backEnd.viewDef->isMirror ? GL_FRONT : GL_BACK, GL_KEEP, tr.stencilDecr, GL_KEEP );
+			qglStencilOpSeparate( backEnd.viewDef->isMirror ? GL_BACK : GL_FRONT, GL_KEEP, tr.stencilIncr, GL_KEEP );
+			GL_Cull( CT_TWO_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+		} else {
+			// "preload" the stencil buffer with the number of volumes
+			// that get clipped by the near or far clip plane
+			qglStencilOp( GL_KEEP, tr.stencilDecr, tr.stencilDecr );
+			GL_Cull( CT_FRONT_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+	
+			qglStencilOp( GL_KEEP, tr.stencilIncr, tr.stencilIncr );
+			GL_Cull( CT_BACK_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+		}
+	} else {
+		// traditional depth-pass stencil shadows
+		if( r_useTwoSidedStencil.GetBool() && glConfig.twoSidedStencilAvailable ) {
+			qglStencilOpSeparate( backEnd.viewDef->isMirror ? GL_FRONT : GL_BACK, GL_KEEP, GL_KEEP, tr.stencilIncr );
+			qglStencilOpSeparate( backEnd.viewDef->isMirror ? GL_BACK : GL_FRONT, GL_KEEP, GL_KEEP, tr.stencilDecr );
+			GL_Cull( CT_TWO_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+		} else {	
+			qglStencilOp( GL_KEEP, GL_KEEP, tr.stencilIncr );
+			GL_Cull( CT_FRONT_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+	
+			qglStencilOp( GL_KEEP, GL_KEEP, tr.stencilDecr );
+			GL_Cull( CT_BACK_SIDED );
+			RB_DrawShadowElementsWithCounters( tri, numIndexes );
+		}
 	}
-
-	// traditional depth-pass stencil shadows
-	qglStencilOp( GL_KEEP, GL_KEEP, tr.stencilIncr );
-	GL_Cull( CT_FRONT_SIDED );
-	RB_DrawShadowElementsWithCounters( tri, numIndexes );
-
-	qglStencilOp( GL_KEEP, GL_KEEP, tr.stencilDecr );
-	GL_Cull( CT_BACK_SIDED );
-	RB_DrawShadowElementsWithCounters( tri, numIndexes );
 }
 
 /*
@@ -1179,11 +1172,15 @@ void RB_StencilShadowPass( const drawSurf_t *drawSurfs ) {
 		return;
 	}
 
+	RENDERLOG_PRINTF("---------- RB_StencilShadowPass ----------\n");
+
 	globalImages->BindNull();
 	qglDisableClientState( GL_TEXTURE_COORD_ARRAY );
 
 	// for visualizing the shadows
 	if ( r_showShadows.GetInteger() ) {
+		renderProgManager.BindShader_ShadowDebug();
+
 		if ( r_showShadows.GetInteger() == 2 ) {
 			// draw filled in
 			GL_State( GLS_DEPTHMASK | GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHFUNC_LESS  );
@@ -1192,6 +1189,8 @@ void RB_StencilShadowPass( const drawSurf_t *drawSurfs ) {
 			GL_State( GLS_SRCBLEND_ONE | GLS_DSTBLEND_ZERO | GLS_POLYMODE_LINE | GLS_DEPTHFUNC_ALWAYS  );
 		}
 	} else {
+		renderProgManager.BindShader_Shadow();
+
 		// don't write to the color buffer, just the stencil buffer
 		GL_State( GLS_DEPTHMASK | GLS_COLORMASK | GLS_ALPHAMASK | GLS_DEPTHFUNC_LESS );
 	}
@@ -1223,6 +1222,8 @@ void RB_StencilShadowPass( const drawSurf_t *drawSurfs ) {
 
 	qglStencilFunc( GL_GEQUAL, 128, 255 );
 	qglStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
+
+	renderProgManager.Unbind();
 }
 
 
@@ -1296,6 +1297,7 @@ static void RB_BlendLight( const drawSurf_t *drawSurfs,  const drawSurf_t *drawS
 	if ( r_skipBlendLights.GetBool() ) {
 		return;
 	}
+	RENDERLOG_PRINTF("---------- RB_BlendLight ----------\n");
 
 	lightShader = backEnd.vLight->lightShader;
 	regs = backEnd.vLight->shaderRegisters;
@@ -1412,6 +1414,8 @@ static void RB_FogPass( const drawSurf_t *drawSurfs,  const drawSurf_t *drawSurf
 	const shaderStage_t	*stage;
 	const float			*regs;
 
+	RENDERLOG_PRINTF("---------- RB_FogPass ----------\n");
+
 	// create a surface for the light frustom triangles, which are oriented drawn side out
 	frustumTris = backEnd.vLight->frustumTris;
 
@@ -1524,12 +1528,14 @@ RB_STD_FogAllLights
 void RB_STD_FogAllLights( void ) {
 	viewLight_t	*vLight;
 
-	if ( r_skipFogLights.GetBool() || r_showOverDraw.GetInteger() != 0
+	if ( r_skipFogLights.GetBool() || r_showOverDraw.GetInteger() != 0 
 		 || backEnd.viewDef->isXraySubview /* dont fog in xray mode*/
 		 ) {
 		return;
 	}
 
+	RENDERLOG_PRINTF("---------- RB_STD_FogAllLights ----------\n");
+
 	qglDisable( GL_STENCIL_TEST );
 
 	for ( vLight = backEnd.viewDef->viewLights ; vLight ; vLight = vLight->next ) {
@@ -1546,7 +1552,7 @@ void RB_STD_FogAllLights( void ) {
 			// units from the origin
 			backEnd.currentScissor = vLight->scissorRect;
 			if ( r_useScissor.GetBool() ) {
-				qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+				qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1, 
 					backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
 					backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
 					backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
@@ -1575,72 +1581,263 @@ void RB_STD_FogAllLights( void ) {
 	qglEnable( GL_STENCIL_TEST );
 }
 
-//=========================================================================================
 
 /*
-==================
-RB_STD_LightScale
+=========================================================================================
+
+GENERAL INTERACTION RENDERING
+
+=========================================================================================
+*/
 
-Perform extra blending passes to multiply the entire buffer by
-a floating point value
+
+/*
+====================
+GL_SelectTextureNoClient
+====================
+*/
+static void GL_SelectTextureNoClient(int unit) {
+	backEnd.glState.currenttmu = unit;
+	qglActiveTextureARB(GL_TEXTURE0_ARB + unit);
+	RENDERLOG_PRINTF("glActiveTextureARB( %i )\n", unit);
+}
+
+/*
+==================
+RB_STD_DrawInteraction
 ==================
 */
-void RB_STD_LightScale( void ) {
-	float	v, f;
+void RB_STD_DrawInteraction(const drawInteraction_t *din) {
+	// load all the vertex program parameters
+	renderProgManager.SetRenderParm( RENDERPARM_LOCALLIGHTORIGIN, din->localLightOrigin.ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_LOCALVIEWORIGIN, din->localViewOrigin.ToFloatPtr() );
 
-	if ( backEnd.overBright == 1.0f ) {
-		return;
-	}
+	renderProgManager.SetRenderParm( RENDERPARM_LIGHTPROJECTION_S, din->lightProjection[0].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_LIGHTPROJECTION_T, din->lightProjection[1].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_LIGHTPROJECTION_Q, din->lightProjection[2].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_LIGHTFALLOFF_S, din->lightProjection[3].ToFloatPtr() );
+
+	renderProgManager.SetRenderParm( RENDERPARM_BUMPMATRIX_S, din->bumpMatrix[0].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_BUMPMATRIX_T, din->bumpMatrix[1].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_DIFFUSEMATRIX_S, din->diffuseMatrix[0].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_DIFFUSEMATRIX_T, din->diffuseMatrix[1].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_SPECULARMATRIX_S, din->specularMatrix[0].ToFloatPtr() );
+	renderProgManager.SetRenderParm( RENDERPARM_SPECULARMATRIX_T, din->specularMatrix[1].ToFloatPtr() );
+
+	// set the vertex colors
+	RB_SetVertexColorParms( din->vertexColor );
+
+	// set the textures
+
+	// texture 0 will be the per-surface bump map
+	GL_SelectTextureNoClient(0);
+	din->bumpImage->Bind();
+
+	// texture 1 will be the light falloff texture
+	GL_SelectTextureNoClient(1);
+	din->lightFalloffImage->Bind();
+
+	// texture 2 will be the light projection texture
+	GL_SelectTextureNoClient(2);
+	din->lightImage->Bind();
 
-	if ( r_skipLightScale.GetBool() ) {
+	// texture 3 is the per-surface diffuse map
+	GL_SelectTextureNoClient(3);
+	din->diffuseImage->Bind();
+
+	// texture 4 is the per-surface specular map
+	GL_SelectTextureNoClient(4);
+	din->specularImage->Bind();
+
+	// draw it
+	RB_DrawElementsWithCounters(din->surf->geo);
+}
+
+
+/*
+=============
+RB_STD_CreateDrawInteractions
+=============
+*/
+void RB_STD_CreateDrawInteractions(const drawSurf_t *surf) {
+	if (!surf) {
 		return;
 	}
 
-	// the scissor may be smaller than the viewport for subviews
-	if ( r_useScissor.GetBool() ) {
-		qglScissor( backEnd.viewDef->viewport.x1 + backEnd.viewDef->scissor.x1,
-			backEnd.viewDef->viewport.y1 + backEnd.viewDef->scissor.y1,
-			backEnd.viewDef->scissor.x2 - backEnd.viewDef->scissor.x1 + 1,
-			backEnd.viewDef->scissor.y2 - backEnd.viewDef->scissor.y1 + 1 );
-		backEnd.currentScissor = backEnd.viewDef->scissor;
+	// perform setup here that will be constant for all interactions
+	GL_State(GLS_SRCBLEND_ONE | GLS_DSTBLEND_ONE | GLS_DEPTHMASK | backEnd.depthFunc);
+
+	// select the render prog
+	if ( surf->material->IsAmbientLight() ) {
+		renderProgManager.BindShader_InteractionAmbient();
+	} else {
+		renderProgManager.BindShader_Interaction();
 	}
 
-	// full screen blends
-	qglLoadIdentity();
-	qglMatrixMode( GL_PROJECTION );
-	qglPushMatrix();
-	qglLoadIdentity();
-	qglOrtho( 0, 1, 0, 1, -1, 1 );
+	// enable the vertex arrays
+	qglEnableVertexAttribArrayARB(8);
+	qglEnableVertexAttribArrayARB(9);
+	qglEnableVertexAttribArrayARB(10);
+	qglEnableVertexAttribArrayARB(11);
+	qglEnableClientState(GL_COLOR_ARRAY);
 
-	GL_State( GLS_SRCBLEND_DST_COLOR | GLS_DSTBLEND_SRC_COLOR );
-	GL_Cull( CT_TWO_SIDED );	// so mirror views also get it
+	for (; surf; surf = surf->nextOnLight) {
+		// perform setup here that will not change over multiple interaction passes
+
+		// set the modelview matrix for the viewer
+		float mat[16];
+		myGlMultMatrix( surf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat );
+		renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
+
+		// set the vertex pointers
+		idDrawVert	*ac = (idDrawVert *)vertexCache.Position(surf->geo->ambientCache);
+		qglColorPointer(4, GL_UNSIGNED_BYTE, sizeof(idDrawVert), ac->color);
+		qglVertexAttribPointerARB(11, 3, GL_FLOAT, false, sizeof(idDrawVert), ac->normal.ToFloatPtr());
+		qglVertexAttribPointerARB(10, 3, GL_FLOAT, false, sizeof(idDrawVert), ac->tangents[1].ToFloatPtr());
+		qglVertexAttribPointerARB(9, 3, GL_FLOAT, false, sizeof(idDrawVert), ac->tangents[0].ToFloatPtr());
+		qglVertexAttribPointerARB(8, 2, GL_FLOAT, false, sizeof(idDrawVert), ac->st.ToFloatPtr());
+		qglVertexPointer(3, GL_FLOAT, sizeof(idDrawVert), ac->xyz.ToFloatPtr());
+
+		// this may cause RB_STD_DrawInteraction to be executed multiple
+		// times with different colors and images if the surface or light have multiple layers
+		RB_CreateSingleDrawInteractions(surf, RB_STD_DrawInteraction);
+	}
+
+	qglDisableVertexAttribArrayARB(8);
+	qglDisableVertexAttribArrayARB(9);
+	qglDisableVertexAttribArrayARB(10);
+	qglDisableVertexAttribArrayARB(11);
+	qglDisableClientState(GL_COLOR_ARRAY);
+
+	// disable features
+	GL_SelectTextureNoClient(4);
 	globalImages->BindNull();
-	qglDisable( GL_DEPTH_TEST );
-	qglDisable( GL_STENCIL_TEST );
 
-	v = 1;
-	while ( idMath::Fabs( v - backEnd.overBright ) > 0.01 ) {	// a little extra slop
-		f = backEnd.overBright / v;
-		f /= 2;
-		if ( f > 1 ) {
-			f = 1;
+	GL_SelectTextureNoClient(3);
+	globalImages->BindNull();
+
+	GL_SelectTextureNoClient(2);
+	globalImages->BindNull();
+
+	GL_SelectTextureNoClient(1);
+	globalImages->BindNull();
+
+	backEnd.glState.currenttmu = -1;
+	GL_SelectTexture(0);
+
+	renderProgManager.Unbind();
+}
+
+
+/*
+==================
+RB_STD_DrawInteractions
+==================
+*/
+void RB_STD_DrawInteractions(void) {
+	viewLight_t		*vLight;
+	const idMaterial	*lightShader;
+
+	renderLog.OpenMainBlock( MRB_DRAW_INTERACTIONS );
+	renderLog.OpenBlock( "RB_DrawInteractions" );
+
+	GL_SelectTexture(0);
+	qglDisableClientState(GL_TEXTURE_COORD_ARRAY);
+
+	//
+	// for each light, perform adding and shadowing
+	//
+	for (vLight = backEnd.viewDef->viewLights; vLight; vLight = vLight->next) {
+		backEnd.vLight = vLight;
+
+		// do fogging later
+		if (vLight->lightShader->IsFogLight()) {
+			continue;
+		}
+		if (vLight->lightShader->IsBlendLight()) {
+			continue;
+		}
+
+		if (!vLight->localInteractions && !vLight->globalInteractions && !vLight->translucentInteractions) {
+			continue;
 		}
-		qglColor3f( f, f, f );
-		v = v * f * 2;
 
-		qglBegin( GL_QUADS );
-		qglVertex2f( 0,0 );
-		qglVertex2f( 0,1 );
-		qglVertex2f( 1,1 );
-		qglVertex2f( 1,0 );
-		qglEnd();
+		lightShader = vLight->lightShader;
+
+		// clear the stencil buffer if needed
+		if (vLight->globalShadows || vLight->localShadows) {
+			backEnd.currentScissor = vLight->scissorRect;
+			if (r_useScissor.GetBool()) {
+				qglScissor(backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+					backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
+					backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
+					backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1);
+			}
+			qglClear(GL_STENCIL_BUFFER_BIT);
+		} else {
+			// no shadows, so no need to read or write the stencil buffer
+			// we might in theory want to use GL_ALWAYS instead of disabling
+			// completely, to satisfy the invarience rules
+			qglStencilFunc(GL_ALWAYS, 128, 255);
+		}
+
+		if ( vLight->globalShadows != NULL ) {
+			renderLog.OpenBlock( "Global Light Shadows" );
+			RB_StencilShadowPass( vLight->globalShadows );
+			renderLog.CloseBlock();
+		}
+
+		if ( vLight->localInteractions != NULL ) {
+			renderLog.OpenBlock( "Local Light Interactions" );
+			RB_STD_CreateDrawInteractions( vLight->localInteractions );
+			renderLog.CloseBlock();
+		}
+
+		if ( vLight->localShadows != NULL ) {
+			renderLog.OpenBlock( "Local Light Shadows" );
+			RB_StencilShadowPass( vLight->localShadows );
+			renderLog.CloseBlock();
+		}
+
+		if ( vLight->globalInteractions != NULL ) {
+			renderLog.OpenBlock( "Global Light Interactions" );
+			RB_STD_CreateDrawInteractions( vLight->globalInteractions );
+			renderLog.CloseBlock();
+		}
+		
+		if ( vLight->translucentInteractions != NULL && !r_skipTranslucent.GetBool() ) {
+			renderLog.OpenBlock( "Translucent Interactions" );
+
+			// disable stencil shadow test
+			qglStencilFunc( GL_ALWAYS, 128, 255 );
+
+			// Disable the depth bounds test because translucent surfaces don't work with
+			// the depth bounds tests since they did not write depth during the depth pass.
+			backEnd.depthFunc = GLS_DEPTHFUNC_LESS;
+
+			// The depth buffer wasn't filled in for translucent surfaces, so they
+			// can never be constrained to perforated surfaces with the depthfunc equal.
+
+			// Translucent surfaces do not receive shadows. This is a case where a
+			// shadow buffer solution would work but stencil shadows do not because
+			// stencil shadows only affect surfaces that contribute to the view depth
+			// buffer and translucent surfaces do not contribute to the view depth buffer.
+			RB_STD_CreateDrawInteractions( vLight->translucentInteractions );
+
+			backEnd.depthFunc = GLS_DEPTHFUNC_EQUAL;
+
+			renderLog.CloseBlock();
+		}
 	}
 
+	// disable stencil shadow test
+	qglStencilFunc(GL_ALWAYS, 128, 255);
 
-	qglPopMatrix();
-	qglEnable( GL_DEPTH_TEST );
-	qglMatrixMode( GL_MODELVIEW );
-	GL_Cull( CT_FRONT_SIDED );
+	GL_SelectTexture(0);
+	qglEnableClientState(GL_TEXTURE_COORD_ARRAY);
+
+	renderLog.CloseBlock();
+	renderLog.CloseMainBlock();
 }
 
 //=========================================================================================
@@ -1648,13 +1845,14 @@ void RB_STD_LightScale( void ) {
 /*
 =============
 RB_STD_DrawView
-
 =============
 */
-void	RB_STD_DrawView( void ) {
+void RB_STD_DrawView( void ) {
 	drawSurf_t	 **drawSurfs;
 	int			numDrawSurfs;
 
+	RENDERLOG_PRINTF("---------- RB_STD_DrawView ----------\n");
+
 	backEnd.depthFunc = GLS_DEPTHFUNC_EQUAL;
 
 	drawSurfs = (drawSurf_t **)&backEnd.viewDef->drawSurfs[0];
@@ -1663,26 +1861,16 @@ void	RB_STD_DrawView( void ) {
 	// clear the z buffer, set the projection matrix, etc
 	RB_BeginDrawingView();
 
-	// decide how much overbrighting we are going to do
-	RB_DetermineLightScale();
-
 	// fill the depth buffer and clear color buffer to black except on
 	// subviews
 	RB_STD_FillDepthBuffer( drawSurfs, numDrawSurfs );
 
 	// main light renderer
-	switch( tr.backEndRenderer ) {
-	case BE_ARB2:
-		RB_ARB2_DrawInteractions();
-		break;
-	}
+	RB_STD_DrawInteractions();
 
 	// disable stencil shadow test
 	qglStencilFunc( GL_ALWAYS, 128, 255 );
-
-	// uplight the entire screen to crutch up not having better blending range
-	RB_STD_LightScale();
-
+	
 	// now draw any non-light dependent shading passes
 	int	processed = RB_STD_DrawShaderPasses( drawSurfs, numDrawSurfs );
 
@@ -1695,5 +1883,4 @@ void	RB_STD_DrawView( void ) {
 	}
 
 	RB_RenderDebugTools( drawSurfs, numDrawSurfs );
-
 }
diff --git a/neo/renderer/qgl.h b/neo/renderer/qgl.h
index 68b020e..6d815e5 100644
--- a/neo/renderer/qgl.h
+++ b/neo/renderer/qgl.h
@@ -68,32 +68,28 @@ GLExtension_t GLimp_ExtensionPointer( const char *name );
 #include "renderer/qgl_proc.h"
 
 // multitexture
-extern	void ( APIENTRY * qglMultiTexCoord2fARB )( GLenum texture, GLfloat s, GLfloat t );
-extern	void ( APIENTRY * qglMultiTexCoord2fvARB )( GLenum texture, GLfloat *st );
 extern	void ( APIENTRY * qglActiveTextureARB )( GLenum texture );
 extern	void ( APIENTRY * qglClientActiveTextureARB )( GLenum texture );
 
+// GL_EXT_direct_state_access
+extern PFNGLBINDMULTITEXTUREEXTPROC			qglBindMultiTextureEXT;
+
 // ARB_vertex_buffer_object
-extern PFNGLBINDBUFFERARBPROC qglBindBufferARB;
-extern PFNGLDELETEBUFFERSARBPROC qglDeleteBuffersARB;
-extern PFNGLGENBUFFERSARBPROC qglGenBuffersARB;
-extern PFNGLISBUFFERARBPROC qglIsBufferARB;
-extern PFNGLBUFFERDATAARBPROC qglBufferDataARB;
-extern PFNGLBUFFERSUBDATAARBPROC qglBufferSubDataARB;
-extern PFNGLGETBUFFERSUBDATAARBPROC qglGetBufferSubDataARB;
-extern PFNGLMAPBUFFERARBPROC qglMapBufferARB;
-extern PFNGLUNMAPBUFFERARBPROC qglUnmapBufferARB;
-extern PFNGLGETBUFFERPARAMETERIVARBPROC qglGetBufferParameterivARB;
-extern PFNGLGETBUFFERPOINTERVARBPROC qglGetBufferPointervARB;
-
-// 3D textures
-extern void ( APIENTRY *qglTexImage3D)(GLenum, GLint, GLint, GLsizei, GLsizei, GLsizei, GLint, GLenum, GLenum, const GLvoid *);
-
-// shared texture palette
-extern	void ( APIENTRY *qglColorTableEXT)( int, int, int, int, int, const void * );
-
-// EXT_stencil_two_side
-extern	PFNGLACTIVESTENCILFACEEXTPROC	qglActiveStencilFaceEXT;
+extern PFNGLBINDBUFFERARBPROC				qglBindBufferARB;
+extern PFNGLBINDBUFFERRANGEPROC				qglBindBufferRange;
+extern PFNGLDELETEBUFFERSARBPROC			qglDeleteBuffersARB;
+extern PFNGLGENBUFFERSARBPROC				qglGenBuffersARB;
+extern PFNGLISBUFFERARBPROC					qglIsBufferARB;
+extern PFNGLBUFFERDATAARBPROC				qglBufferDataARB;
+extern PFNGLBUFFERSUBDATAARBPROC			qglBufferSubDataARB;
+extern PFNGLGETBUFFERSUBDATAARBPROC			qglGetBufferSubDataARB;
+extern PFNGLMAPBUFFERARBPROC				qglMapBufferARB;
+extern PFNGLUNMAPBUFFERARBPROC				qglUnmapBufferARB;
+extern PFNGLGETBUFFERPARAMETERIVARBPROC		qglGetBufferParameterivARB;
+extern PFNGLGETBUFFERPOINTERVARBPROC		qglGetBufferPointervARB;
+
+// GL_ARB_map_buffer_range
+extern PFNGLMAPBUFFERRANGEPROC				qglMapBufferRange;
 
 // ARB_texture_compression
 extern	PFNGLCOMPRESSEDTEXIMAGE2DARBPROC	qglCompressedTexImage2DARB;
@@ -112,4 +108,57 @@ extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC	qglProgramLocalParameter4fvARB;
 // GL_EXT_depth_bounds_test
 extern PFNGLDEPTHBOUNDSEXTPROC              qglDepthBoundsEXT;
 
+// separate stencil
+extern PFNGLSTENCILOPSEPARATEPROC			qglStencilOpSeparate;
+
+// GLSL / OpenGL 2.0
+extern PFNGLCREATESHADERPROC				qglCreateShader;
+extern PFNGLDELETESHADERPROC				qglDeleteShader;
+extern PFNGLSHADERSOURCEPROC				qglShaderSource;
+extern PFNGLCOMPILESHADERPROC				qglCompileShader;
+extern PFNGLGETSHADERIVPROC					qglGetShaderiv;
+extern PFNGLGETSHADERINFOLOGPROC			qglGetShaderInfoLog;
+extern PFNGLCREATEPROGRAMPROC				qglCreateProgram;
+extern PFNGLDELETEPROGRAMPROC				qglDeleteProgram;
+extern PFNGLATTACHSHADERPROC				qglAttachShader;
+extern PFNGLDETACHSHADERPROC				qglDetachShader;
+extern PFNGLLINKPROGRAMPROC					qglLinkProgram;
+extern PFNGLUSEPROGRAMPROC					qglUseProgram;
+extern PFNGLGETPROGRAMIVPROC				qglGetProgramiv;
+extern PFNGLGETPROGRAMINFOLOGPROC			qglGetProgramInfoLog;
+extern PFNGLPROGRAMPARAMETERIPROC			qglProgramParameteri;
+extern PFNGLBINDATTRIBLOCATIONPROC			qglBindAttribLocation;
+extern PFNGLGETUNIFORMLOCATIONPROC			qglGetUniformLocation;
+extern PFNGLUNIFORM1IPROC					qglUniform1i;
+extern PFNGLUNIFORM4FVPROC					qglUniform4fv;
+
+// GL_ARB_uniform_buffer_object
+extern PFNGLGETUNIFORMBLOCKINDEXPROC		qglGetUniformBlockIndex;
+extern PFNGLUNIFORMBLOCKBINDINGPROC			qglUniformBlockBinding;
+
+// GL_ARB_sync
+extern PFNGLFENCESYNCPROC					qglFenceSync;
+extern PFNGLISSYNCPROC						qglIsSync;
+extern PFNGLCLIENTWAITSYNCPROC				qglClientWaitSync;
+extern PFNGLDELETESYNCPROC					qglDeleteSync;
+
+// GL_ARB_occlusion_query
+extern PFNGLGENQUERIESARBPROC				qglGenQueriesARB;
+extern PFNGLDELETEQUERIESARBPROC			qglDeleteQueriesARB;
+extern PFNGLISQUERYARBPROC					qglIsQueryARB;
+extern PFNGLBEGINQUERYARBPROC				qglBeginQueryARB;
+extern PFNGLENDQUERYARBPROC					qglEndQueryARB;
+extern PFNGLGETQUERYIVARBPROC				qglGetQueryivARB;
+extern PFNGLGETQUERYOBJECTIVARBPROC			qglGetQueryObjectivARB;
+extern PFNGLGETQUERYOBJECTUIVARBPROC		qglGetQueryObjectuivARB;
+
+// GL_ARB_timer_query / GL_EXT_timer_query
+extern PFNGLGETQUERYOBJECTUI64VEXTPROC		qglGetQueryObjectui64vEXT;
+
+// GL_ARB_debug_output
+extern PFNGLDEBUGMESSAGECONTROLARBPROC		qglDebugMessageControlARB;
+extern PFNGLDEBUGMESSAGEINSERTARBPROC		qglDebugMessageInsertARB;
+extern PFNGLDEBUGMESSAGECALLBACKARBPROC		qglDebugMessageCallbackARB;
+extern PFNGLGETDEBUGMESSAGELOGARBPROC		qglGetDebugMessageLogARB;
+
 #endif
diff --git a/neo/renderer/tr_backend.cpp b/neo/renderer/tr_backend.cpp
index 18224a0..37d3226 100644
--- a/neo/renderer/tr_backend.cpp
+++ b/neo/renderer/tr_backend.cpp
@@ -43,6 +43,8 @@ may touch, including the editor.
 void RB_SetDefaultGLState( void ) {
 	int		i;
 
+	RENDERLOG_PRINTF("--- R_SetDefaultGLState ---\n");
+
 	qglClearDepth( 1.0f );
 	qglColor4f (1,1,1,1);
 
@@ -70,9 +72,8 @@ void RB_SetDefaultGLState( void ) {
 	qglPolygonMode (GL_FRONT_AND_BACK, GL_FILL);
 	qglDepthMask( GL_TRUE );
 	qglDepthFunc( GL_ALWAYS );
-
+ 
 	qglCullFace( GL_FRONT_AND_BACK );
-	qglShadeModel( GL_SMOOTH );
 
 	if ( r_useScissor.GetBool() ) {
 		qglScissor( 0, 0, glConfig.vidWidth, glConfig.vidHeight );
@@ -89,22 +90,17 @@ void RB_SetDefaultGLState( void ) {
 
 		GL_TexEnv( GL_MODULATE );
 		qglDisable( GL_TEXTURE_2D );
-		if ( glConfig.texture3DAvailable ) {
-			qglDisable( GL_TEXTURE_3D );
-		}
-		if ( glConfig.cubeMapAvailable ) {
-			qglDisable( GL_TEXTURE_CUBE_MAP_EXT );
-		}
+		qglDisable( GL_TEXTURE_CUBE_MAP );
 	}
-}
-
 
+	renderProgManager.Unbind();
+	renderProgManager.ZeroUniforms();
+}
 
 
 //=============================================================================
 
 
-
 /*
 ====================
 GL_SelectTexture
@@ -122,6 +118,7 @@ void GL_SelectTexture( int unit ) {
 
 	qglActiveTextureARB( GL_TEXTURE0_ARB + unit );
 	qglClientActiveTextureARB( GL_TEXTURE0_ARB + unit );
+	RENDERLOG_PRINTF("glActiveTextureARB( %i );\nglClientActiveTextureARB( %i );\n", unit, unit);
 
 	backEnd.glState.currenttmu = unit;
 }
@@ -350,32 +347,6 @@ void GL_State( int stateBits ) {
 		}
 	}
 
-	//
-	// alpha test
-	//
-	if ( diff & GLS_ATEST_BITS ) {
-		switch ( stateBits & GLS_ATEST_BITS ) {
-		case 0:
-			qglDisable( GL_ALPHA_TEST );
-			break;
-		case GLS_ATEST_EQ_255:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_EQUAL, 1 );
-			break;
-		case GLS_ATEST_LT_128:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_LESS, 0.5 );
-			break;
-		case GLS_ATEST_GE_128:
-			qglEnable( GL_ALPHA_TEST );
-			qglAlphaFunc( GL_GEQUAL, 0.5 );
-			break;
-		default:
-			assert( 0 );
-			break;
-		}
-	}
-
 	backEnd.glState.glStateBits = stateBits;
 }
 
@@ -534,6 +505,8 @@ const void	RB_SwapBuffers( const void *data ) {
 		qglFinish();
 	}
 
+	RENDERLOG_PRINTF("***************** RB_SwapBuffers *****************\n\n\n");
+
 	// don't flip if drawing to front buffer
 	if ( !r_frontBuffer.GetBool() ) {
 		GLimp_SwapBuffers();
@@ -556,6 +529,8 @@ const void	RB_CopyRender( const void *data ) {
 		return;
 	}
 
+	RENDERLOG_PRINTF("***************** RB_CopyRender *****************\n");
+
 	if (cmd->image) {
 		cmd->image->CopyFramebuffer( cmd->x, cmd->y, cmd->imageWidth, cmd->imageHeight, false );
 	}
@@ -580,6 +555,8 @@ void RB_ExecuteBackEndCommands( const emptyCommand_t *cmds ) {
 
 	backEndStartTime = Sys_Milliseconds();
 
+	renderLog.StartFrame();
+
 	// needed for editor rendering
 	RB_SetDefaultGLState();
 
@@ -629,4 +606,5 @@ void RB_ExecuteBackEndCommands( const emptyCommand_t *cmds ) {
 		common->Printf( "3d: %i, 2d: %i, SetBuf: %i, SwpBuf: %i, CpyRenders: %i, CpyFrameBuf: %i\n", c_draw3d, c_draw2d, c_setBuffers, c_swapBuffers, c_copyRenders, backEnd.c_copyFrameBuffer );
 		backEnd.c_copyFrameBuffer = 0;
 	}
+	renderLog.EndFrame();
 }
diff --git a/neo/renderer/tr_light.cpp b/neo/renderer/tr_light.cpp
index 5a68199..1aac4a7 100644
--- a/neo/renderer/tr_light.cpp
+++ b/neo/renderer/tr_light.cpp
@@ -70,71 +70,6 @@ bool R_CreateAmbientCache( srfTriangles_t *tri, bool needsLighting ) {
 
 /*
 ==================
-R_CreateLightingCache
-
-Returns false if the cache couldn't be allocated, in which case the surface should be skipped.
-==================
-*/
-bool R_CreateLightingCache( const idRenderEntityLocal *ent, const idRenderLightLocal *light, srfTriangles_t *tri ) {
-	idVec3		localLightOrigin;
-
-	// fogs and blends don't need light vectors
-	if ( light->lightShader->IsFogLight() || light->lightShader->IsBlendLight() ) {
-		return true;
-	}
-
-	// not needed if we have vertex programs
-	if ( tr.backEndRendererHasVertexPrograms ) {
-		return true;
-	}
-
-	R_GlobalPointToLocal( ent->modelMatrix, light->globalLightOrigin, localLightOrigin );
-
-	int	size = tri->ambientSurface->numVerts * sizeof( lightingCache_t );
-	lightingCache_t *cache = (lightingCache_t *)_alloca16( size );
-
-#if 1
-
-	SIMDProcessor->CreateTextureSpaceLightVectors( &cache[0].localLightVector, localLightOrigin,
-												tri->ambientSurface->verts, tri->ambientSurface->numVerts, tri->indexes, tri->numIndexes );
-
-#else
-
-	bool *used = (bool *)_alloca16( tri->ambientSurface->numVerts * sizeof( used[0] ) );
-	memset( used, 0, tri->ambientSurface->numVerts * sizeof( used[0] ) );
-
-	// because the interaction may be a very small subset of the full surface,
-	// it makes sense to only deal with the verts used
-	for ( int j = 0; j < tri->numIndexes; j++ ) {
-		int i = tri->indexes[j];
-		if ( used[i] ) {
-			continue;
-		}
-		used[i] = true;
-
-		idVec3 lightDir;
-		const idDrawVert *v;
-
-		v = &tri->ambientSurface->verts[i];
-
-		lightDir = localLightOrigin - v->xyz;
-
-		cache[i].localLightVector[0] = lightDir * v->tangents[0];
-		cache[i].localLightVector[1] = lightDir * v->tangents[1];
-		cache[i].localLightVector[2] = lightDir * v->normal;
-	}
-
-#endif
-
-	vertexCache.Alloc( cache, size, &tri->lightingCache );
-	if ( !tri->lightingCache ) {
-		return false;
-	}
-	return true;
-}
-
-/*
-==================
 R_CreatePrivateShadowCache
 
 This is used only for a specific light
@@ -295,77 +230,6 @@ void R_WobbleskyTexGen( drawSurf_t *surf, const idVec3 &viewOrg ) {
 	surf->dynamicTexCoords = vertexCache.AllocFrameTemp( texCoords, size );
 }
 
-/*
-=================
-R_SpecularTexGen
-
-Calculates the specular coordinates for cards without vertex programs.
-=================
-*/
-static void R_SpecularTexGen( drawSurf_t *surf, const idVec3 &globalLightOrigin, const idVec3 &viewOrg ) {
-	const srfTriangles_t *tri;
-	idVec3	localLightOrigin;
-	idVec3	localViewOrigin;
-
-	R_GlobalPointToLocal( surf->space->modelMatrix, globalLightOrigin, localLightOrigin );
-	R_GlobalPointToLocal( surf->space->modelMatrix, viewOrg, localViewOrigin );
-
-	tri = surf->geo;
-
-	// FIXME: change to 3 component?
-	int	size = tri->numVerts * sizeof( idVec4 );
-	idVec4 *texCoords = (idVec4 *) _alloca16( size );
-
-#if 1
-
-	SIMDProcessor->CreateSpecularTextureCoords( texCoords, localLightOrigin, localViewOrigin,
-											tri->verts, tri->numVerts, tri->indexes, tri->numIndexes );
-
-#else
-
-	bool *used = (bool *)_alloca16( tri->numVerts * sizeof( used[0] ) );
-	memset( used, 0, tri->numVerts * sizeof( used[0] ) );
-
-	// because the interaction may be a very small subset of the full surface,
-	// it makes sense to only deal with the verts used
-	for ( int j = 0; j < tri->numIndexes; j++ ) {
-		int i = tri->indexes[j];
-		if ( used[i] ) {
-			continue;
-		}
-		used[i] = true;
-
-		float ilength;
-
-		const idDrawVert *v = &tri->verts[i];
-
-		idVec3 lightDir = localLightOrigin - v->xyz;
-		idVec3 viewDir = localViewOrigin - v->xyz;
-
-		ilength = idMath::RSqrt( lightDir * lightDir );
-		lightDir[0] *= ilength;
-		lightDir[1] *= ilength;
-		lightDir[2] *= ilength;
-
-		ilength = idMath::RSqrt( viewDir * viewDir );
-		viewDir[0] *= ilength;
-		viewDir[1] *= ilength;
-		viewDir[2] *= ilength;
-
-		lightDir += viewDir;
-
-		texCoords[i][0] = lightDir * v->tangents[0];
-		texCoords[i][1] = lightDir * v->tangents[1];
-		texCoords[i][2] = lightDir * v->normal;
-		texCoords[i][3] = 1;
-	}
-
-#endif
-
-	surf->dynamicTexCoords = vertexCache.AllocFrameTemp( texCoords, size );
-}
-
-
 //=======================================================================================================
 
 /*
@@ -542,11 +406,10 @@ Both shadow and light surfaces have been generated.  Either or both surfaces may
 =================
 */
 void idRenderWorldLocal::CreateLightDefInteractions( idRenderLightLocal *ldef ) {
-	areaReference_t		*eref;
-	areaReference_t		*lref;
-	idRenderEntityLocal		*edef;
-	portalArea_t	*area;
-	idInteraction	*inter;
+	areaReference_t		*eref, *lref; // entity, light
+	idRenderEntityLocal	*edef;
+	portalArea_t		*area;
+	
 
 	for ( lref = ldef->references ; lref ; lref = lref->ownerNext ) {
 		area = lref->area;
@@ -583,12 +446,13 @@ void idRenderWorldLocal::CreateLightDefInteractions( idRenderLightLocal *ldef )
 			}
 
 			// if any of the edef's interaction match this light, we don't
-			// need to consider it.
+			// need to consider it. 
+			idInteraction *inter;
 			if ( r_useInteractionTable.GetBool() && this->interactionTable ) {
 				// allocating these tables may take several megs on big maps, but it saves 3% to 5% of
 				// the CPU time.  The table is updated at interaction::AllocAndLink() and interaction::UnlinkAndFree()
-				int index = ldef->index * this->interactionTableWidth + edef->index;
-				inter = this->interactionTable[ index ];
+				//int index = ldef->index * this->interactionTableWidth + edef->index;
+				inter = this->interactionTable[ (ldef->index * this->interactionTableWidth + edef->index) ];
 				if ( inter ) {
 					// if this entity wasn't in view already, the scissor rect will be empty,
 					// so it will only be used for shadow casting
@@ -605,31 +469,24 @@ void idRenderWorldLocal::CreateLightDefInteractions( idRenderLightLocal *ldef )
 				// so the entity chains should be somewhat shorter (they tend to be fairly close).
 				for ( inter = edef->firstInteraction; inter != NULL; inter = inter->entityNext ) {
 					if ( inter->lightDef == ldef ) {
+						if ( !inter->IsEmpty() ) {
+							R_SetEntityDefViewEntity( edef );
+						}
 						break;
 					}
 				}
-
-				// if we already have an interaction, we don't need to do anything
-				if ( inter != NULL ) {
-					// if this entity wasn't in view already, the scissor rect will be empty,
-					// so it will only be used for shadow casting
-					if ( !inter->IsEmpty() ) {
-						R_SetEntityDefViewEntity( edef );
-					}
+				if ( !inter ) {
 					continue;
 				}
 			}
 
-			//
 			// create a new interaction, but don't do any work other than bbox to frustum culling
-			//
-			idInteraction *inter = idInteraction::AllocAndLink( edef, ldef );
+			inter = idInteraction::AllocAndLink( edef, ldef );
 
 			// do a check of the entity reference bounds against the light frustum,
 			// trying to avoid creating a viewEntity if it hasn't been already
 			float	modelMatrix[16];
 			float	*m;
-
 			if ( edef->viewCount == tr.viewCount ) {
 				m = edef->viewEntity->modelMatrix;
 			} else {
@@ -692,15 +549,6 @@ void R_LinkLightSurf( const drawSurf_t **link, const srfTriangles_t *tri, const
 			drawSurf->shaderRegisters = regs;
 			shader->EvaluateRegisters( regs, space->entityDef->parms.shaderParms, tr.viewDef, space->entityDef->parms.referenceSound );
 		}
-
-		// calculate the specular coordinates if we aren't using vertex programs
-		if ( !tr.backEndRendererHasVertexPrograms && !r_skipSpecular.GetBool() ) {
-			R_SpecularTexGen( drawSurf, light->globalLightOrigin, tr.viewDef->renderView.vieworg );
-			// if we failed to allocate space for the specular calculations, drop the surface
-			if ( !drawSurf->dynamicTexCoords ) {
-				return;
-			}
-		}
 	}
 
 	// actually link it in
@@ -724,16 +572,14 @@ idScreenRect R_ClippedLightScissorRectangle( viewLight_t *vLight ) {
 	for ( i = 0 ; i < 6 ; i++ ) {
 		const idWinding *ow = light->frustumWindings[i];
 
-		// projected lights may have one of the frustums degenerated
-		if ( !ow ) {
-			continue;
-		}
-
+		// !ow - projected lights may have one of the frustums degenerated
+		// OR
+		// light->frustum[i].Distance( tr.viewDef->renderView.vieworg ) >= 0
 		// the light frustum planes face out from the light,
 		// so the planes that have the view origin on the negative
 		// side will be the "back" faces of the light, which must have
 		// some fragment inside the portalStack to be visible
-		if ( light->frustum[i].Distance( tr.viewDef->renderView.vieworg ) >= 0 ) {
+		if ( !ow || light->frustum[i].Distance( tr.viewDef->renderView.vieworg ) >= 0 ) {
 			continue;
 		}
 
@@ -791,7 +637,7 @@ The light screen bounds will be used to crop the scissor rect during
 stencil clears and interaction drawing
 ==================
 */
-int	c_clippedLight, c_unclippedLight;
+static int c_clippedLight = 0, c_unclippedLight = 0;
 
 idScreenRect	R_CalcLightScissorRectangle( viewLight_t *vLight ) {
 	idScreenRect	r;
@@ -889,6 +735,7 @@ void R_AddLightSurfaces( void ) {
 		const idMaterial	*lightShader = light->lightShader;
 		if ( !lightShader ) {
 			common->Error( "R_AddLightSurfaces: NULL lightShader" );
+			return;
 		}
 
 		// see if we are suppressing the light in this view
@@ -899,7 +746,7 @@ void R_AddLightSurfaces( void ) {
 				light->viewCount = -1;
 				continue;
 			}
-			if ( light->parms.allowLightInViewID
+			if ( light->parms.allowLightInViewID 
 			&& light->parms.allowLightInViewID != tr.viewDef->renderView.viewID ) {
 				*ptr = vLight->next;
 				light->viewCount = -1;
@@ -972,15 +819,6 @@ void R_AddLightSurfaces( void ) {
 			}
 		}
 
-#if 0
-		// this never happens, because CullLightByPortals() does a more precise job
-		if ( vLight->scissorRect.IsEmpty() ) {
-			// this light doesn't touch anything on screen, so remove it from the list
-			*ptr = vLight->next;
-			continue;
-		}
-#endif
-
 		// this one stays on the list
 		ptr = &vLight->next;
 
@@ -1041,7 +879,7 @@ void R_AddLightSurfaces( void ) {
 			// touch the shadow surface so it won't get purged
 			vertexCache.Touch( tri->shadowCache );
 
-			if ( !tri->indexCache && r_useIndexBuffers.GetBool() ) {
+			if ( !tri->indexCache ) {
 				vertexCache.Alloc( tri->indexes, tri->numIndexes * sizeof( tri->indexes[0] ), &tri->indexCache, true );
 			}
 			if ( tri->indexCache ) {
@@ -1107,22 +945,20 @@ it and any necessary overlays
 ===================
 */
 idRenderModel *R_EntityDefDynamicModel( idRenderEntityLocal *def ) {
-	bool callbackUpdate;
+
+	bool callbackUpdate = false;
 
 	// allow deferred entities to construct themselves
 	if ( def->parms.callback ) {
 		callbackUpdate = R_IssueEntityDefCallback( def );
-	} else {
-		callbackUpdate = false;
 	}
 
 	idRenderModel *model = def->parms.hModel;
 
 	if ( !model ) {
 		common->Error( "R_EntityDefDynamicModel: NULL model" );
-	}
-
-	if ( model->IsDynamicModel() == DM_STATIC ) {
+		return NULL;
+	} else if ( model->IsDynamicModel() == DM_STATIC ) {
 		def->dynamicModel = NULL;
 		def->dynamicModelFrameCount = 0;
 		return model;
@@ -1253,22 +1089,19 @@ void R_AddDrawSurf( const srfTriangles_t *tri, const viewEntity_t *space, const
 			shaderParms = renderEntity->shaderParms;
 		}
 
-		float oldFloatTime = 0.0f;
-		int oldTime = 0;
-
 		if ( space->entityDef && space->entityDef->parms.timeGroup ) {
-			oldFloatTime = tr.viewDef->floatTime;
-			oldTime = tr.viewDef->renderView.time;
+			const float oldFloatTime = tr.viewDef->floatTime;
+			const int oldTime = tr.viewDef->renderView.time;
 
-			tr.viewDef->floatTime = game->GetTimeGroupTime( space->entityDef->parms.timeGroup ) * 0.001;
+			tr.viewDef->floatTime = game->GetTimeGroupTime( space->entityDef->parms.timeGroup ) * 0.001f;
 			tr.viewDef->renderView.time = game->GetTimeGroupTime( space->entityDef->parms.timeGroup );
-		}
 
-		shader->EvaluateRegisters( regs, shaderParms, tr.viewDef, renderEntity->referenceSound );
+			shader->EvaluateRegisters( regs, shaderParms, tr.viewDef, renderEntity->referenceSound );
 
-		if ( space->entityDef && space->entityDef->parms.timeGroup ) {
 			tr.viewDef->floatTime = oldFloatTime;
 			tr.viewDef->renderView.time = oldTime;
+		} else {
+			shader->EvaluateRegisters( regs, shaderParms, tr.viewDef, renderEntity->referenceSound );
 		}
 	}
 
@@ -1279,10 +1112,10 @@ void R_AddDrawSurf( const srfTriangles_t *tri, const viewEntity_t *space, const
 	switch( shader->Texgen() ) {
 		case TG_SKYBOX_CUBE:
 			R_SkyboxTexGen( drawSurf, tr.viewDef->renderView.vieworg );
-			break;
+			return;
 		case TG_WOBBLESKY_CUBE:
 			R_WobbleskyTexGen( drawSurf, tr.viewDef->renderView.vieworg );
-			break;
+			return;
 	}
 
 	// check for gui surfaces
@@ -1302,13 +1135,10 @@ void R_AddDrawSurf( const srfTriangles_t *tri, const viewEntity_t *space, const
 
 	if ( gui ) {
 		// force guis on the fast time
-		float oldFloatTime;
-		int oldTime;
-
-		oldFloatTime = tr.viewDef->floatTime;
-		oldTime = tr.viewDef->renderView.time;
+		const float oldFloatTime = tr.viewDef->floatTime;
+		const int oldTime = tr.viewDef->renderView.time;
 
-		tr.viewDef->floatTime = game->GetTimeGroupTime( 1 ) * 0.001;
+		tr.viewDef->floatTime = game->GetTimeGroupTime( 1 ) * 0.001f;
 		tr.viewDef->renderView.time = game->GetTimeGroupTime( 1 );
 
 		idBounds ndcBounds;
@@ -1374,7 +1204,7 @@ static void R_AddAmbientDrawsurfs( viewEntity_t *vEntity ) {
 
 		R_GlobalShaderOverride( &shader );
 
-		if ( !shader ) {
+		if ( !shader ) {	
 			continue;
 		}
 		if ( !shader->IsDrawn() ) {
@@ -1415,7 +1245,7 @@ static void R_AddAmbientDrawsurfs( viewEntity_t *vEntity ) {
 			// touch it so it won't get purged
 			vertexCache.Touch( tri->ambientCache );
 
-			if ( r_useIndexBuffers.GetBool() && !tri->indexCache ) {
+			if ( !tri->indexCache ) {
 				vertexCache.Alloc( tri->indexes, tri->numIndexes * sizeof( tri->indexes[0] ), &tri->indexCache, true );
 			}
 			if ( tri->indexCache ) {
diff --git a/neo/renderer/tr_local.h b/neo/renderer/tr_local.h
index eca4bc8..897cbc9 100644
--- a/neo/renderer/tr_local.h
+++ b/neo/renderer/tr_local.h
@@ -39,6 +39,9 @@ class idScreenRect; // yay for include recursion
 #include "renderer/RenderSystem.h"
 #include "renderer/RenderWorld.h"
 
+#include "renderer/RenderLog.h"
+#include "renderer/RenderProgs.h"
+
 class idRenderWorldLocal;
 
 // everything that is needed by the backend needs
@@ -46,6 +49,9 @@ class idRenderWorldLocal;
 // parallel on a dual cpu machine
 const int SMP_FRAMES = 1;
 
+// maximum texture units
+const int MAX_PROG_TEXTURE_PARMS = 16;
+
 const int FALLOFF_TEXTURE_SIZE =	64;
 
 const float	DEFAULT_FOG_DISTANCE = 500.0f;
@@ -444,11 +450,11 @@ typedef struct {
 	idImage *			diffuseImage;
 	idImage *			specularImage;
 
-	idVec4				diffuseColor;	// may have a light color baked into it, will be < tr.backEndRendererMaxLight
-	idVec4				specularColor;	// may have a light color baked into it, will be < tr.backEndRendererMaxLight
+	idVec4				diffuseColor;	// may have a light color baked into it
+	idVec4				specularColor;	// may have a light color baked into it
 	stageVertexColor_t	vertexColor;	// applies to both diffuse and specular
 
-	int					ambientLight;	// use tr.ambientNormalMap instead of normalization cube map
+	int					ambientLight;	// use tr.ambientNormalMap instead of normalization cube map 
 	// (not a bool just to avoid an uninitialized memory check of the pad region by valgrind)
 
 	// these are loaded into the vertex program
@@ -595,7 +601,6 @@ typedef struct {
 
 typedef struct {
 	int		current2DMap;
-	int		current3DMap;
 	int		currentCubeMap;
 	int		texEnv;
 	textureType_t	textureType;
@@ -632,7 +637,6 @@ typedef struct {
 	int		c_vboIndexes;
 	float	c_overDraw;
 
-	float	maxLightValue;	// for light scale
 	int		msec;			// total msec for backend run
 } backEndCounters_t;
 
@@ -652,13 +656,6 @@ typedef struct {
 	float				lightTextureMatrix[16];	// only if lightStage->texture.hasMatrix
 	float				lightColor[4];		// evaluation of current light's color stage
 
-	float				lightScale;			// Every light color calaculation will be multiplied by this,
-											// which will guarantee that the result is < tr.backEndRendererMaxLight
-											// A card with high dynamic range will have this set to 1.0
-	float				overBright;			// The amount that all light interactions must be multiplied by
-											// with post processing to get the desired total light level.
-											// A high dynamic range card will have this set to 1.0.
-
 	bool				currentRenderCopied;	// true if any material has already referenced _currentRender
 
 	// our OpenGL state deltas
@@ -671,10 +668,6 @@ typedef struct {
 const int MAX_GUI_SURFACES	= 1024;		// default size of the drawSurfs list for guis, will
 										// be automatically expanded as needed
 
-typedef enum {
-	BE_ARB2,
-	BE_BAD
-} backEndName_t;
 
 typedef struct {
 	int		x, y, width, height;	// these are in physical, OpenGL Y-at-bottom pixels
@@ -735,7 +728,6 @@ public:
 							~idRenderSystemLocal( void );
 
 	void					Clear( void );
-	void					SetBackEndRenderer();			// sets tr.backEndRenderer based on cvars
 	void					RenderViewToViewport( const renderView_t *renderView, idScreenRect *viewport );
 
 public:
@@ -754,14 +746,7 @@ public:
 
 	int						viewportOffset[2];	// for doing larger-than-window tiled renderings
 	int						tiledViewport[2];
-
-	// determines which back end to use, and if vertex programs are in use
-	backEndName_t			backEndRenderer;
-	bool					backEndRendererHasVertexPrograms;
-	float					backEndRendererMaxLight;	// 1.0 for standard, unlimited for floats
-														// determines how much overbrighting needs
-														// to be done post-process
-
+	
 	idVec4					ambientLightVector;	// used for "ambient bump mapping"
 
 	float					sortOffset;				// for determinist sorting of equal sort materials
@@ -787,6 +772,7 @@ public:
 	drawSurfsCommand_t		lockSurfacesCmd;	// use this when r_lockSurfaces = 1
 
 	viewEntity_t			identitySpace;		// can use if we don't know viewDef->worldSpace is valid
+
 	int						stencilIncr, stencilDecr;	// GL_INCR / INCR_WRAP_EXT, GL_DECR / GL_DECR_EXT
 
 	renderCrop_t			renderCrops[MAX_RENDER_CROPS];
@@ -796,6 +782,8 @@ public:
 	int						guiRecursionLevel;		// to prevent infinite overruns
 	class idGuiModel *		guiModel;
 	class idGuiModel *		demoGuiModel;
+
+	unsigned short			gammaTable[256];	// brightness / gamma modify this
 };
 
 extern backEndState_t		backEnd;
@@ -806,7 +794,9 @@ extern glconfig_t			glConfig;		// outside of TR since it shouldn't be cleared du
 //
 // cvars
 //
-extern idCVar r_mode;					// video mode number
+extern idCVar r_debugContext;			// enable various levels of context debug
+extern idCVar r_glDriver;				// "opengl32", etc
+extern idCVar r_vidMode;					// video mode number
 extern idCVar r_displayRefresh;			// optional display refresh rate option for vid mode
 extern idCVar r_fullscreen;				// 0 = windowed, 1 = full screen
 extern idCVar r_multiSamples;			// number of antialiasing samples
@@ -817,10 +807,10 @@ extern idCVar r_znear;					// near Z clip plane
 
 extern idCVar r_finish;					// force a call to glFinish() every frame
 extern idCVar r_frontBuffer;			// draw to front buffer for debugging
-extern idCVar r_swapInterval;			// changes the GL swap interval
+extern idCVar r_swapInterval;			// changes wglSwapIntarval
 extern idCVar r_offsetFactor;			// polygon offset parameter
 extern idCVar r_offsetUnits;			// polygon offset parameter
-extern idCVar r_singleTriangle;			// only draw a single triangle per primitive
+extern idCVar r_logFile;				// number of frames to emit GL logs
 extern idCVar r_clear;					// force screen clear every frame
 extern idCVar r_shadows;				// enable shadows
 extern idCVar r_subviewOnly;			// 1 = don't render main view, allowing subviews to be debugged
@@ -830,8 +820,6 @@ extern idCVar r_flareSize;				// scale the flare deforms from the material def
 extern idCVar r_gamma;					// changes gamma tables
 extern idCVar r_brightness;				// changes gamma tables
 
-extern idCVar r_renderer;				// arb2, etc
-
 extern idCVar r_checkBounds;			// compare all surface bounds with precalculated ones
 
 extern idCVar r_useLightPortalFlow;		// 1 = do a more precise area reference determination
@@ -854,7 +842,6 @@ extern idCVar r_usePreciseTriangleInteractions;	// 1 = do winding clipping to de
 extern idCVar r_useTurboShadow;			// 1 = use the infinite projection with W technique for dynamic shadows
 extern idCVar r_useExternalShadows;		// 1 = skip drawing caps when outside the light volume
 extern idCVar r_useOptimizedShadows;	// 1 = use the dmap generated static shadow volumes
-extern idCVar r_useShadowVertexProgram;	// 1 = do the shadow projection in the vertex program on capable cards
 extern idCVar r_useShadowProjectedCull;	// 1 = discard triangles outside light volume before shadowing
 extern idCVar r_useDeferredTangents;	// 1 = don't always calc tangents after deform
 extern idCVar r_useCachedDynamicModels;	// 1 = cache snapshots of dynamic models
@@ -863,9 +850,6 @@ extern idCVar r_useInfiniteFarZ;		// 1 = use the no-far-clip-plane trick
 extern idCVar r_useScissor;				// 1 = scissor clip as portals and lights are processed
 extern idCVar r_usePortals;				// 1 = use portals to perform area culling, otherwise draw everything
 extern idCVar r_useStateCaching;		// avoid redundant state changes in GL_*() calls
-extern idCVar r_useCombinerDisplayLists;// if 1, put all nvidia register combiner programming in display lists
-extern idCVar r_useVertexBuffers;		// if 0, don't use ARB_vertex_buffer_object for vertexes
-extern idCVar r_useIndexBuffers;		// if 0, don't use ARB_vertex_buffer_object for indexes
 extern idCVar r_useEntityCallbacks;		// if 0, issue the callback immediately at update time, rather than defering
 extern idCVar r_lightAllBackFaces;		// light all the back faces, even when they would be shadowed
 extern idCVar r_useDepthBoundsTest;     // use depth bounds test to reduce shadow fill
@@ -877,7 +861,6 @@ extern idCVar r_skipFrontEnd;			// bypasses all front end work, but 2D gui rende
 extern idCVar r_skipBackEnd;			// don't draw anything
 extern idCVar r_skipCopyTexture;		// do all rendering, but don't actually copyTexSubImage2D
 extern idCVar r_skipRender;				// skip 3D rendering, but pass 2D
-extern idCVar r_skipRenderContext;		// NULL the rendering context during backend 3D rendering
 extern idCVar r_skipTranslucent;		// skip the translucent interaction rendering
 extern idCVar r_skipAmbient;			// bypasses all non-interaction drawing
 extern idCVar r_skipNewAmbient;			// bypasses all vertex/fragment program ambients
@@ -889,7 +872,6 @@ extern idCVar r_skipParticles;			// 1 = don't render any particles
 extern idCVar r_skipUpdates;			// 1 = don't accept any entity or light updates, making everything static
 extern idCVar r_skipDeforms;			// leave all deform materials in their original state
 extern idCVar r_skipDynamicTextures;	// don't dynamically create textures
-extern idCVar r_skipLightScale;			// don't do any post-interaction light scaling, makes things dim on low-dynamic range cards
 extern idCVar r_skipBump;				// uses a flat surface instead of the bump map
 extern idCVar r_skipSpecular;			// use black for specular
 extern idCVar r_skipDiffuse;			// use black for diffuse
@@ -908,7 +890,6 @@ extern idCVar r_showVertexColor;		// draws all triangles with the solid vertex c
 extern idCVar r_showUpdates;			// report entity and light updates and ref counts
 extern idCVar r_showDemo;				// report reads and writes to the demo file
 extern idCVar r_showDynamic;			// report stats on dynamic surface generation
-extern idCVar r_showLightScale;			// report the scale factor applied to drawing for overbrights
 extern idCVar r_showIntensity;			// draw the screen colors based on intensity, red = 0, green = 128, blue = 255
 extern idCVar r_showDefs;				// report the number of modeDefs and lightDefs in view
 extern idCVar r_showTrace;				// show the intersection of an eye trace with the world
@@ -948,8 +929,6 @@ extern idCVar r_testGamma;				// draw a grid pattern to test gamma levels
 extern idCVar r_testStepGamma;			// draw a grid pattern to test gamma levels
 extern idCVar r_testGammaBias;			// draw a grid pattern to test gamma levels
 
-extern idCVar r_testARBProgram;			// experiment with vertex/fragment programs
-
 extern idCVar r_singleLight;			// suppress all but one light
 extern idCVar r_singleEntity;			// suppress all but one entity
 extern idCVar r_singleArea;				// only draw the portal area the view is actually in
@@ -971,6 +950,8 @@ extern idCVar r_materialOverride;		// override all materials
 
 extern idCVar r_debugRenderToTexture;
 
+extern idCVar stereoRender_deGhost;		// subtract from opposite eye to reduce ghosting
+
 /*
 ====================================================================
 
@@ -1023,11 +1004,6 @@ const int GLS_DEPTHFUNC_ALWAYS					= 0x00010000;
 const int GLS_DEPTHFUNC_EQUAL					= 0x00020000;
 const int GLS_DEPTHFUNC_LESS					= 0x0;
 
-const int GLS_ATEST_EQ_255						= 0x10000000;
-const int GLS_ATEST_LT_128						= 0x20000000;
-const int GLS_ATEST_GE_128						= 0x40000000;
-const int GLS_ATEST_BITS						= 0x70000000;
-
 const int GLS_DEFAULT							= GLS_DEPTHFUNC_ALWAYS;
 
 void R_Init( void );
@@ -1040,7 +1016,7 @@ void R_SetColorMappings( void );
 void R_ScreenShot_f( const idCmdArgs &args );
 void R_StencilShot( void );
 
-bool R_CheckExtension( const char *name );
+bool R_CheckExtension( char *name );
 
 
 /*
@@ -1051,14 +1027,48 @@ IMPLEMENTATION SPECIFIC FUNCTIONS
 ====================================================================
 */
 
-typedef struct {
+struct vidMode_t {
+	int width;
+	int height;
+	int displayHz;
+	
+	vidMode_t()	{
+		width = 640;
+		height = 480;
+		displayHz = 60;
+	}
+	
+	vidMode_t( int width, int height, int displayHz ) :
+		width( width ), height( height ), displayHz( displayHz ) {}
+	
+	bool operator==( const vidMode_t& a ) {
+		return a.width == width && a.height == height && a.displayHz == displayHz;
+	}
+};
+
+bool R_IsInitialized();
+
+// the number of displays can be found by itterating this until it returns false
+// displayNum is the 0 based value passed to EnumDisplayDevices(), you must add
+// 1 to this to get an r_fullScreen value.
+bool R_GetModeListForDisplay( const int displayNum, idList<vidMode_t>& modeList );
+
+struct glimpParms_t
+{
+	int			x;				// ignored in fullscreen
+	int			y;				// ignored in fullscreen
 	int			width;
 	int			height;
-	bool		fullScreen;
+	int			fullScreen;		// 0 = windowed, otherwise 1 based monitor number to go full screen on
+	// -1 = borderless window for spanning multiple displays
 	bool		stereo;
 	int			displayHz;
 	int			multiSamples;
-} glimpParms_t;
+};
+
+// R_GetModeListForDisplay is called before GLimp_Init(), but SDL needs SDL_Init() first.
+// So add PreInit for platforms that need it, others can just stub it.
+void		GLimp_PreInit();
 
 bool		GLimp_Init( glimpParms_t parms );
 // If the desired mode can't be set satisfactorily, false will be returned.
@@ -1077,7 +1087,7 @@ void		GLimp_SwapBuffers( void );
 // other system specific cvar checks that happen every frame.
 // This will not be called if 'r_drawBuffer GL_FRONT'
 
-void		GLimp_SetGamma( unsigned short red[256],
+void		GLimp_SetGamma( unsigned short red[256], 
 							unsigned short green[256],
 							unsigned short blue[256] );
 // Sets the hardware gamma ramps for gamma and brightness adjustment.
@@ -1085,24 +1095,13 @@ void		GLimp_SetGamma( unsigned short red[256],
 // of dacs with >8 bits of precision
 
 
-// Returns false if the system only has a single processor
-
-void		GLimp_ActivateContext( void );
-void		GLimp_DeactivateContext( void );
-// These are used for managing SMP handoffs of the OpenGL context
-// between threads, and as a performance tunining aid.  Setting
-// 'r_skipRenderContext 1' will call GLimp_DeactivateContext() before
-// the 3D rendering code, and GLimp_ActivateContext() afterwards.  On
-// most OpenGL implementations, this will result in all OpenGL calls
-// being immediate returns, which lets us guage how much time is
-// being spent inside OpenGL.
-
 const int GRAB_ENABLE		= (1 << 0);
 const int GRAB_REENABLE		= (1 << 1);
 const int GRAB_HIDECURSOR	= (1 << 2);
 const int GRAB_SETSTATE		= (1 << 3);
 
 void GLimp_GrabInput(int flags);
+
 /*
 ====================================================================
 
@@ -1166,7 +1165,6 @@ void R_LinkLightSurf( const drawSurf_t **link, const srfTriangles_t *tri, const
 				   const idRenderLightLocal *light, const idMaterial *shader, const idScreenRect &scissor, bool viewInsideShadow );
 
 bool R_CreateAmbientCache( srfTriangles_t *tri, bool needsLighting );
-bool R_CreateLightingCache( const idRenderEntityLocal *ent, const idRenderLightLocal *light, srfTriangles_t *tri );
 void R_CreatePrivateShadowCache( srfTriangles_t *tri );
 void R_CreateVertexProgramShadowCache( srfTriangles_t *tri );
 
@@ -1226,15 +1224,15 @@ RENDER
 ============================================================
 */
 
-void RB_EnterWeaponDepthHack();
-void RB_EnterModelDepthHack( float depth );
-void RB_LeaveDepthHack();
+void RB_EnterWeaponDepthHack( const drawSurf_t *surf );
+void RB_EnterModelDepthHack( const drawSurf_t *surf );
+void RB_LeaveDepthHack( const drawSurf_t *surf );
 void RB_DrawElementsImmediate( const srfTriangles_t *tri );
 void RB_RenderTriangleSurface( const srfTriangles_t *tri );
 void RB_T_RenderTriangleSurface( const drawSurf_t *surf );
-void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs,
+void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs, 
 					  void (*triFunc_)( const drawSurf_t *) );
-void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs,
+void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs, 
 										void (*triFunc_)( const drawSurf_t *) );
 void RB_DrawShaderPasses( drawSurf_t **drawSurfs, int numDrawSurfs );
 void RB_LoadShaderTextureMatrix( const float *shaderRegisters, const textureStage_t *texture );
@@ -1245,8 +1243,6 @@ const shaderStage_t *RB_SetLightTexture( const idRenderLightLocal *light );
 
 void RB_DrawView( const void *data );
 
-void RB_DetermineLightScale( void );
-void RB_STD_LightScale( void );
 void RB_BeginDrawingView (void);
 
 /*
@@ -1261,8 +1257,6 @@ void RB_DrawElementsWithCounters( const srfTriangles_t *tri );
 void RB_DrawShadowElementsWithCounters( const srfTriangles_t *tri, int numIndexes );
 void RB_STD_FillDepthBuffer( drawSurf_t **drawSurfs, int numDrawSurfs );
 void RB_BindVariableStageImage( const textureStage_t *texture, const float *shaderRegisters );
-void RB_BindStageTexture( const float *shaderRegisters, const textureStage_t *texture, const drawSurf_t *surf );
-void RB_FinishStageTexture( const textureStage_t *texture, const drawSurf_t *surf );
 void RB_StencilShadowPass( const drawSurf_t *drawSurfs );
 void RB_STD_DrawView( void );
 void RB_STD_FogAllLights( void );
@@ -1277,7 +1271,7 @@ DRAW_*
 */
 
 void	R_ARB2_Init( void );
-void	RB_ARB2_DrawInteractions( void );
+
 void	R_ReloadARBPrograms_f( const idCmdArgs &args );
 int		R_FindARBProgram( GLenum target, const char *program );
 
@@ -1287,11 +1281,9 @@ typedef enum {
 	VPROG_ENVIRONMENT,
 	VPROG_BUMPY_ENVIRONMENT,
 	VPROG_STENCIL_SHADOW,
-	VPROG_TEST,
 	FPROG_INTERACTION,
 	FPROG_ENVIRONMENT,
 	FPROG_BUMPY_ENVIRONMENT,
-	FPROG_TEST,
 	VPROG_AMBIENT,
 	FPROG_AMBIENT,
 	VPROG_GLASSWARP,
@@ -1384,11 +1376,7 @@ calling this function may modify "facing" based on culling
 ============================================================
 */
 
-srfTriangles_t *R_CreateVertexProgramTurboShadowVolume( const idRenderEntityLocal *ent,
-									 const srfTriangles_t *tri, const idRenderLightLocal *light,
-									 srfCullInfo_t &cullInfo );
-
-srfTriangles_t *R_CreateTurboShadowVolume( const idRenderEntityLocal *ent,
+srfTriangles_t *R_CreateTurboShadowVolume(const idRenderEntityLocal *ent,
 									 const srfTriangles_t *tri, const idRenderLightLocal *light,
 									 srfCullInfo_t &cullInfo );
 
@@ -1416,7 +1404,7 @@ typedef struct {
 	int		totalIndexes;
 } optimizedShadow_t;
 
-optimizedShadow_t SuperOptimizeOccluders( idVec4 *verts, glIndex_t *indexes, int numIndexes,
+optimizedShadow_t SuperOptimizeOccluders( idVec4 *verts, glIndex_t *indexes, int numIndexes, 
 										 idPlane projectionPlane, idVec3 projectionOrigin );
 
 void CleanupOptimizedShadowTris( srfTriangles_t *tri );
diff --git a/neo/renderer/tr_render.cpp b/neo/renderer/tr_render.cpp
index 92cbca0..ad03584 100644
--- a/neo/renderer/tr_render.cpp
+++ b/neo/renderer/tr_render.cpp
@@ -2,9 +2,9 @@
 ===========================================================================
 
 Doom 3 GPL Source Code
-Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company.
+Copyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. 
 
-This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").
+This file is part of the Doom 3 GPL Source Code ("Doom 3 Source Code").  
 
 Doom 3 Source Code is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
@@ -91,18 +91,18 @@ void RB_DrawElementsWithCounters( const srfTriangles_t *tri ) {
 		}
 	}
 
-	if ( tri->indexCache && r_useIndexBuffers.GetBool() ) {
-		qglDrawElements( GL_TRIANGLES,
-						r_singleTriangle.GetBool() ? 3 : tri->numIndexes,
+	renderProgManager.CommitUniforms();
+	
+	if ( tri->indexCache ) {
+		qglDrawElements( GL_TRIANGLES, 
+						tri->numIndexes,
 						GL_INDEX_TYPE,
 						(int *)vertexCache.Position( tri->indexCache ) );
 		backEnd.pc.c_vboIndexes += tri->numIndexes;
 	} else {
-		if ( r_useIndexBuffers.GetBool() ) {
-			vertexCache.UnbindIndex();
-		}
-		qglDrawElements( GL_TRIANGLES,
-						r_singleTriangle.GetBool() ? 3 : tri->numIndexes,
+		vertexCache.UnbindIndex();
+		qglDrawElements( GL_TRIANGLES, 
+						tri->numIndexes,
 						GL_INDEX_TYPE,
 						tri->indexes );
 	}
@@ -120,18 +120,16 @@ void RB_DrawShadowElementsWithCounters( const srfTriangles_t *tri, int numIndexe
 	backEnd.pc.c_shadowIndexes += numIndexes;
 	backEnd.pc.c_shadowVertexes += tri->numVerts;
 
-	if ( tri->indexCache && r_useIndexBuffers.GetBool() ) {
-		qglDrawElements( GL_TRIANGLES,
-						r_singleTriangle.GetBool() ? 3 : numIndexes,
+	if ( tri->indexCache ) {
+		qglDrawElements( GL_TRIANGLES, 
+						numIndexes,
 						GL_INDEX_TYPE,
 						(int *)vertexCache.Position( tri->indexCache ) );
 		backEnd.pc.c_vboIndexes += numIndexes;
 	} else {
-		if ( r_useIndexBuffers.GetBool() ) {
-			vertexCache.UnbindIndex();
-		}
-		qglDrawElements( GL_TRIANGLES,
-						r_singleTriangle.GetBool() ? 3 : numIndexes,
+		vertexCache.UnbindIndex();
+		qglDrawElements( GL_TRIANGLES, 
+						numIndexes,
 						GL_INDEX_TYPE,
 						tri->indexes );
 	}
@@ -151,7 +149,6 @@ void RB_RenderTriangleSurface( const srfTriangles_t *tri ) {
 		return;
 	}
 
-
 	idDrawVert *ac = (idDrawVert *)vertexCache.Position( tri->ambientCache );
 	qglVertexPointer( 3, GL_FLOAT, sizeof( idDrawVert ), ac->xyz.ToFloatPtr() );
 	qglTexCoordPointer( 2, GL_FLOAT, sizeof( idDrawVert ), ac->st.ToFloatPtr() );
@@ -174,7 +171,7 @@ void RB_T_RenderTriangleSurface( const drawSurf_t *surf ) {
 RB_EnterWeaponDepthHack
 ===============
 */
-void RB_EnterWeaponDepthHack() {
+void RB_EnterWeaponDepthHack( const drawSurf_t *surf ) {
 	qglDepthRange( 0, 0.5 );
 
 	float	matrix[16];
@@ -186,6 +183,10 @@ void RB_EnterWeaponDepthHack() {
 	qglMatrixMode(GL_PROJECTION);
 	qglLoadMatrixf( matrix );
 	qglMatrixMode(GL_MODELVIEW);
+
+	float  mat[16];
+	myGlMultMatrix(surf->space->modelViewMatrix, matrix, mat);
+	renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
 }
 
 /*
@@ -193,18 +194,22 @@ void RB_EnterWeaponDepthHack() {
 RB_EnterModelDepthHack
 ===============
 */
-void RB_EnterModelDepthHack( float depth ) {
+void RB_EnterModelDepthHack( const drawSurf_t *surf ) {
 	qglDepthRange( 0.0f, 1.0f );
 
 	float	matrix[16];
 
 	memcpy( matrix, backEnd.viewDef->projectionMatrix, sizeof( matrix ) );
 
-	matrix[14] -= depth;
+	matrix[14] -= surf->space->modelDepthHack;
 
 	qglMatrixMode(GL_PROJECTION);
 	qglLoadMatrixf( matrix );
 	qglMatrixMode(GL_MODELVIEW);
+
+	float  mat[16];
+	myGlMultMatrix(surf->space->modelViewMatrix, matrix, mat);
+	renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
 }
 
 /*
@@ -212,12 +217,16 @@ void RB_EnterModelDepthHack( float depth ) {
 RB_LeaveDepthHack
 ===============
 */
-void RB_LeaveDepthHack() {
+void RB_LeaveDepthHack( const drawSurf_t *surf ) {
 	qglDepthRange( 0, 1 );
 
 	qglMatrixMode(GL_PROJECTION);
 	qglLoadMatrixf( backEnd.viewDef->projectionMatrix );
 	qglMatrixMode(GL_MODELVIEW);
+
+	float  mat[16];
+	myGlMultMatrix(surf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat);
+	renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
 }
 
 /*
@@ -230,7 +239,7 @@ matrix will already have been loaded, and backEnd.currentSpace will
 be updated after the triangle function completes.
 ====================
 */
-void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs,
+void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs, 
 											  void (*triFunc_)( const drawSurf_t *) ) {
 	int				i;
 	const drawSurf_t		*drawSurf;
@@ -243,20 +252,28 @@ void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs
 		// change the matrix if needed
 		if ( drawSurf->space != backEnd.currentSpace ) {
 			qglLoadMatrixf( drawSurf->space->modelViewMatrix );
+
+			float  mat[16];
+			myGlMultMatrix(drawSurf->space->modelViewMatrix, backEnd.viewDef->projectionMatrix, mat);
+			renderProgManager.SetRenderParms( RENDERPARM_MVPMATRIX_X, mat, 4 );
+ 
+			// we need the model matrix without it being combined with the view matrix
+			// so we can transform local vectors to global coordinates
+			renderProgManager.SetRenderParms( RENDERPARM_MODELMATRIX_X, drawSurf->space->modelMatrix, 4 );
 		}
 
 		if ( drawSurf->space->weaponDepthHack ) {
-			RB_EnterWeaponDepthHack();
+			RB_EnterWeaponDepthHack( drawSurf );
 		}
 
 		if ( drawSurf->space->modelDepthHack != 0.0f ) {
-			RB_EnterModelDepthHack( drawSurf->space->modelDepthHack );
+			RB_EnterModelDepthHack( drawSurf );
 		}
 
 		// change the scissor if needed
 		if ( r_useScissor.GetBool() && !backEnd.currentScissor.Equals( drawSurf->scissorRect ) ) {
 			backEnd.currentScissor = drawSurf->scissorRect;
-			qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+			qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1, 
 				backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
 				backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
 				backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
@@ -266,7 +283,7 @@ void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs
 		triFunc_( drawSurf );
 
 		if ( drawSurf->space->weaponDepthHack || drawSurf->space->modelDepthHack != 0.0f ) {
-			RB_LeaveDepthHack();
+			RB_LeaveDepthHack( drawSurf );
 		}
 
 		backEnd.currentSpace = drawSurf->space;
@@ -278,7 +295,7 @@ void RB_RenderDrawSurfListWithFunction( drawSurf_t **drawSurfs, int numDrawSurfs
 RB_RenderDrawSurfChainWithFunction
 ======================
 */
-void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs,
+void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs, 
 										void (*triFunc_)( const drawSurf_t *) ) {
 	const drawSurf_t		*drawSurf;
 
@@ -291,17 +308,17 @@ void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs,
 		}
 
 		if ( drawSurf->space->weaponDepthHack ) {
-			RB_EnterWeaponDepthHack();
+			RB_EnterWeaponDepthHack( drawSurf );
 		}
 
 		if ( drawSurf->space->modelDepthHack ) {
-			RB_EnterModelDepthHack( drawSurf->space->modelDepthHack );
+			RB_EnterModelDepthHack( drawSurf );
 		}
 
 		// change the scissor if needed
 		if ( r_useScissor.GetBool() && !backEnd.currentScissor.Equals( drawSurf->scissorRect ) ) {
 			backEnd.currentScissor = drawSurf->scissorRect;
-			qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+			qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1, 
 				backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
 				backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
 				backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
@@ -311,7 +328,7 @@ void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs,
 		triFunc_( drawSurf );
 
 		if ( drawSurf->space->weaponDepthHack || drawSurf->space->modelDepthHack != 0.0f ) {
-			RB_LeaveDepthHack();
+			RB_LeaveDepthHack( drawSurf );
 		}
 
 		backEnd.currentSpace = drawSurf->space;
@@ -323,36 +340,35 @@ void RB_RenderDrawSurfChainWithFunction( const drawSurf_t *drawSurfs,
 RB_GetShaderTextureMatrix
 ======================
 */
-void RB_GetShaderTextureMatrix( const float *shaderRegisters,
-							   const textureStage_t *texture, float matrix[16] ) {
-	matrix[0] = shaderRegisters[ texture->matrix[0][0] ];
-	matrix[4] = shaderRegisters[ texture->matrix[0][1] ];
-	matrix[8] = 0;
-	matrix[12] = shaderRegisters[ texture->matrix[0][2] ];
+void RB_GetShaderTextureMatrix( const float *shaderRegisters, const textureStage_t *texture, float matrix[16] ) {
+	matrix[0*4+0] = shaderRegisters[ texture->matrix[0][0] ];
+	matrix[1*4+0] = shaderRegisters[ texture->matrix[0][1] ];
+	matrix[2*4+0] = 0.0f;
+	matrix[3*4+0] = shaderRegisters[ texture->matrix[0][2] ];
+
+	matrix[0*4+1] = shaderRegisters[ texture->matrix[1][0] ];
+	matrix[1*4+1] = shaderRegisters[ texture->matrix[1][1] ];
+	matrix[2*4+1] = 0.0f;
+	matrix[3*4+1] = shaderRegisters[ texture->matrix[1][2] ];
 
 	// we attempt to keep scrolls from generating incredibly large texture values, but
 	// center rotations and center scales can still generate offsets that need to be > 1
-	if ( matrix[12] < -40 || matrix[12] > 40 ) {
-		matrix[12] -= (int)matrix[12];
+	if ( matrix[3*4+0] < -40.0f || matrix[12] > 40.0f ) {
+		matrix[3*4+0] -= (int)matrix[3*4+0];
 	}
-
-	matrix[1] = shaderRegisters[ texture->matrix[1][0] ];
-	matrix[5] = shaderRegisters[ texture->matrix[1][1] ];
-	matrix[9] = 0;
-	matrix[13] = shaderRegisters[ texture->matrix[1][2] ];
-	if ( matrix[13] < -40 || matrix[13] > 40 ) {
+	if ( matrix[13] < -40.0f || matrix[13] > 40.0f ) {
 		matrix[13] -= (int)matrix[13];
 	}
 
-	matrix[2] = 0;
-	matrix[6] = 0;
-	matrix[10] = 1;
-	matrix[14] = 0;
+	matrix[0*4+2] = 0.0f;
+	matrix[1*4+2] = 0.0f;
+	matrix[2*4+2] = 1.0f;
+	matrix[3*4+2] = 0.0f;
 
-	matrix[3] = 0;
-	matrix[7] = 0;
-	matrix[11] = 0;
-	matrix[15] = 1;
+	matrix[0*4+3] = 0.0f;
+	matrix[1*4+3] = 0.0f;
+	matrix[2*4+3] = 0.0f;
+	matrix[3*4+3] = 1.0f;
 }
 
 /*
@@ -367,6 +383,32 @@ void RB_LoadShaderTextureMatrix( const float *shaderRegisters, const textureStag
 	qglMatrixMode( GL_TEXTURE );
 	qglLoadMatrixf( matrix );
 	qglMatrixMode( GL_MODELVIEW );
+
+	float texS[4] = { 1.0f, 0.0f, 0.0f, 0.0f };
+	float texT[4] = { 0.0f, 1.0f, 0.0f, 0.0f };
+
+	if ( texture->hasMatrix ) {
+//		float matrix[16];
+//		RB_GetShaderTextureMatrix( shaderRegisters, texture, matrix );
+		texS[0] = matrix[0*4+0];
+		texS[1] = matrix[1*4+0];
+		texS[2] = matrix[2*4+0];
+		texS[3] = matrix[3*4+0];
+	
+		texT[0] = matrix[0*4+1];
+		texT[1] = matrix[1*4+1];
+		texT[2] = matrix[2*4+1];
+		texT[3] = matrix[3*4+1];
+
+		RENDERLOG_PRINTF( "Setting Texture Matrix\n");
+		renderLog.Indent();
+		RENDERLOG_PRINTF( "Texture Matrix S : %4.3f, %4.3f, %4.3f, %4.3f\n", texS[0], texS[1], texS[2], texS[3] );
+		RENDERLOG_PRINTF( "Texture Matrix T : %4.3f, %4.3f, %4.3f, %4.3f\n", texT[0], texT[1], texT[2], texT[3] );
+		renderLog.Outdent();
+	} 
+
+	renderProgManager.SetRenderParm( RENDERPARM_TEXTUREMATRIX_S, texS );
+	renderProgManager.SetRenderParm( RENDERPARM_TEXTUREMATRIX_T, texT );
 }
 
 /*
@@ -403,150 +445,12 @@ void RB_BindVariableStageImage( const textureStage_t *texture, const float *shad
 	}
 }
 
-/*
-======================
-RB_BindStageTexture
-======================
-*/
-void RB_BindStageTexture( const float *shaderRegisters, const textureStage_t *texture, const drawSurf_t *surf ) {
-	// image
-	RB_BindVariableStageImage( texture, shaderRegisters );
-
-	// texgens
-	if ( texture->texgen == TG_DIFFUSE_CUBE ) {
-		qglTexCoordPointer( 3, GL_FLOAT, sizeof( idDrawVert ), ((idDrawVert *)vertexCache.Position( surf->geo->ambientCache ))->normal.ToFloatPtr() );
-	}
-	if ( texture->texgen == TG_SKYBOX_CUBE || texture->texgen == TG_WOBBLESKY_CUBE ) {
-		qglTexCoordPointer( 3, GL_FLOAT, 0, vertexCache.Position( surf->dynamicTexCoords ) );
-	}
-	if ( texture->texgen == TG_REFLECT_CUBE ) {
-		qglEnable( GL_TEXTURE_GEN_S );
-		qglEnable( GL_TEXTURE_GEN_T );
-		qglEnable( GL_TEXTURE_GEN_R );
-		qglTexGenf( GL_S, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-		qglTexGenf( GL_T, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-		qglTexGenf( GL_R, GL_TEXTURE_GEN_MODE, GL_REFLECTION_MAP_EXT );
-		qglEnableClientState( GL_NORMAL_ARRAY );
-		qglNormalPointer( GL_FLOAT, sizeof( idDrawVert ), ((idDrawVert *)vertexCache.Position( surf->geo->ambientCache ))->normal.ToFloatPtr() );
-
-		qglMatrixMode( GL_TEXTURE );
-		float	mat[16];
-
-		R_TransposeGLMatrix( backEnd.viewDef->worldSpace.modelViewMatrix, mat );
-
-		qglLoadMatrixf( mat );
-		qglMatrixMode( GL_MODELVIEW );
-	}
-
-	// matrix
-	if ( texture->hasMatrix ) {
-		RB_LoadShaderTextureMatrix( shaderRegisters, texture );
-	}
-}
-
-/*
-======================
-RB_FinishStageTexture
-======================
-*/
-void RB_FinishStageTexture( const textureStage_t *texture, const drawSurf_t *surf ) {
-	if ( texture->texgen == TG_DIFFUSE_CUBE || texture->texgen == TG_SKYBOX_CUBE
-		|| texture->texgen == TG_WOBBLESKY_CUBE ) {
-		qglTexCoordPointer( 2, GL_FLOAT, sizeof( idDrawVert ),
-			(void *)&(((idDrawVert *)vertexCache.Position( surf->geo->ambientCache ))->st) );
-	}
-
-	if ( texture->texgen == TG_REFLECT_CUBE ) {
-		qglDisable( GL_TEXTURE_GEN_S );
-		qglDisable( GL_TEXTURE_GEN_T );
-		qglDisable( GL_TEXTURE_GEN_R );
-		qglTexGenf( GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-		qglTexGenf( GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-		qglTexGenf( GL_R, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
-		qglDisableClientState( GL_NORMAL_ARRAY );
-
-		qglMatrixMode( GL_TEXTURE );
-		qglLoadIdentity();
-		qglMatrixMode( GL_MODELVIEW );
-	}
-
-	if ( texture->hasMatrix ) {
-		qglMatrixMode( GL_TEXTURE );
-		qglLoadIdentity();
-		qglMatrixMode( GL_MODELVIEW );
-	}
-}
-
-
 
 //=============================================================================================
 
 
 /*
 =================
-RB_DetermineLightScale
-
-Sets:
-backEnd.lightScale
-backEnd.overBright
-
-Find out how much we are going to need to overscale the lighting, so we
-can down modulate the pre-lighting passes.
-
-We only look at light calculations, but an argument could be made that
-we should also look at surface evaluations, which would let surfaces
-overbright past 1.0
-=================
-*/
-void RB_DetermineLightScale( void ) {
-	viewLight_t			*vLight;
-	const idMaterial	*shader;
-	float				max;
-	int					i, j, numStages;
-	const shaderStage_t	*stage;
-
-	// the light scale will be based on the largest color component of any surface
-	// that will be drawn.
-	// should we consider separating rgb scales?
-
-	// if there are no lights, this will remain at 1.0, so GUI-only
-	// rendering will not lose any bits of precision
-	max = 1.0;
-
-	for ( vLight = backEnd.viewDef->viewLights ; vLight ; vLight = vLight->next ) {
-		// lights with no surfaces or shaderparms may still be present
-		// for debug display
-		if ( !vLight->localInteractions && !vLight->globalInteractions
-			&& !vLight->translucentInteractions ) {
-			continue;
-		}
-
-		shader = vLight->lightShader;
-		numStages = shader->GetNumStages();
-		for ( i = 0 ; i < numStages ; i++ ) {
-			stage = shader->GetStage( i );
-			for ( j = 0 ; j < 3 ; j++ ) {
-				float	v = r_lightScale.GetFloat() * vLight->shaderRegisters[ stage->color.registers[j] ];
-				if ( v > max ) {
-					max = v;
-				}
-			}
-		}
-	}
-
-	backEnd.pc.maxLightValue = max;
-	if ( max <= tr.backEndRendererMaxLight ) {
-		backEnd.lightScale = r_lightScale.GetFloat();
-		backEnd.overBright = 1.0;
-	} else {
-		backEnd.lightScale = r_lightScale.GetFloat() * tr.backEndRendererMaxLight / max;
-		backEnd.overBright = max / tr.backEndRendererMaxLight;
-	}
-}
-
-
-/*
-=================
 RB_BeginDrawingView
 
 Any mirrored or portaled views have already been drawn, so prepare
@@ -560,14 +464,14 @@ void RB_BeginDrawingView (void) {
 	qglMatrixMode(GL_MODELVIEW);
 
 	// set the window clipping
-	qglViewport( tr.viewportOffset[0] + backEnd.viewDef->viewport.x1,
-		tr.viewportOffset[1] + backEnd.viewDef->viewport.y1,
+	qglViewport( tr.viewportOffset[0] + backEnd.viewDef->viewport.x1, 
+		tr.viewportOffset[1] + backEnd.viewDef->viewport.y1, 
 		backEnd.viewDef->viewport.x2 + 1 - backEnd.viewDef->viewport.x1,
 		backEnd.viewDef->viewport.y2 + 1 - backEnd.viewDef->viewport.y1 );
 
 	// the scissor may be smaller than the viewport for subviews
-	qglScissor( tr.viewportOffset[0] + backEnd.viewDef->viewport.x1 + backEnd.viewDef->scissor.x1,
-		tr.viewportOffset[1] + backEnd.viewDef->viewport.y1 + backEnd.viewDef->scissor.y1,
+	qglScissor( tr.viewportOffset[0] + backEnd.viewDef->viewport.x1 + backEnd.viewDef->scissor.x1, 
+		tr.viewportOffset[1] + backEnd.viewDef->viewport.y1 + backEnd.viewDef->scissor.y1, 
 		backEnd.viewDef->scissor.x2 + 1 - backEnd.viewDef->scissor.x1,
 		backEnd.viewDef->scissor.y2 + 1 - backEnd.viewDef->scissor.y1 );
 	backEnd.currentScissor = backEnd.viewDef->scissor;
@@ -668,12 +572,12 @@ static void RB_SubmittInteraction( drawInteraction_t *din, void (*DrawInteractio
 	}
 
 	// if we wouldn't draw anything, don't call the Draw function
-	if (
-		( ( din->diffuseColor[0] > 0 ||
-		din->diffuseColor[1] > 0 ||
+	if ( 
+		( ( din->diffuseColor[0] > 0 || 
+		din->diffuseColor[1] > 0 || 
 		din->diffuseColor[2] > 0 ) && din->diffuseImage != globalImages->blackImage )
-		|| ( ( din->specularColor[0] > 0 ||
-		din->specularColor[1] > 0 ||
+		|| ( ( din->specularColor[0] > 0 || 
+		din->specularColor[1] > 0 || 
 		din->specularColor[2] > 0 ) && din->specularImage != globalImages->blackImage ) ) {
 		DrawInteraction( din );
 	}
@@ -699,6 +603,8 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 		return;
 	}
 
+	RENDERLOG_PRINTF("---------- RB_CreateSingleDrawInteractions %s on %s ----------\n", lightShader->GetName(), surfaceShader->GetName());
+
 	// change the matrix and light projection vectors if needed
 	if ( surf->space != backEnd.currentSpace ) {
 		backEnd.currentSpace = surf->space;
@@ -708,7 +614,7 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 	// change the scissor if needed
 	if ( r_useScissor.GetBool() && !backEnd.currentScissor.Equals( surf->scissorRect ) ) {
 		backEnd.currentScissor = surf->scissorRect;
-		qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1,
+		qglScissor( backEnd.viewDef->viewport.x1 + backEnd.currentScissor.x1, 
 			backEnd.viewDef->viewport.y1 + backEnd.currentScissor.y1,
 			backEnd.currentScissor.x2 + 1 - backEnd.currentScissor.x1,
 			backEnd.currentScissor.y2 + 1 - backEnd.currentScissor.y1 );
@@ -716,11 +622,11 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 
 	// hack depth range if needed
 	if ( surf->space->weaponDepthHack ) {
-		RB_EnterWeaponDepthHack();
+		RB_EnterWeaponDepthHack( surf );
 	}
 
 	if ( surf->space->modelDepthHack ) {
-		RB_EnterModelDepthHack( surf->space->modelDepthHack );
+		RB_EnterModelDepthHack( surf );
 	}
 
 	inter.surf = surf;
@@ -761,15 +667,20 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 		inter.diffuseColor[0] = inter.diffuseColor[1] = inter.diffuseColor[2] = inter.diffuseColor[3] = 0;
 		inter.specularColor[0] = inter.specularColor[1] = inter.specularColor[2] = inter.specularColor[3] = 0;
 
-		float lightColor[4];
-
-		// backEnd.lightScale is calculated so that lightColor[] will never exceed
-		// tr.backEndRendererMaxLight
-		lightColor[0] = backEnd.lightScale * lightRegs[ lightStage->color.registers[0] ];
-		lightColor[1] = backEnd.lightScale * lightRegs[ lightStage->color.registers[1] ];
-		lightColor[2] = backEnd.lightScale * lightRegs[ lightStage->color.registers[2] ];
-		lightColor[3] = lightRegs[ lightStage->color.registers[3] ];
-
+		const float lightScale = r_lightScale.GetFloat();
+		const idVec4 lightColor(
+			lightScale * lightRegs[ lightStage->color.registers[0] ],
+			lightScale * lightRegs[ lightStage->color.registers[1] ],
+			lightScale * lightRegs[ lightStage->color.registers[2] ],
+			lightRegs[ lightStage->color.registers[3] ] );
+		// apply the world-global overbright and the 2x factor for specular
+		const idVec4 diffuseColor = lightColor;
+		const idVec4 specularColor = lightColor * 2.0f;
+
+		// set the color modifiers
+		renderProgManager.SetRenderParm( RENDERPARM_DIFFUSEMODIFIER, diffuseColor.ToFloatPtr() );
+		renderProgManager.SetRenderParm( RENDERPARM_SPECULARMODIFIER, specularColor.ToFloatPtr() );
+		
 		// go through the individual stages
 		for ( int surfaceStageNum = 0 ; surfaceStageNum < surfaceShader->GetNumStages() ; surfaceStageNum++ ) {
 			const shaderStage_t	*surfaceStage = surfaceShader->GetStage( surfaceStageNum );
@@ -801,10 +712,6 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 					}
 					R_SetDrawInteraction( surfaceStage, surfaceRegs, &inter.diffuseImage,
 											inter.diffuseMatrix, inter.diffuseColor.ToFloatPtr() );
-					inter.diffuseColor[0] *= lightColor[0];
-					inter.diffuseColor[1] *= lightColor[1];
-					inter.diffuseColor[2] *= lightColor[2];
-					inter.diffuseColor[3] *= lightColor[3];
 					inter.vertexColor = surfaceStage->vertexColor;
 					break;
 				}
@@ -818,10 +725,6 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 					}
 					R_SetDrawInteraction( surfaceStage, surfaceRegs, &inter.specularImage,
 											inter.specularMatrix, inter.specularColor.ToFloatPtr() );
-					inter.specularColor[0] *= lightColor[0];
-					inter.specularColor[1] *= lightColor[1];
-					inter.specularColor[2] *= lightColor[2];
-					inter.specularColor[3] *= lightColor[3];
 					inter.vertexColor = surfaceStage->vertexColor;
 					break;
 				}
@@ -834,7 +737,7 @@ void RB_CreateSingleDrawInteractions( const drawSurf_t *surf, void (*DrawInterac
 
 	// unhack depth range if needed
 	if ( surf->space->weaponDepthHack || surf->space->modelDepthHack != 0.0f ) {
-		RB_LeaveDepthHack();
+		RB_LeaveDepthHack( surf );
 	}
 }
 
@@ -849,7 +752,7 @@ void RB_DrawView( const void *data ) {
 	cmd = (const drawSurfsCommand_t *)data;
 
 	backEnd.viewDef = cmd->viewDef;
-
+	
 	// we will need to do a new copyTexSubImage of the screen
 	// when a SS_POST_PROCESS material is used
 	backEnd.currentRenderCopied = false;
@@ -865,23 +768,10 @@ void RB_DrawView( const void *data ) {
 		return;
 	}
 
-	// skip render context sets the gl context to NULL,
-	// which should factor out the API cost, under the assumption
-	// that all gl calls just return if the context isn't valid
-	if ( r_skipRenderContext.GetBool() && backEnd.viewDef->viewEntitys ) {
-		GLimp_DeactivateContext();
-	}
-
 	backEnd.pc.c_surfaces += backEnd.viewDef->numDrawSurfs;
 
 	RB_ShowOverdraw();
 
 	// render the scene, jumping to the hardware specific interaction renderers
 	RB_STD_DrawView();
-
-	// restore the context for 2D drawing if we were stubbing it out
-	if ( r_skipRenderContext.GetBool() && backEnd.viewDef->viewEntitys ) {
-		GLimp_ActivateContext();
-		RB_SetDefaultGLState();
-	}
 }
diff --git a/neo/renderer/tr_stencilshadow.cpp b/neo/renderer/tr_stencilshadow.cpp
index 9b4278f..0dc7280 100644
--- a/neo/renderer/tr_stencilshadow.cpp
+++ b/neo/renderer/tr_stencilshadow.cpp
@@ -1243,11 +1243,7 @@ srfTriangles_t *R_CreateShadowVolume( const idRenderEntityLocal *ent,
 	// trades somewhat more overdraw and no cap optimizations for
 	// a very simple generation process
 	if ( optimize == SG_DYNAMIC && r_useTurboShadow.GetBool() ) {
-		if ( tr.backEndRendererHasVertexPrograms && r_useShadowVertexProgram.GetBool() ) {
-			return R_CreateVertexProgramTurboShadowVolume( ent, tri, light, cullInfo );
-		} else {
-			return R_CreateTurboShadowVolume( ent, tri, light, cullInfo );
-		}
+		return R_CreateTurboShadowVolume( ent, tri, light, cullInfo );
 	}
 
 	R_CalcInteractionFacing( ent, tri, light, cullInfo );
diff --git a/neo/sys/glimp.cpp b/neo/sys/glimp.cpp
index 1c31cb3..bdaa2ee 100644
--- a/neo/sys/glimp.cpp
+++ b/neo/sys/glimp.cpp
@@ -31,22 +31,37 @@ If you have questions concerning this license or the applicable additional terms
 
 #include "sys/platform.h"
 #include "framework/Licensee.h"
+#include "idlib/containers/Sort.h"
 
 #include "renderer/tr_local.h"
+#if defined(_WIN32)
+#include "sys/win32/win_local.h"
+#endif
 
 idCVar in_nograb("in_nograb", "0", CVAR_SYSTEM | CVAR_NOCHEAT, "prevents input grabbing");
-idCVar r_waylandcompat("r_waylandcompat", "0", CVAR_SYSTEM | CVAR_NOCHEAT | CVAR_ARCHIVE, "wayland compatible framebuffer");
+idCVar r_useOpenGL32( "r_useOpenGL32", "1", CVAR_INTEGER, "0 = OpenGL 2.0, 1 = OpenGL 3.2 compatibility profile, 2 = OpenGL 3.2 core profile", 0, 2 );
 
 static bool grabbed = false;
 
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-static SDL_Window *window = NULL;
-static SDL_GLContext context = NULL;
-#else
-static SDL_Surface *window = NULL;
-#define SDL_WINDOW_OPENGL SDL_OPENGL
-#define SDL_WINDOW_FULLSCREEN SDL_FULLSCREEN
-#endif
+SDL_Window *SDL_window = NULL;
+static SDL_GLContext *SDL_glContext = NULL;
+
+/*
+===================
+GLimp_PreInit
+
+ R_GetModeListForDisplay is called before GLimp_Init(), but SDL needs SDL_Init() first.
+ So do that in GLimp_PreInit()
+ Calling that function more than once doesn't make a difference
+===================
+*/
+void GLimp_PreInit() {
+	if( !SDL_WasInit( SDL_INIT_VIDEO ) ){
+		if( SDL_Init( SDL_INIT_VIDEO ) )
+			common->Error( "Error while initializing SDL: %s", SDL_GetError() );
+	}
+}
+
 
 /*
 ===================
@@ -54,148 +69,197 @@ GLimp_Init
 ===================
 */
 bool GLimp_Init(glimpParms_t parms) {
-	common->Printf("Initializing OpenGL subsystem\n");
+	common->Printf( "Initializing OpenGL subsystem\n" );
 
-	assert(SDL_WasInit(SDL_INIT_VIDEO));
+	GLimp_PreInit();
 
-	Uint32 flags = SDL_WINDOW_OPENGL;
+	Uint32 flags = SDL_WINDOW_SHOWN | SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE;
 
 	if (parms.fullScreen)
 		flags |= SDL_WINDOW_FULLSCREEN;
 
-	int colorbits = 24;
-	int depthbits = 24;
-	int stencilbits = 8;
-
-	for (int i = 0; i < 16; i++) {
-		// 0 - default
-		// 1 - minus colorbits
-		// 2 - minus depthbits
-		// 3 - minus stencil
-		if ((i % 4) == 0 && i) {
-			// one pass, reduce
-			switch (i / 4) {
-			case 2 :
-				if (colorbits == 24)
-					colorbits = 16;
-				break;
-			case 1 :
-				if (depthbits == 24)
-					depthbits = 16;
-				else if (depthbits == 16)
-					depthbits = 8;
-			case 3 :
-				if (stencilbits == 24)
-					stencilbits = 16;
-				else if (stencilbits == 16)
-					stencilbits = 8;
-			}
-		}
+	SDL_GL_SetAttribute (SDL_GL_RED_SIZE, 8);
+	SDL_GL_SetAttribute (SDL_GL_GREEN_SIZE, 8);
+	SDL_GL_SetAttribute (SDL_GL_BLUE_SIZE, 8);
+	SDL_GL_SetAttribute (SDL_GL_ALPHA_SIZE, 8);
+	SDL_GL_SetAttribute (SDL_GL_DEPTH_SIZE, 24);
+	SDL_GL_SetAttribute (SDL_GL_STENCIL_SIZE, 8);
 
-		int tcolorbits = colorbits;
-		int tdepthbits = depthbits;
-		int tstencilbits = stencilbits;
+	SDL_GL_SetAttribute(SDL_GL_STEREO, parms.stereo ? 1 : 0);
 
-		if ((i % 4) == 3) {
-			// reduce colorbits
-			if (tcolorbits == 24)
-				tcolorbits = 16;
-		}
+	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, parms.multiSamples ? 1 : 0);
+	SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, parms.multiSamples);
 
-		if ((i % 4) == 2) {
-			// reduce depthbits
-			if (tdepthbits == 24)
-				tdepthbits = 16;
-			else if (tdepthbits == 16)
-				tdepthbits = 8;
-		}
+	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
 
-		if ((i % 4) == 1) {
-			// reduce stencilbits
-			if (tstencilbits == 24)
-				tstencilbits = 16;
-			else if (tstencilbits == 16)
-				tstencilbits = 8;
-			else
-				tstencilbits = 0;
+	if( r_useOpenGL32.GetInteger() > 0 ) {
+		SDL_GL_SetAttribute( SDL_GL_CONTEXT_MAJOR_VERSION, 3 );
+		SDL_GL_SetAttribute( SDL_GL_CONTEXT_MINOR_VERSION, 2 );
+		if( r_useOpenGL32.GetInteger() > 1 ) {
+			SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE );
+		} else {
+			SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY );
+		}
+			
+		if( r_debugContext.GetBool() ) {
+			SDL_GL_SetAttribute( SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG );
 		}
+	}
 
-		int channelcolorbits = 4;
-		if (tcolorbits == 24)
-			channelcolorbits = 8;
-
-		SDL_GL_SetAttribute(SDL_GL_RED_SIZE, channelcolorbits);
-		SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, channelcolorbits);
-		SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, channelcolorbits);
-		SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
-		SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, tdepthbits);
-		SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, tstencilbits);
-
-		if (r_waylandcompat.GetBool())
-			SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 0);
-		else
-			SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, channelcolorbits);
-
-		SDL_GL_SetAttribute(SDL_GL_STEREO, parms.stereo ? 1 : 0);
-
-		SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, parms.multiSamples ? 1 : 0);
-		SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, parms.multiSamples);
-
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-		window = SDL_CreateWindow(GAME_NAME,
-									SDL_WINDOWPOS_UNDEFINED,
-									SDL_WINDOWPOS_UNDEFINED,
-									parms.width, parms.height, flags);
-		context = SDL_GL_CreateContext(window);
-
-		if (!window) {
-			common->DPrintf("Couldn't set GL mode %d/%d/%d: %s",
-							channelcolorbits, tdepthbits, tstencilbits, SDL_GetError());
-			continue;
+	int windowPos = SDL_WINDOWPOS_UNDEFINED;
+	if( parms.fullScreen > 0 ) {
+		if( parms.fullScreen > SDL_GetNumVideoDisplays() ) {
+			common->Warning( "Couldn't set display to num %i because we only have %i displays",
+							 parms.fullScreen, SDL_GetNumVideoDisplays() );
+		} else {
+			// -1 because SDL starts counting displays at 0, while parms.fullScreen starts at 1
+			windowPos = SDL_WINDOWPOS_UNDEFINED_DISPLAY( ( parms.fullScreen - 1 ) );
 		}
+	}
+	// TODO: if parms.fullScreen == -1 there should be a borderless window spanning multiple displays
+	/*
+	 * NOTE that this implicitly handles parms.fullScreen == -2 (from r_fullscreen -2) meaning
+	 * "do fullscreen, but I don't care on what monitor", at least on my box it's the monitor with
+	 * the mouse cursor.
+	 */
+	// Destroy existing state if it exists
+	if( SDL_glContext != NULL )	{
+		SDL_GL_DeleteContext( SDL_glContext );
+		SDL_glContext = NULL;
+	}
 
-		if (SDL_GL_SetSwapInterval(r_swapInterval.GetInteger()) < 0)
-			common->Warning("SDL_GL_SWAP_CONTROL not supported");
+	if( SDL_window != NULL ) {
+		SDL_GetWindowPosition( SDL_window, &windowPos, &windowPos );
+		common->DPrintf( "Existing window at %dx%d before being destroyed\n", windowPos, windowPos );
+		SDL_DestroyWindow( SDL_window );
+		SDL_window = NULL;
+	}
 
-		SDL_GetWindowSize(window, &glConfig.vidWidth, &glConfig.vidHeight);
+	if( ( SDL_window = SDL_CreateWindow( GAME_NAME, windowPos, windowPos, parms.width, parms.height, flags ) ) == 0 ) {
+		common->DPrintf( "SDL_CreateWindow failed: %s\n", SDL_GetError( ) );
+		return false;
+	}
 
-		glConfig.isFullscreen = (SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN) == SDL_WINDOW_FULLSCREEN;
-#else
-		SDL_WM_SetCaption(GAME_NAME, GAME_NAME);
+	if( ( SDL_glContext = (SDL_GLContext *)SDL_GL_CreateContext( SDL_window ) ) == NULL ) {
+		common->DPrintf( "SDL_GL_CreateContext failed: %s\n", SDL_GetError( ) );
+		return false;
+	}
 
-		if (SDL_GL_SetAttribute(SDL_GL_SWAP_CONTROL, r_swapInterval.GetInteger()) < 0)
-			common->Warning("SDL_GL_SWAP_CONTROL not supported");
+	if( SDL_GL_MakeCurrent( SDL_window, SDL_glContext ) < 0 ) {
+		common->DPrintf( "SDL_GL_MakeCurrent failed: %s\n", SDL_GetError( ) );
+		return false;
+	}
 
-		window = SDL_SetVideoMode(parms.width, parms.height, colorbits, flags);
-		if (!window) {
-			common->DPrintf("Couldn't set GL mode %d/%d/%d: %s",
-							channelcolorbits, tdepthbits, tstencilbits, SDL_GetError());
-			continue;
-		}
+	if (SDL_GL_SetSwapInterval(r_swapInterval.GetInteger()) < 0)
+		common->Warning("SDL_GL_SWAP_CONTROL not supported");
 
-		glConfig.vidWidth = window->w;
-		glConfig.vidHeight = window->h;
+	SDL_GetWindowSize( SDL_window, &glConfig.vidWidth, &glConfig.vidHeight );
 
-		glConfig.isFullscreen = (window->flags & SDL_FULLSCREEN) == SDL_FULLSCREEN;
-#endif
+	glConfig.isFullscreen = (SDL_GetWindowFlags( SDL_window ) & SDL_WINDOW_FULLSCREEN) == SDL_WINDOW_FULLSCREEN;
+	
+	glConfig.colorBits = 24;
+	glConfig.depthBits = 24;
+	glConfig.stencilBits = 8;
+	
+	glConfig.displayFrequency = 60;
 
-		common->Printf("Using %d color bits, %d depth, %d stencil display\n",
-						channelcolorbits, tdepthbits, tstencilbits);
+	// make sure cursor is not visible and grab window focus
+	SDL_ShowCursor( SDL_DISABLE );
+	SDL_SetWindowGrab( SDL_window, SDL_TRUE );
 
-		glConfig.colorBits = tcolorbits;
-		glConfig.depthBits = tdepthbits;
-		glConfig.stencilBits = tstencilbits;
+	return true;
+}
 
-		glConfig.displayFrequency = 0;
 
-		break;
+// SDL1 doesn't support multiple displays, so the source is much shorter and doesn't need seperate functions
+// makes sure the window will be full-screened on the right display and returns the SDL display index
+static int ScreenParmsHandleDisplayIndex( glimpParms_t parms )
+{
+	int displayIdx;
+	if( parms.fullScreen > 0 )
+	{
+		displayIdx = parms.fullScreen - 1; // first display for SDL is 0, in parms it's 1
+	}
+	else // -2 == use current display
+	{
+		displayIdx = SDL_GetWindowDisplayIndex( SDL_window );
+		if( displayIdx < 0 ) // for some reason the display for the window couldn't be detected
+			displayIdx = 0;
+	}
+	
+	if( parms.fullScreen > SDL_GetNumVideoDisplays() )
+	{
+		common->Warning( "Can't set fullscreen mode to display number %i, because SDL2 only knows about %i displays!",
+						 parms.fullScreen, SDL_GetNumVideoDisplays() );
+		return -1;
+	}
+	
+	if( parms.fullScreen != glConfig.isFullscreen )
+	{
+		// we have to switch to another display
+		if( glConfig.isFullscreen )
+		{
+			// if we're already in fullscreen mode but want to switch to another monitor
+			// we have to go to windowed mode first to move the window.. SDL-oddity.
+			SDL_SetWindowFullscreen( SDL_window, SDL_FALSE );
+		}
+		// select display ; SDL_WINDOWPOS_UNDEFINED_DISPLAY() doesn't work.
+		int x = SDL_WINDOWPOS_CENTERED_DISPLAY( displayIdx );
+		// move window to the center of selected display
+		SDL_SetWindowPosition( SDL_window, x, x );
 	}
+	return displayIdx;
+}
 
-	if (!window) {
-		common->Warning("No usable GL mode found: %s", SDL_GetError());
+static bool SetScreenParmsFullscreen( glimpParms_t parms )
+{
+	SDL_DisplayMode m = {0};
+	int displayIdx = ScreenParmsHandleDisplayIndex( parms );
+	if( displayIdx < 0 )
+		return false;
+		
+	// get current mode of display the window should be full-screened on
+	SDL_GetCurrentDisplayMode( displayIdx, &m );
+	
+	// change settings in that display mode according to parms
+	// FIXME: check if refreshrate, width and height are supported?
+	// m.refresh_rate = parms.displayHz;
+	m.w = parms.width;
+	m.h = parms.height;
+	
+	// set that displaymode
+	if( SDL_SetWindowDisplayMode( SDL_window, &m ) < 0 )
+	{
+		common->Warning( "Couldn't set window mode for fullscreen, reason: %s", SDL_GetError() );
 		return false;
 	}
+	
+	// if we're currently not in fullscreen mode, we need to switch to fullscreen
+	if( !( SDL_GetWindowFlags( SDL_window ) & SDL_WINDOW_FULLSCREEN ) )
+	{
+		if( SDL_SetWindowFullscreen( SDL_window, SDL_TRUE ) < 0 )
+		{
+			common->Warning( "Couldn't switch to fullscreen mode, reason: %s!", SDL_GetError() );
+			return false;
+		}
+	}
+	return true;
+}
 
+static bool SetScreenParmsWindowed( glimpParms_t parms )
+{
+	SDL_SetWindowSize( SDL_window, parms.width, parms.height );
+	SDL_SetWindowPosition( SDL_window, parms.x, parms.y );
+	
+	// if we're currently in fullscreen mode, we need to disable that
+	if( SDL_GetWindowFlags( SDL_window ) & SDL_WINDOW_FULLSCREEN )
+	{
+		if( SDL_SetWindowFullscreen( SDL_window, SDL_FALSE ) < 0 )
+		{
+			common->Warning( "Couldn't switch to windowed mode, reason: %s!", SDL_GetError() );
+			return false;
+		}
+	}
 	return true;
 }
 
@@ -204,8 +268,33 @@ bool GLimp_Init(glimpParms_t parms) {
 GLimp_SetScreenParms
 ===================
 */
-bool GLimp_SetScreenParms(glimpParms_t parms) {
-	common->DPrintf("TODO: GLimp_ActivateContext\n");
+bool GLimp_SetScreenParms( glimpParms_t parms ) {
+	if( parms.fullScreen > 0 || parms.fullScreen == -2 )
+	{
+		if( !SetScreenParmsFullscreen( parms ) )
+			return false;
+	}
+	else if( parms.fullScreen == 0 ) // windowed mode
+	{
+		if( !SetScreenParmsWindowed( parms ) )
+			return false;
+	}
+	else
+	{
+		common->Warning( "GLimp_SetScreenParms: fullScreen -1 (borderless window for multiple displays) currently unsupported!" );
+		return false;
+	}
+
+	SDL_GL_SetAttribute( SDL_GL_STEREO, parms.stereo ? 1 : 0 );
+	
+	SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, parms.multiSamples ? 1 : 0 );
+	SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, parms.multiSamples );
+	
+	glConfig.isFullscreen = parms.fullScreen;
+	glConfig.vidWidth = parms.width;
+	glConfig.vidHeight = parms.height;
+	glConfig.displayFrequency = parms.displayHz;
+	
 	return true;
 }
 
@@ -217,17 +306,15 @@ GLimp_Shutdown
 void GLimp_Shutdown() {
 	common->Printf("Shutting down OpenGL subsystem\n");
 
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-	if (context) {
-		SDL_GL_DeleteContext(context);
-		context = NULL;
+	if ( SDL_glContext ) {
+		SDL_GL_DeleteContext( SDL_glContext );
+		SDL_glContext = NULL;
 	}
 
-	if (window) {
-		SDL_DestroyWindow(window);
-		window = NULL;
+	if ( SDL_window ) {
+		SDL_DestroyWindow( SDL_window );
+		SDL_window = NULL;
 	}
-#endif
 }
 
 /*
@@ -236,11 +323,7 @@ GLimp_SwapBuffers
 ===================
 */
 void GLimp_SwapBuffers() {
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-	SDL_GL_SwapWindow(window);
-#else
-	SDL_GL_SwapBuffers();
-#endif
+	SDL_GL_SwapWindow( SDL_window );
 }
 
 /*
@@ -249,38 +332,16 @@ GLimp_SetGamma
 =================
 */
 void GLimp_SetGamma(unsigned short red[256], unsigned short green[256], unsigned short blue[256]) {
-	if (!window) {
+	if ( !SDL_window ) {
 		common->Warning("GLimp_SetGamma called without window");
 		return;
 	}
 
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-	if (SDL_SetWindowGammaRamp(window, red, green, blue))
-#else
-	if (SDL_SetGammaRamp(red, green, blue))
-#endif
+	if (SDL_SetWindowGammaRamp( SDL_window, red, green, blue ))
 		common->Warning("Couldn't set gamma ramp: %s", SDL_GetError());
 }
 
 /*
-=================
-GLimp_ActivateContext
-=================
-*/
-void GLimp_ActivateContext() {
-	common->DPrintf("TODO: GLimp_ActivateContext\n");
-}
-
-/*
-=================
-GLimp_DeactivateContext
-=================
-*/
-void GLimp_DeactivateContext() {
-	common->DPrintf("TODO: GLimp_DeactivateContext\n");
-}
-
-/*
 ===================
 GLimp_ExtensionPointer
 ===================
@@ -294,26 +355,106 @@ GLExtension_t GLimp_ExtensionPointer(const char *name) {
 void GLimp_GrabInput(int flags) {
 	bool grab = flags & GRAB_ENABLE;
 
-	if (grab && (flags & GRAB_REENABLE))
+	if ( grab && (flags & GRAB_REENABLE) )
 		grab = false;
 
-	if (flags & GRAB_SETSTATE)
+	if ( flags & GRAB_SETSTATE )
 		grabbed = grab;
 
-	if (in_nograb.GetBool())
+	if ( in_nograb.GetBool() )
 		grab = false;
 
-	if (!window) {
+	if ( !SDL_window ) {
 		common->Warning("GLimp_GrabInput called without window");
 		return;
 	}
 
-#if SDL_VERSION_ATLEAST(2, 0, 0)
-	SDL_ShowCursor(flags & GRAB_HIDECURSOR ? SDL_DISABLE : SDL_ENABLE);
-	SDL_SetRelativeMouseMode(flags & GRAB_HIDECURSOR ? SDL_TRUE : SDL_FALSE);
-	SDL_SetWindowGrab(window, grab ? SDL_TRUE : SDL_FALSE);
-#else
-	SDL_ShowCursor(flags & GRAB_HIDECURSOR ? SDL_DISABLE : SDL_ENABLE);
-	SDL_WM_GrabInput(grab ? SDL_GRAB_ON : SDL_GRAB_OFF);
-#endif
+	SDL_SetRelativeMouseMode( flags & GRAB_ENABLE ? SDL_TRUE : SDL_FALSE );
+	SDL_SetWindowGrab( SDL_window, grab ? SDL_TRUE : SDL_FALSE );
+}
+
+class idSort_VidMode : public idSort_Quick< vidMode_t, idSort_VidMode > {
+public:
+	int Compare( const vidMode_t& a, const vidMode_t& b ) const {
+		int wd = a.width - b.width;
+		int hd = a.height - b.height;
+		int fd = a.displayHz - b.displayHz;
+		return ( hd != 0 ) ? hd : ( wd != 0 ) ? wd : fd;
+	}
+};
+
+// RB: resolutions supported by XreaL
+static void FillStaticVidModes( idList<vidMode_t>& modeList ) {
+	modeList.AddUnique( vidMode_t( 320,   240, 60 ) );
+	modeList.AddUnique( vidMode_t( 400,   300, 60 ) );
+	modeList.AddUnique( vidMode_t( 512,   384, 60 ) );
+	modeList.AddUnique( vidMode_t( 640,   480, 60 ) );
+	modeList.AddUnique( vidMode_t( 800,   600, 60 ) );
+	modeList.AddUnique( vidMode_t( 960,   720, 60 ) );
+	modeList.AddUnique( vidMode_t( 1024,  768, 60 ) );
+	modeList.AddUnique( vidMode_t( 1152,  864, 60 ) );
+	modeList.AddUnique( vidMode_t( 1280,  720, 60 ) );
+	modeList.AddUnique( vidMode_t( 1280,  768, 60 ) );
+	modeList.AddUnique( vidMode_t( 1280,  800, 60 ) );
+	modeList.AddUnique( vidMode_t( 1280, 1024, 60 ) );
+	modeList.AddUnique( vidMode_t( 1360,  768, 60 ) );
+	modeList.AddUnique( vidMode_t( 1440,  900, 60 ) );
+	modeList.AddUnique( vidMode_t( 1680, 1050, 60 ) );
+	modeList.AddUnique( vidMode_t( 1600, 1200, 60 ) );
+	modeList.AddUnique( vidMode_t( 1920, 1080, 60 ) );
+	modeList.AddUnique( vidMode_t( 1920, 1200, 60 ) );
+	modeList.AddUnique( vidMode_t( 2048, 1536, 60 ) );
+	modeList.AddUnique( vidMode_t( 2560, 1600, 60 ) );
+	
+	modeList.SortWithTemplate( idSort_VidMode() );
+}
+
+/*
+====================
+R_GetModeListForDisplay
+====================
+*/
+bool R_GetModeListForDisplay( const int requestedDisplayNum, idList<vidMode_t>& modeList ) {
+	assert( requestedDisplayNum >= 0 );
+	
+	modeList.Clear();
+
+	if( requestedDisplayNum >= SDL_GetNumVideoDisplays() ) {
+		// requested invalid displaynum
+		return false;
+	}
+	
+	int numModes = SDL_GetNumDisplayModes( requestedDisplayNum );
+	if( numModes > 0 ) {
+		for( int i = 0; i < numModes; i++ ) {
+			SDL_DisplayMode m;
+			int ret = SDL_GetDisplayMode( requestedDisplayNum, i, &m );
+			if( ret != 0 ) {
+				common->Warning( "Can't get video mode no %i, because of %s\n", i, SDL_GetError() );
+				continue;
+			}
+			
+			vidMode_t mode;
+			mode.width = m.w;
+			mode.height = m.h;
+			mode.displayHz = m.refresh_rate ? m.refresh_rate : 60; // default to 60 if unknown (0)
+			modeList.AddUnique( mode );
+		}
+		
+		if( modeList.Num() < 1 ) {
+			common->Warning( "Couldn't get a single video mode for display %i, using default ones..!\n", requestedDisplayNum );
+			FillStaticVidModes( modeList );
+		}
+		
+		// sort with lowest resolution first
+		modeList.SortWithTemplate( idSort_VidMode() );
+	} else {
+		common->Warning( "Can't get Video Info, using default modes...\n" );
+		if( numModes < 0 ) {
+			common->Warning( "Reason was: %s\n", SDL_GetError() );
+		}
+		FillStaticVidModes( modeList );
+	}
+	
+	return true;
 }
